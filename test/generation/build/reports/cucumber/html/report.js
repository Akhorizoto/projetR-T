$(document).ready(function() {var formatter = new CucumberHTML.DOMFormatter($('.cucumber-report'));formatter.uri("CAPEC_100_Step_1_1.feature");
formatter.feature({
  "line": 2,
  "name": "CAPEC-100: Overflow Buffers",
  "description": "",
  "id": "capec-100:-overflow-buffers",
  "keyword": "Feature",
  "tags": [
    {
      "line": 1,
      "name": "@capec100"
    }
  ]
});
formatter.scenario({
  "comments": [
    {
      "line": 3,
      "value": "#1. Explore"
    }
  ],
  "line": 4,
  "name": "Step1.1",
  "description": "",
  "id": "capec-100:-overflow-buffers;step1.1",
  "type": "scenario",
  "keyword": "Scenario"
});
formatter.step({
  "line": 5,
  "name": "prepare to",
  "keyword": "Given "
});
formatter.step({
  "line": 6,
  "name": "Try to",
  "keyword": "When "
});
formatter.step({
  "comments": [
    {
      "line": 7,
      "value": "# assertion for attack step success"
    }
  ],
  "line": 8,
  "name": "Assert the success of",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 9,
      "value": "#assertions for security pattern testing (checker whether the pattern consequences are observed)"
    }
  ],
  "line": 10,
  "name": "assert the consequences of the pattern",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 11,
      "value": "#"
    }
  ],
  "line": 12,
  "name": "assert the consequences of the pattern audit interceptor",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 13,
      "value": "# depends secure logger"
    }
  ],
  "line": 14,
  "name": "assert the consequences of the pattern secure logger",
  "keyword": "Then "
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({
  "location": "PatternSteps.assauditinterceptor()"
});
formatter.result({
  "status": "skipped"
});
formatter.match({
  "location": "PatternSteps.asssecurelogger()"
});
formatter.result({
  "status": "skipped"
});
formatter.uri("CAPEC_100_Step_2_1.feature");
formatter.feature({
  "line": 2,
  "name": "CAPEC-100: Overflow Buffers",
  "description": "",
  "id": "capec-100:-overflow-buffers",
  "keyword": "Feature",
  "tags": [
    {
      "line": 1,
      "name": "@capec100"
    }
  ]
});
formatter.scenario({
  "comments": [
    {
      "line": 3,
      "value": "#2. Experiment"
    }
  ],
  "line": 4,
  "name": "Step2.1",
  "description": "",
  "id": "capec-100:-overflow-buffers;step2.1",
  "type": "scenario",
  "keyword": "Scenario"
});
formatter.step({
  "line": 5,
  "name": "prepare to",
  "keyword": "Given "
});
formatter.step({
  "line": 6,
  "name": "Try to",
  "keyword": "When "
});
formatter.step({
  "comments": [
    {
      "line": 7,
      "value": "# assertion for attack step success"
    }
  ],
  "line": 8,
  "name": "Assert the success of",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 9,
      "value": "#assertions for security pattern testing (checker whether the pattern consequences are observed)"
    }
  ],
  "line": 10,
  "name": "assert the consequences of the pattern",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 11,
      "value": "#"
    }
  ],
  "line": 12,
  "name": "assert the consequences of the pattern audit interceptor",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 13,
      "value": "# depends secure logger"
    }
  ],
  "line": 14,
  "name": "assert the consequences of the pattern secure logger",
  "keyword": "Then "
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({
  "location": "PatternSteps.assauditinterceptor()"
});
formatter.result({
  "status": "skipped"
});
formatter.match({
  "location": "PatternSteps.asssecurelogger()"
});
formatter.result({
  "status": "skipped"
});
formatter.uri("CAPEC_100_Step_3_1.feature");
formatter.feature({
  "line": 2,
  "name": "CAPEC-100: Overflow Buffers",
  "description": "",
  "id": "capec-100:-overflow-buffers",
  "keyword": "Feature",
  "tags": [
    {
      "line": 1,
      "name": "@capec100"
    }
  ]
});
formatter.scenario({
  "comments": [
    {
      "line": 3,
      "value": "#3. Exploit"
    }
  ],
  "line": 4,
  "name": "Step3.1",
  "description": "",
  "id": "capec-100:-overflow-buffers;step3.1",
  "type": "scenario",
  "keyword": "Scenario"
});
formatter.step({
  "line": 5,
  "name": "prepare to",
  "keyword": "Given "
});
formatter.step({
  "line": 6,
  "name": "Try to",
  "keyword": "When "
});
formatter.step({
  "comments": [
    {
      "line": 7,
      "value": "# assertion for attack step success"
    }
  ],
  "line": 8,
  "name": "Assert the success of",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 9,
      "value": "#assertions for security pattern testing (checker whether the pattern consequences are observed)"
    }
  ],
  "line": 10,
  "name": "assert the consequences of the pattern",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 11,
      "value": "#"
    }
  ],
  "line": 12,
  "name": "assert the consequences of the pattern audit interceptor",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 13,
      "value": "# depends secure logger"
    }
  ],
  "line": 14,
  "name": "assert the consequences of the pattern secure logger",
  "keyword": "Then "
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({
  "location": "PatternSteps.assauditinterceptor()"
});
formatter.result({
  "status": "skipped"
});
formatter.match({
  "location": "PatternSteps.asssecurelogger()"
});
formatter.result({
  "status": "skipped"
});
formatter.uri("CAPEC_101_Step_1_1.feature");
formatter.feature({
  "line": 2,
  "name": "CAPEC-101: Server Side Include (SSI) Injection",
  "description": "",
  "id": "capec-101:-server-side-include-(ssi)-injection",
  "keyword": "Feature",
  "tags": [
    {
      "line": 1,
      "name": "@capec101"
    }
  ]
});
formatter.scenario({
  "comments": [
    {
      "line": 3,
      "value": "#1. Explore"
    }
  ],
  "line": 4,
  "name": "Step1.1 Determine applicability",
  "description": "",
  "id": "capec-101:-server-side-include-(ssi)-injection;step1.1-determine-applicability",
  "type": "scenario",
  "keyword": "Scenario"
});
formatter.step({
  "line": 5,
  "name": "prepare to Determine applicability",
  "keyword": "Given "
});
formatter.step({
  "line": 6,
  "name": "Try to Determine applicability",
  "keyword": "When "
});
formatter.step({
  "comments": [
    {
      "line": 7,
      "value": "# assertion for attack step success"
    }
  ],
  "line": 8,
  "name": "Assert the success of Determine applicability",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 9,
      "value": "#assertions for security pattern testing (checker whether the pattern consequences are observed)"
    }
  ],
  "line": 10,
  "name": "assert the consequences of the pattern",
  "keyword": "Then "
});
formatter.match({
  "location": "determineapplicability.predetermineapplicability()"
});
formatter.result({
  "duration": 93580522,
  "status": "passed"
});
formatter.match({
  "location": "determineapplicability.trydetermineapplicability()"
});
formatter.result({
  "duration": 28549,
  "status": "passed"
});
formatter.match({
  "location": "determineapplicability.assdetermineapplicability()"
});
formatter.result({
  "duration": 27733,
  "status": "passed"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.uri("CAPEC_101_Step_1_2.feature");
formatter.feature({
  "line": 2,
  "name": "CAPEC-101: Server Side Include (SSI) Injection",
  "description": "",
  "id": "capec-101:-server-side-include-(ssi)-injection",
  "keyword": "Feature",
  "tags": [
    {
      "line": 1,
      "name": "@capec101"
    }
  ]
});
formatter.scenario({
  "comments": [
    {
      "line": 3,
      "value": "#1. Explore"
    }
  ],
  "line": 4,
  "name": "Step1.2 Attempt SSI",
  "description": "",
  "id": "capec-101:-server-side-include-(ssi)-injection;step1.2-attempt-ssi",
  "type": "scenario",
  "keyword": "Scenario"
});
formatter.step({
  "line": 5,
  "name": "prepare to Attempt SSI",
  "keyword": "Given "
});
formatter.step({
  "line": 6,
  "name": "Try to Attempt SSI",
  "keyword": "When "
});
formatter.step({
  "comments": [
    {
      "line": 7,
      "value": "# assertion for attack step success"
    }
  ],
  "line": 8,
  "name": "Assert the success of Attempt SSI",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 9,
      "value": "#assertions for security pattern testing (checker whether the pattern consequences are observed)"
    }
  ],
  "line": 10,
  "name": "assert the consequences of the pattern",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 11,
      "value": "#"
    }
  ],
  "line": 12,
  "name": "assert the consequences of the pattern audit interceptor",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 13,
      "value": "# depends secure logger"
    }
  ],
  "line": 14,
  "name": "assert the consequences of the pattern secure logger",
  "keyword": "Then "
});
formatter.match({
  "location": "attemptssi.preattemptssi()"
});
formatter.result({
  "duration": 26411253,
  "error_message": "net.continuumsecurity.proxy.ProxyException: org.zaproxy.clientapi.core.ClientApiException: java.net.ConnectException: Connection refused\n\tat net.continuumsecurity.proxy.ZAProxyScanner.validateMinimumRequiredZapVersion(ZAProxyScanner.java:96)\n\tat net.continuumsecurity.proxy.ZAProxyScanner.\u003cinit\u003e(ZAProxyScanner.java:38)\n\tat steps.attemptssi.preattemptssi(attemptssi.java:17)\n\tat ✽.Given prepare to Attempt SSI(CAPEC_101_Step_1_2.feature:5)\nCaused by: org.zaproxy.clientapi.core.ClientApiException: java.net.ConnectException: Connection refused\n\tat org.zaproxy.clientapi.core.ClientApi.callApiDom(ClientApi.java:307)\n\tat org.zaproxy.clientapi.core.ClientApi.callApi(ClientApi.java:289)\n\tat org.zaproxy.clientapi.gen.Core.version(Core.java:158)\n\tat net.continuumsecurity.proxy.ZAProxyScanner.validateMinimumRequiredZapVersion(ZAProxyScanner.java:85)\n\tat net.continuumsecurity.proxy.ZAProxyScanner.\u003cinit\u003e(ZAProxyScanner.java:38)\n\tat steps.attemptssi.preattemptssi(attemptssi.java:17)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.lang.reflect.Method.invoke(Method.java:498)\n\tat cucumber.runtime.Utils$1.call(Utils.java:37)\n\tat cucumber.runtime.Timeout.timeout(Timeout.java:13)\n\tat cucumber.runtime.Utils.invoke(Utils.java:31)\n\tat cucumber.runtime.java.JavaStepDefinition.execute(JavaStepDefinition.java:37)\n\tat cucumber.runtime.StepDefinitionMatch.runStep(StepDefinitionMatch.java:37)\n\tat cucumber.runtime.Runtime.runStep(Runtime.java:298)\n\tat cucumber.runtime.model.StepContainer.runStep(StepContainer.java:44)\n\tat cucumber.runtime.model.StepContainer.runSteps(StepContainer.java:39)\n\tat cucumber.runtime.model.CucumberScenario.run(CucumberScenario.java:48)\n\tat cucumber.runtime.junit.ExecutionUnitRunner.run(ExecutionUnitRunner.java:91)\n\tat cucumber.runtime.junit.FeatureRunner.runChild(FeatureRunner.java:63)\n\tat cucumber.runtime.junit.FeatureRunner.runChild(FeatureRunner.java:18)\n\tat org.junit.runners.ParentRunner$3.run(ParentRunner.java:238)\n\tat org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:63)\n\tat org.junit.runners.ParentRunner.runChildren(ParentRunner.java:236)\n\tat org.junit.runners.ParentRunner.access$000(ParentRunner.java:53)\n\tat org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:229)\n\tat org.junit.runners.ParentRunner.run(ParentRunner.java:309)\n\tat cucumber.runtime.junit.FeatureRunner.run(FeatureRunner.java:70)\n\tat cucumber.api.junit.Cucumber.runChild(Cucumber.java:93)\n\tat cucumber.api.junit.Cucumber.runChild(Cucumber.java:37)\n\tat org.junit.runners.ParentRunner$3.run(ParentRunner.java:238)\n\tat org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:63)\n\tat org.junit.runners.ParentRunner.runChildren(ParentRunner.java:236)\n\tat org.junit.runners.ParentRunner.access$000(ParentRunner.java:53)\n\tat org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:229)\n\tat org.junit.internal.runners.statements.RunAfters.evaluate(RunAfters.java:27)\n\tat org.junit.runners.ParentRunner.run(ParentRunner.java:309)\n\tat cucumber.api.junit.Cucumber.run(Cucumber.java:98)\n\tat org.eclipse.jdt.internal.junit4.runner.JUnit4TestReference.run(JUnit4TestReference.java:86)\n\tat org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:459)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:678)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:382)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:192)\nCaused by: java.net.ConnectException: Connection refused\n\tat java.net.PlainSocketImpl.socketConnect(Native Method)\n\tat java.net.AbstractPlainSocketImpl.doConnect(AbstractPlainSocketImpl.java:350)\n\tat java.net.AbstractPlainSocketImpl.connectToAddress(AbstractPlainSocketImpl.java:206)\n\tat java.net.AbstractPlainSocketImpl.connect(AbstractPlainSocketImpl.java:188)\n\tat java.net.Socket.connect(Socket.java:589)\n\tat java.net.Socket.connect(Socket.java:538)\n\tat sun.net.NetworkClient.doConnect(NetworkClient.java:180)\n\tat sun.net.www.http.HttpClient.openServer(HttpClient.java:432)\n\tat sun.net.www.http.HttpClient$1.run(HttpClient.java:484)\n\tat sun.net.www.http.HttpClient$1.run(HttpClient.java:482)\n\tat java.security.AccessController.doPrivileged(Native Method)\n\tat sun.net.www.http.HttpClient.privilegedOpenServer(HttpClient.java:481)\n\tat sun.net.www.http.HttpClient.openServer(HttpClient.java:522)\n\tat sun.net.www.http.HttpClient.\u003cinit\u003e(HttpClient.java:211)\n\tat sun.net.www.http.HttpClient.New(HttpClient.java:308)\n\tat sun.net.www.http.HttpClient.New(HttpClient.java:326)\n\tat sun.net.www.protocol.http.HttpURLConnection.getNewHttpClient(HttpURLConnection.java:1169)\n\tat sun.net.www.protocol.http.HttpURLConnection.plainConnect0(HttpURLConnection.java:1148)\n\tat sun.net.www.protocol.http.HttpURLConnection.plainConnect(HttpURLConnection.java:999)\n\tat sun.net.www.protocol.http.HttpURLConnection.connect(HttpURLConnection.java:933)\n\tat org.zaproxy.clientapi.core.ClientApi.getConnectionInputStream(ClientApi.java:313)\n\tat org.zaproxy.clientapi.core.ClientApi.callApiDom(ClientApi.java:305)\n\t... 44 more\n",
  "status": "failed"
});
formatter.match({
  "location": "attemptssi.tryattemptssi()"
});
formatter.result({
  "status": "skipped"
});
formatter.match({
  "location": "attemptssi.assattemptssi()"
});
formatter.result({
  "status": "skipped"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({
  "location": "PatternSteps.assauditinterceptor()"
});
formatter.result({
  "status": "skipped"
});
formatter.match({
  "location": "PatternSteps.asssecurelogger()"
});
formatter.result({
  "status": "skipped"
});
formatter.uri("CAPEC_101_Step_1_3.feature");
formatter.feature({
  "line": 2,
  "name": "CAPEC-101: Server Side Include (SSI) Injection",
  "description": "",
  "id": "capec-101:-server-side-include-(ssi)-injection",
  "keyword": "Feature",
  "tags": [
    {
      "line": 1,
      "name": "@capec101"
    }
  ]
});
formatter.scenario({
  "comments": [
    {
      "line": 3,
      "value": "#1. Explore"
    }
  ],
  "line": 4,
  "name": "Step1.3 Inject SSI",
  "description": "",
  "id": "capec-101:-server-side-include-(ssi)-injection;step1.3-inject-ssi",
  "type": "scenario",
  "keyword": "Scenario"
});
formatter.step({
  "line": 5,
  "name": "prepare to Inject SSI",
  "keyword": "Given "
});
formatter.step({
  "line": 6,
  "name": "Try to Inject SSI",
  "keyword": "When "
});
formatter.step({
  "comments": [
    {
      "line": 7,
      "value": "# assertion for attack step success"
    }
  ],
  "line": 8,
  "name": "Assert the success of Inject SSI",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 9,
      "value": "#assertions for security pattern testing (checker whether the pattern consequences are observed)"
    }
  ],
  "line": 10,
  "name": "assert the consequences of the pattern",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 11,
      "value": "#"
    }
  ],
  "line": 12,
  "name": "assert the consequences of the pattern audit interceptor",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 13,
      "value": "# depends secure logger"
    }
  ],
  "line": 14,
  "name": "assert the consequences of the pattern secure logger",
  "keyword": "Then "
});
formatter.match({
  "location": "injectssi.preinjectssi()"
});
formatter.result({
  "duration": 51193,
  "status": "passed"
});
formatter.match({
  "location": "injectssi.tryinjectssi()"
});
formatter.result({
  "duration": 12352,
  "status": "passed"
});
formatter.match({
  "location": "injectssi.assinjectssi()"
});
formatter.result({
  "duration": 12836,
  "status": "passed"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({
  "location": "PatternSteps.assauditinterceptor()"
});
formatter.result({
  "status": "skipped"
});
formatter.match({
  "location": "PatternSteps.asssecurelogger()"
});
formatter.result({
  "status": "skipped"
});
formatter.uri("CAPEC_102_Step_1_1.feature");
formatter.feature({
  "line": 2,
  "name": "CAPEC-102: Session Sidejacking",
  "description": "",
  "id": "capec-102:-session-sidejacking",
  "keyword": "Feature",
  "tags": [
    {
      "line": 1,
      "name": "@capec102"
    }
  ]
});
formatter.scenario({
  "comments": [
    {
      "line": 3,
      "value": "#1. Explore"
    }
  ],
  "line": 4,
  "name": "Step1.1 Detect Unprotected Session Token Transfer",
  "description": "",
  "id": "capec-102:-session-sidejacking;step1.1-detect-unprotected-session-token-transfer",
  "type": "scenario",
  "keyword": "Scenario"
});
formatter.step({
  "line": 5,
  "name": "prepare to Detect Unprotected Session Token Transfer",
  "keyword": "Given "
});
formatter.step({
  "line": 6,
  "name": "Try to Detect Unprotected Session Token Transfer",
  "keyword": "When "
});
formatter.step({
  "comments": [
    {
      "line": 7,
      "value": "# assertion for attack step success"
    }
  ],
  "line": 8,
  "name": "Assert the success of Detect Unprotected Session Token Transfer",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 9,
      "value": "#assertions for security pattern testing (checker whether the pattern consequences are observed)"
    }
  ],
  "line": 10,
  "name": "assert the consequences of the pattern",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 11,
      "value": "#"
    }
  ],
  "line": 12,
  "name": "assert the consequences of the pattern audit interceptor",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 13,
      "value": "# depends secure logger"
    }
  ],
  "line": 14,
  "name": "assert the consequences of the pattern secure logger",
  "keyword": "Then "
});
formatter.match({
  "location": "detectunprotectedsessiontokentransfer.predetectunprotectedsessiontokentransfer()"
});
formatter.result({
  "duration": 65310,
  "status": "passed"
});
formatter.match({
  "location": "detectunprotectedsessiontokentransfer.trydetectunprotectedsessiontokentransfer()"
});
formatter.result({
  "duration": 17513,
  "status": "passed"
});
formatter.match({
  "location": "detectunprotectedsessiontokentransfer.assdetectunprotectedsessiontokentransfer()"
});
formatter.result({
  "duration": 33095,
  "status": "passed"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({
  "location": "PatternSteps.assauditinterceptor()"
});
formatter.result({
  "status": "skipped"
});
formatter.match({
  "location": "PatternSteps.asssecurelogger()"
});
formatter.result({
  "status": "skipped"
});
formatter.uri("CAPEC_102_Step_2_1.feature");
formatter.feature({
  "line": 2,
  "name": "CAPEC-102: Session Sidejacking",
  "description": "",
  "id": "capec-102:-session-sidejacking",
  "keyword": "Feature",
  "tags": [
    {
      "line": 1,
      "name": "@capec102"
    }
  ]
});
formatter.scenario({
  "comments": [
    {
      "line": 3,
      "value": "#2. Experiment"
    }
  ],
  "line": 4,
  "name": "Step2.1 Capture session token",
  "description": "",
  "id": "capec-102:-session-sidejacking;step2.1-capture-session-token",
  "type": "scenario",
  "keyword": "Scenario"
});
formatter.step({
  "line": 5,
  "name": "prepare to Capture session token",
  "keyword": "Given "
});
formatter.step({
  "line": 6,
  "name": "Try to Capture session token",
  "keyword": "When "
});
formatter.step({
  "comments": [
    {
      "line": 7,
      "value": "# assertion for attack step success"
    }
  ],
  "line": 8,
  "name": "Assert the success of Capture session token",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 9,
      "value": "#assertions for security pattern testing (checker whether the pattern consequences are observed)"
    }
  ],
  "line": 10,
  "name": "assert the consequences of the pattern",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 11,
      "value": "#"
    }
  ],
  "line": 12,
  "name": "assert the consequences of the pattern audit interceptor",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 13,
      "value": "# depends secure logger"
    }
  ],
  "line": 14,
  "name": "assert the consequences of the pattern secure logger",
  "keyword": "Then "
});
formatter.match({
  "location": "capturesessiontoken.precapturesessiontoken()"
});
formatter.result({
  "duration": 2268010,
  "error_message": "net.continuumsecurity.proxy.ProxyException: org.zaproxy.clientapi.core.ClientApiException: java.net.ConnectException: Connection refused\n\tat net.continuumsecurity.proxy.ZAProxyScanner.validateMinimumRequiredZapVersion(ZAProxyScanner.java:96)\n\tat net.continuumsecurity.proxy.ZAProxyScanner.\u003cinit\u003e(ZAProxyScanner.java:38)\n\tat steps.capturesessiontoken.precapturesessiontoken(capturesessiontoken.java:25)\n\tat ✽.Given prepare to Capture session token(CAPEC_102_Step_2_1.feature:5)\nCaused by: org.zaproxy.clientapi.core.ClientApiException: java.net.ConnectException: Connection refused\n\tat org.zaproxy.clientapi.core.ClientApi.callApiDom(ClientApi.java:307)\n\tat org.zaproxy.clientapi.core.ClientApi.callApi(ClientApi.java:289)\n\tat org.zaproxy.clientapi.gen.Core.version(Core.java:158)\n\tat net.continuumsecurity.proxy.ZAProxyScanner.validateMinimumRequiredZapVersion(ZAProxyScanner.java:85)\n\tat net.continuumsecurity.proxy.ZAProxyScanner.\u003cinit\u003e(ZAProxyScanner.java:38)\n\tat steps.capturesessiontoken.precapturesessiontoken(capturesessiontoken.java:25)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.lang.reflect.Method.invoke(Method.java:498)\n\tat cucumber.runtime.Utils$1.call(Utils.java:37)\n\tat cucumber.runtime.Timeout.timeout(Timeout.java:13)\n\tat cucumber.runtime.Utils.invoke(Utils.java:31)\n\tat cucumber.runtime.java.JavaStepDefinition.execute(JavaStepDefinition.java:37)\n\tat cucumber.runtime.StepDefinitionMatch.runStep(StepDefinitionMatch.java:37)\n\tat cucumber.runtime.Runtime.runStep(Runtime.java:298)\n\tat cucumber.runtime.model.StepContainer.runStep(StepContainer.java:44)\n\tat cucumber.runtime.model.StepContainer.runSteps(StepContainer.java:39)\n\tat cucumber.runtime.model.CucumberScenario.run(CucumberScenario.java:48)\n\tat cucumber.runtime.junit.ExecutionUnitRunner.run(ExecutionUnitRunner.java:91)\n\tat cucumber.runtime.junit.FeatureRunner.runChild(FeatureRunner.java:63)\n\tat cucumber.runtime.junit.FeatureRunner.runChild(FeatureRunner.java:18)\n\tat org.junit.runners.ParentRunner$3.run(ParentRunner.java:238)\n\tat org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:63)\n\tat org.junit.runners.ParentRunner.runChildren(ParentRunner.java:236)\n\tat org.junit.runners.ParentRunner.access$000(ParentRunner.java:53)\n\tat org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:229)\n\tat org.junit.runners.ParentRunner.run(ParentRunner.java:309)\n\tat cucumber.runtime.junit.FeatureRunner.run(FeatureRunner.java:70)\n\tat cucumber.api.junit.Cucumber.runChild(Cucumber.java:93)\n\tat cucumber.api.junit.Cucumber.runChild(Cucumber.java:37)\n\tat org.junit.runners.ParentRunner$3.run(ParentRunner.java:238)\n\tat org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:63)\n\tat org.junit.runners.ParentRunner.runChildren(ParentRunner.java:236)\n\tat org.junit.runners.ParentRunner.access$000(ParentRunner.java:53)\n\tat org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:229)\n\tat org.junit.internal.runners.statements.RunAfters.evaluate(RunAfters.java:27)\n\tat org.junit.runners.ParentRunner.run(ParentRunner.java:309)\n\tat cucumber.api.junit.Cucumber.run(Cucumber.java:98)\n\tat org.eclipse.jdt.internal.junit4.runner.JUnit4TestReference.run(JUnit4TestReference.java:86)\n\tat org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:459)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:678)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:382)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:192)\nCaused by: java.net.ConnectException: Connection refused\n\tat java.net.PlainSocketImpl.socketConnect(Native Method)\n\tat java.net.AbstractPlainSocketImpl.doConnect(AbstractPlainSocketImpl.java:350)\n\tat java.net.AbstractPlainSocketImpl.connectToAddress(AbstractPlainSocketImpl.java:206)\n\tat java.net.AbstractPlainSocketImpl.connect(AbstractPlainSocketImpl.java:188)\n\tat java.net.Socket.connect(Socket.java:589)\n\tat java.net.Socket.connect(Socket.java:538)\n\tat sun.net.NetworkClient.doConnect(NetworkClient.java:180)\n\tat sun.net.www.http.HttpClient.openServer(HttpClient.java:432)\n\tat sun.net.www.http.HttpClient$1.run(HttpClient.java:484)\n\tat sun.net.www.http.HttpClient$1.run(HttpClient.java:482)\n\tat java.security.AccessController.doPrivileged(Native Method)\n\tat sun.net.www.http.HttpClient.privilegedOpenServer(HttpClient.java:481)\n\tat sun.net.www.http.HttpClient.openServer(HttpClient.java:522)\n\tat sun.net.www.http.HttpClient.\u003cinit\u003e(HttpClient.java:211)\n\tat sun.net.www.http.HttpClient.New(HttpClient.java:308)\n\tat sun.net.www.http.HttpClient.New(HttpClient.java:326)\n\tat sun.net.www.protocol.http.HttpURLConnection.getNewHttpClient(HttpURLConnection.java:1169)\n\tat sun.net.www.protocol.http.HttpURLConnection.plainConnect0(HttpURLConnection.java:1148)\n\tat sun.net.www.protocol.http.HttpURLConnection.plainConnect(HttpURLConnection.java:999)\n\tat sun.net.www.protocol.http.HttpURLConnection.connect(HttpURLConnection.java:933)\n\tat org.zaproxy.clientapi.core.ClientApi.getConnectionInputStream(ClientApi.java:313)\n\tat org.zaproxy.clientapi.core.ClientApi.callApiDom(ClientApi.java:305)\n\t... 44 more\n",
  "status": "failed"
});
formatter.match({
  "location": "capturesessiontoken.trycapturesessiontoken()"
});
formatter.result({
  "status": "skipped"
});
formatter.match({
  "location": "capturesessiontoken.asscapturesessiontoken()"
});
formatter.result({
  "status": "skipped"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({
  "location": "PatternSteps.assauditinterceptor()"
});
formatter.result({
  "status": "skipped"
});
formatter.match({
  "location": "PatternSteps.asssecurelogger()"
});
formatter.result({
  "status": "skipped"
});
formatter.uri("CAPEC_102_Step_2_2.feature");
formatter.feature({
  "line": 2,
  "name": "CAPEC-102: Session Sidejacking",
  "description": "",
  "id": "capec-102:-session-sidejacking",
  "keyword": "Feature",
  "tags": [
    {
      "line": 1,
      "name": "@capec102"
    }
  ]
});
formatter.scenario({
  "comments": [
    {
      "line": 3,
      "value": "#2. Experiment"
    }
  ],
  "line": 4,
  "name": "Step2.2 Insert captured session token",
  "description": "",
  "id": "capec-102:-session-sidejacking;step2.2-insert-captured-session-token",
  "type": "scenario",
  "keyword": "Scenario"
});
formatter.step({
  "line": 5,
  "name": "prepare to Insert captured session token",
  "keyword": "Given "
});
formatter.step({
  "line": 6,
  "name": "Try to Insert captured session token",
  "keyword": "When "
});
formatter.step({
  "comments": [
    {
      "line": 7,
      "value": "# assertion for attack step success"
    }
  ],
  "line": 8,
  "name": "Assert the success of Insert captured session token",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 9,
      "value": "#assertions for security pattern testing (checker whether the pattern consequences are observed)"
    }
  ],
  "line": 10,
  "name": "assert the consequences of the pattern",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 11,
      "value": "#"
    }
  ],
  "line": 12,
  "name": "assert the consequences of the pattern audit interceptor",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 13,
      "value": "# depends secure logger"
    }
  ],
  "line": 14,
  "name": "assert the consequences of the pattern secure logger",
  "keyword": "Then "
});
formatter.match({
  "location": "insertcapturedsessiontoken.preinsertcapturedsessiontoken()"
});
formatter.result({
  "duration": 72554,
  "status": "passed"
});
formatter.match({
  "location": "insertcapturedsessiontoken.tryinsertcapturedsessiontoken()"
});
formatter.result({
  "duration": 19566,
  "status": "passed"
});
formatter.match({
  "location": "insertcapturedsessiontoken.assinsertcapturedsessiontoken()"
});
formatter.result({
  "duration": 17710,
  "status": "passed"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({
  "location": "PatternSteps.assauditinterceptor()"
});
formatter.result({
  "status": "skipped"
});
formatter.match({
  "location": "PatternSteps.asssecurelogger()"
});
formatter.result({
  "status": "skipped"
});
formatter.uri("CAPEC_102_Step_3_1.feature");
formatter.feature({
  "line": 2,
  "name": "CAPEC-102: Session Sidejacking",
  "description": "",
  "id": "capec-102:-session-sidejacking",
  "keyword": "Feature",
  "tags": [
    {
      "line": 1,
      "name": "@capec102"
    }
  ]
});
formatter.scenario({
  "comments": [
    {
      "line": 3,
      "value": "#3. Exploit"
    }
  ],
  "line": 4,
  "name": "Step3.1 Session Token Exploitation",
  "description": "",
  "id": "capec-102:-session-sidejacking;step3.1-session-token-exploitation",
  "type": "scenario",
  "keyword": "Scenario"
});
formatter.step({
  "line": 5,
  "name": "prepare to Session Token Exploitation",
  "keyword": "Given "
});
formatter.step({
  "line": 6,
  "name": "Try to Session Token Exploitation",
  "keyword": "When "
});
formatter.step({
  "comments": [
    {
      "line": 7,
      "value": "# assertion for attack step success"
    }
  ],
  "line": 8,
  "name": "Assert the success of Session Token Exploitation",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 9,
      "value": "#assertions for security pattern testing (checker whether the pattern consequences are observed)"
    }
  ],
  "line": 10,
  "name": "assert the consequences of the pattern secure logger",
  "keyword": "Then "
});
formatter.match({
  "location": "sessiontokenexploitation.presessiontokenexploitation()"
});
formatter.result({
  "duration": 76848,
  "status": "passed"
});
formatter.match({
  "location": "sessiontokenexploitation.trysessiontokenexploitation()"
});
formatter.result({
  "duration": 16968,
  "status": "passed"
});
formatter.match({
  "location": "sessiontokenexploitation.asssessiontokenexploitation()"
});
formatter.result({
  "duration": 14239,
  "status": "passed"
});
formatter.match({
  "location": "PatternSteps.asssecurelogger()"
});
formatter.result({
  "duration": 40983,
  "status": "passed"
});
formatter.uri("CAPEC_103_Step_1_1.feature");
formatter.feature({
  "line": 2,
  "name": "CAPEC-103: Clickjacking",
  "description": "",
  "id": "capec-103:-clickjacking",
  "keyword": "Feature",
  "tags": [
    {
      "line": 1,
      "name": "@capec103"
    }
  ]
});
formatter.scenario({
  "comments": [
    {
      "line": 3,
      "value": "#1. Experiment"
    }
  ],
  "line": 4,
  "name": "Step1.1 Craft a clickjacking page",
  "description": "",
  "id": "capec-103:-clickjacking;step1.1-craft-a-clickjacking-page",
  "type": "scenario",
  "keyword": "Scenario"
});
formatter.step({
  "line": 5,
  "name": "prepare to Craft a clickjacking page",
  "keyword": "Given "
});
formatter.step({
  "line": 6,
  "name": "Try to Craft a clickjacking page",
  "keyword": "When "
});
formatter.step({
  "comments": [
    {
      "line": 7,
      "value": "# assertion for attack step success"
    }
  ],
  "line": 8,
  "name": "Assert the success of Craft a clickjacking page",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 9,
      "value": "#assertions for security pattern testing (checker whether the pattern consequences are observed)"
    }
  ],
  "line": 10,
  "name": "assert the consequences of the pattern output guard",
  "keyword": "Then "
});
formatter.step({
  "line": 11,
  "name": "assert the consequences of the pattern comparator checked fault tolerant system",
  "keyword": "Then "
});
formatter.match({
  "location": "craftaclickjackingpage.precraftaclickjackingpage()"
});
formatter.result({
  "duration": 72611,
  "status": "passed"
});
formatter.match({
  "location": "craftaclickjackingpage.trycraftaclickjackingpage()"
});
formatter.result({
  "duration": 15399,
  "status": "passed"
});
formatter.match({
  "location": "craftaclickjackingpage.asscraftaclickjackingpage()"
});
formatter.result({
  "duration": 22472,
  "status": "passed"
});
formatter.match({
  "location": "PatternSteps.assoutputguard()"
});
formatter.result({
  "duration": 26764,
  "status": "passed"
});
formatter.match({
  "location": "PatternSteps.asscomparatorcheckedfaulttolerantsystem()"
});
formatter.result({
  "duration": 23426,
  "status": "passed"
});
formatter.uri("CAPEC_103_Step_2_1.feature");
formatter.feature({
  "line": 2,
  "name": "CAPEC-103: Clickjacking",
  "description": "",
  "id": "capec-103:-clickjacking",
  "keyword": "Feature",
  "tags": [
    {
      "line": 1,
      "name": "@capec103"
    }
  ]
});
formatter.scenario({
  "comments": [
    {
      "line": 3,
      "value": "#2. Exploit"
    }
  ],
  "line": 4,
  "name": "Step2.1 Attacker lures victim to clickjacking page",
  "description": "",
  "id": "capec-103:-clickjacking;step2.1-attacker-lures-victim-to-clickjacking-page",
  "type": "scenario",
  "keyword": "Scenario"
});
formatter.step({
  "line": 5,
  "name": "prepare to Attacker lures victim to clickjacking page",
  "keyword": "Given "
});
formatter.step({
  "line": 6,
  "name": "Try to Attacker lures victim to clickjacking page",
  "keyword": "When "
});
formatter.step({
  "comments": [
    {
      "line": 7,
      "value": "# assertion for attack step success"
    }
  ],
  "line": 8,
  "name": "Assert the success of Attacker lures victim to clickjacking page",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 9,
      "value": "#assertions for security pattern testing (checker whether the pattern consequences are observed)"
    }
  ],
  "line": 10,
  "name": "assert the consequences of the pattern",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 11,
      "value": "#"
    }
  ],
  "line": 12,
  "name": "assert the consequences of the pattern audit interceptor",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 13,
      "value": "# depends secure logger"
    }
  ],
  "line": 14,
  "name": "assert the consequences of the pattern secure logger",
  "keyword": "Then "
});
formatter.match({
  "location": "attackerluresvictimtoclickjackingpage.preattackerluresvictimtoclickjackingpage()"
});
formatter.result({
  "duration": 63363,
  "status": "passed"
});
formatter.match({
  "location": "attackerluresvictimtoclickjackingpage.tryattackerluresvictimtoclickjackingpage()"
});
formatter.result({
  "duration": 10290,
  "status": "passed"
});
formatter.match({
  "location": "attackerluresvictimtoclickjackingpage.assattackerluresvictimtoclickjackingpage()"
});
formatter.result({
  "duration": 9676,
  "status": "passed"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({
  "location": "PatternSteps.assauditinterceptor()"
});
formatter.result({
  "status": "skipped"
});
formatter.match({
  "location": "PatternSteps.asssecurelogger()"
});
formatter.result({
  "status": "skipped"
});
formatter.uri("CAPEC_103_Step_2_2.feature");
formatter.feature({
  "line": 2,
  "name": "CAPEC-103: Clickjacking",
  "description": "",
  "id": "capec-103:-clickjacking",
  "keyword": "Feature",
  "tags": [
    {
      "line": 1,
      "name": "@capec103"
    }
  ]
});
formatter.scenario({
  "comments": [
    {
      "line": 3,
      "value": "#2. Exploit"
    }
  ],
  "line": 4,
  "name": "Step2.2 Trick victim into interacting with the clickjacking page in the desired manner",
  "description": "",
  "id": "capec-103:-clickjacking;step2.2-trick-victim-into-interacting-with-the-clickjacking-page-in-the-desired-manner",
  "type": "scenario",
  "keyword": "Scenario"
});
formatter.step({
  "line": 5,
  "name": "prepare to Trick victim into interacting with the clickjacking page in the desired manner",
  "keyword": "Given "
});
formatter.step({
  "line": 6,
  "name": "Try to Trick victim into interacting with the clickjacking page in the desired manner",
  "keyword": "When "
});
formatter.step({
  "comments": [
    {
      "line": 7,
      "value": "# assertion for attack step success"
    }
  ],
  "line": 8,
  "name": "Assert the success of Trick victim into interacting with the clickjacking page in the desired manner",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 9,
      "value": "#assertions for security pattern testing (checker whether the pattern consequences are observed)"
    }
  ],
  "line": 10,
  "name": "assert the consequences of the pattern",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 11,
      "value": "#"
    }
  ],
  "line": 12,
  "name": "assert the consequences of the pattern audit interceptor",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 13,
      "value": "# depends secure logger"
    }
  ],
  "line": 14,
  "name": "assert the consequences of the pattern secure logger",
  "keyword": "Then "
});
formatter.match({
  "location": "trickvictimintointeractingwiththeclickjackingpageinthedesiredmanner.pretrickvictimintointeractingwiththeclickjackingpageinthedesiredmanner()"
});
formatter.result({
  "duration": 77848,
  "status": "passed"
});
formatter.match({
  "location": "trickvictimintointeractingwiththeclickjackingpageinthedesiredmanner.trytrickvictimintointeractingwiththeclickjackingpageinthedesiredmanner()"
});
formatter.result({
  "duration": 22532,
  "status": "passed"
});
formatter.match({
  "location": "trickvictimintointeractingwiththeclickjackingpageinthedesiredmanner.asstrickvictimintointeractingwiththeclickjackingpageinthedesiredmanner()"
});
formatter.result({
  "duration": 18304,
  "status": "passed"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({
  "location": "PatternSteps.assauditinterceptor()"
});
formatter.result({
  "status": "skipped"
});
formatter.match({
  "location": "PatternSteps.asssecurelogger()"
});
formatter.result({
  "status": "skipped"
});
formatter.uri("CAPEC_104_Step_1_1.feature");
formatter.feature({
  "line": 2,
  "name": "CAPEC-104: Cross Zone Scripting",
  "description": "",
  "id": "capec-104:-cross-zone-scripting",
  "keyword": "Feature",
  "tags": [
    {
      "line": 1,
      "name": "@capec104"
    }
  ]
});
formatter.scenario({
  "comments": [
    {
      "line": 3,
      "value": "#1. Explore"
    }
  ],
  "line": 4,
  "name": "Step1.1 Find systems susceptible to the attack",
  "description": "",
  "id": "capec-104:-cross-zone-scripting;step1.1-find-systems-susceptible-to-the-attack",
  "type": "scenario",
  "keyword": "Scenario"
});
formatter.step({
  "line": 5,
  "name": "prepare to Find systems susceptible to the attack",
  "keyword": "Given "
});
formatter.step({
  "line": 6,
  "name": "Try to Find systems susceptible to the attack",
  "keyword": "When "
});
formatter.step({
  "comments": [
    {
      "line": 7,
      "value": "# assertion for attack step success"
    }
  ],
  "line": 8,
  "name": "Assert the success of Find systems susceptible to the attack",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 9,
      "value": "#assertions for security pattern testing (checker whether the pattern consequences are observed)"
    }
  ],
  "line": 10,
  "name": "assert the consequences of the pattern",
  "keyword": "Then "
});
formatter.match({
  "location": "findsystemssusceptibletotheattack.prefindsystemssusceptibletotheattack()"
});
formatter.result({
  "duration": 71895,
  "status": "passed"
});
formatter.match({
  "location": "findsystemssusceptibletotheattack.tryfindsystemssusceptibletotheattack()"
});
formatter.result({
  "duration": 22888,
  "status": "passed"
});
formatter.match({
  "location": "findsystemssusceptibletotheattack.assfindsystemssusceptibletotheattack()"
});
formatter.result({
  "duration": 18396,
  "status": "passed"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.uri("CAPEC_104_Step_2_1.feature");
formatter.feature({
  "line": 2,
  "name": "CAPEC-104: Cross Zone Scripting",
  "description": "",
  "id": "capec-104:-cross-zone-scripting",
  "keyword": "Feature",
  "tags": [
    {
      "line": 1,
      "name": "@capec104"
    }
  ]
});
formatter.scenario({
  "comments": [
    {
      "line": 3,
      "value": "#2. Experiment"
    }
  ],
  "line": 4,
  "name": "Step2.1 Find the insertion point for the payload",
  "description": "",
  "id": "capec-104:-cross-zone-scripting;step2.1-find-the-insertion-point-for-the-payload",
  "type": "scenario",
  "keyword": "Scenario"
});
formatter.step({
  "line": 5,
  "name": "prepare to Find the insertion point for the payload",
  "keyword": "Given "
});
formatter.step({
  "line": 6,
  "name": "Try to Find the insertion point for the payload",
  "keyword": "When "
});
formatter.step({
  "comments": [
    {
      "line": 7,
      "value": "# assertion for attack step success"
    }
  ],
  "line": 8,
  "name": "Assert the success of Find the insertion point for the payload",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 9,
      "value": "#assertions for security pattern testing (checker whether the pattern consequences are observed)"
    }
  ],
  "line": 10,
  "name": "assert the consequences of the pattern",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 11,
      "value": "#"
    }
  ],
  "line": 12,
  "name": "assert the consequences of the pattern audit interceptor",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 13,
      "value": "# depends secure logger"
    }
  ],
  "line": 14,
  "name": "assert the consequences of the pattern secure logger",
  "keyword": "Then "
});
formatter.match({
  "location": "findtheinsertionpointforthepayload.prefindtheinsertionpointforthepayload()"
});
formatter.result({
  "duration": 84842,
  "status": "passed"
});
formatter.match({
  "location": "findtheinsertionpointforthepayload.tryfindtheinsertionpointforthepayload()"
});
formatter.result({
  "duration": 17125,
  "status": "passed"
});
formatter.match({
  "location": "findtheinsertionpointforthepayload.assfindtheinsertionpointforthepayload()"
});
formatter.result({
  "duration": 39912,
  "status": "passed"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({
  "location": "PatternSteps.assauditinterceptor()"
});
formatter.result({
  "status": "skipped"
});
formatter.match({
  "location": "PatternSteps.asssecurelogger()"
});
formatter.result({
  "status": "skipped"
});
formatter.uri("CAPEC_104_Step_3_1.feature");
formatter.feature({
  "line": 2,
  "name": "CAPEC-104: Cross Zone Scripting",
  "description": "",
  "id": "capec-104:-cross-zone-scripting",
  "keyword": "Feature",
  "tags": [
    {
      "line": 1,
      "name": "@capec104"
    }
  ]
});
formatter.scenario({
  "comments": [
    {
      "line": 3,
      "value": "#3. Exploit"
    }
  ],
  "line": 4,
  "name": "Step3.1 Craft and inject the payload",
  "description": "",
  "id": "capec-104:-cross-zone-scripting;step3.1-craft-and-inject-the-payload",
  "type": "scenario",
  "keyword": "Scenario"
});
formatter.step({
  "line": 5,
  "name": "prepare to Craft and inject the payload",
  "keyword": "Given "
});
formatter.step({
  "line": 6,
  "name": "Try to Craft and inject the payload",
  "keyword": "When "
});
formatter.step({
  "comments": [
    {
      "line": 7,
      "value": "# assertion for attack step success"
    }
  ],
  "line": 8,
  "name": "Assert the success of Craft and inject the payload",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 9,
      "value": "#assertions for security pattern testing (checker whether the pattern consequences are observed)"
    }
  ],
  "line": 10,
  "name": "assert the consequences of the pattern",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 11,
      "value": "#"
    }
  ],
  "line": 12,
  "name": "assert the consequences of the pattern audit interceptor",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 13,
      "value": "# depends secure logger"
    }
  ],
  "line": 14,
  "name": "assert the consequences of the pattern secure logger",
  "keyword": "Then "
});
formatter.match({
  "location": "craftandinjectthepayload.precraftandinjectthepayload()"
});
formatter.result({
  "duration": 103405,
  "status": "passed"
});
formatter.match({
  "location": "craftandinjectthepayload.trycraftandinjectthepayload()"
});
formatter.result({
  "duration": 33198,
  "status": "passed"
});
formatter.match({
  "location": "craftandinjectthepayload.asscraftandinjectthepayload()"
});
formatter.result({
  "duration": 20699,
  "status": "passed"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({
  "location": "PatternSteps.assauditinterceptor()"
});
formatter.result({
  "status": "skipped"
});
formatter.match({
  "location": "PatternSteps.asssecurelogger()"
});
formatter.result({
  "status": "skipped"
});
formatter.uri("CAPEC_105_Step_1_1.feature");
formatter.feature({
  "line": 2,
  "name": "CAPEC-105: HTTP Request Splitting",
  "description": "",
  "id": "capec-105:-http-request-splitting",
  "keyword": "Feature",
  "tags": [
    {
      "line": 1,
      "name": "@capec105"
    }
  ]
});
formatter.scenario({
  "comments": [
    {
      "line": 3,
      "value": "#1. Explore"
    }
  ],
  "line": 4,
  "name": "Step1.1 Investigate Target Environment",
  "description": "",
  "id": "capec-105:-http-request-splitting;step1.1-investigate-target-environment",
  "type": "scenario",
  "keyword": "Scenario"
});
formatter.step({
  "line": 5,
  "name": "prepare to Investigate Target Environment",
  "keyword": "Given "
});
formatter.step({
  "line": 6,
  "name": "Try to Investigate Target Environment",
  "keyword": "When "
});
formatter.step({
  "comments": [
    {
      "line": 7,
      "value": "# assertion for attack step success"
    }
  ],
  "line": 8,
  "name": "Assert the success of Investigate Target Environment",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 9,
      "value": "#assertions for security pattern testing (checker whether the pattern consequences are observed)"
    }
  ],
  "line": 10,
  "name": "assert the consequences of the pattern",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 11,
      "value": "#"
    }
  ],
  "line": 12,
  "name": "assert the consequences of the pattern audit interceptor",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 13,
      "value": "# depends secure logger"
    }
  ],
  "line": 14,
  "name": "assert the consequences of the pattern secure logger",
  "keyword": "Then "
});
formatter.match({
  "location": "investigatetargetenvironment.preinvestigatetargetenvironment()"
});
formatter.result({
  "duration": 96231,
  "status": "passed"
});
formatter.match({
  "location": "investigatetargetenvironment.tryinvestigatetargetenvironment()"
});
formatter.result({
  "duration": 19154,
  "status": "passed"
});
formatter.match({
  "location": "investigatetargetenvironment.assinvestigatetargetenvironment()"
});
formatter.result({
  "duration": 16263,
  "status": "passed"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({
  "location": "PatternSteps.assauditinterceptor()"
});
formatter.result({
  "status": "skipped"
});
formatter.match({
  "location": "PatternSteps.asssecurelogger()"
});
formatter.result({
  "status": "skipped"
});
formatter.uri("CAPEC_105_Step_2_1.feature");
formatter.feature({
  "line": 2,
  "name": "CAPEC-105: HTTP Request Splitting",
  "description": "",
  "id": "capec-105:-http-request-splitting",
  "keyword": "Feature",
  "tags": [
    {
      "line": 1,
      "name": "@capec105"
    }
  ]
});
formatter.scenario({
  "comments": [
    {
      "line": 3,
      "value": "#2. Exploit"
    }
  ],
  "line": 4,
  "name": "Step2.1 Post a malicious HTTP Request",
  "description": "",
  "id": "capec-105:-http-request-splitting;step2.1-post-a-malicious-http-request",
  "type": "scenario",
  "keyword": "Scenario"
});
formatter.step({
  "line": 5,
  "name": "prepare to Post a malicious HTTP Request",
  "keyword": "Given "
});
formatter.step({
  "line": 6,
  "name": "Try to Post a malicious HTTP Request",
  "keyword": "When "
});
formatter.step({
  "comments": [
    {
      "line": 7,
      "value": "# assertion for attack step success"
    }
  ],
  "line": 8,
  "name": "Assert the success of Post a malicious HTTP Request",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 9,
      "value": "#assertions for security pattern testing (checker whether the pattern consequences are observed)"
    }
  ],
  "line": 10,
  "name": "assert the consequences of the pattern",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 11,
      "value": "#"
    }
  ],
  "line": 12,
  "name": "assert the consequences of the pattern audit interceptor",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 13,
      "value": "# depends secure logger"
    }
  ],
  "line": 14,
  "name": "assert the consequences of the pattern secure logger",
  "keyword": "Then "
});
formatter.match({
  "location": "postamalicioushttprequest.prepostamalicioushttprequest()"
});
formatter.result({
  "duration": 84513,
  "status": "passed"
});
formatter.match({
  "location": "postamalicioushttprequest.trypostamalicioushttprequest()"
});
formatter.result({
  "duration": 18954,
  "status": "passed"
});
formatter.match({
  "location": "postamalicioushttprequest.asspostamalicioushttprequest()"
});
formatter.result({
  "duration": 17683,
  "status": "passed"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({
  "location": "PatternSteps.assauditinterceptor()"
});
formatter.result({
  "status": "skipped"
});
formatter.match({
  "location": "PatternSteps.asssecurelogger()"
});
formatter.result({
  "status": "skipped"
});
formatter.uri("CAPEC_106_Step_1_1.feature");
formatter.feature({
  "line": 2,
  "name": "CAPEC-106: Cross Site Scripting through Log Files",
  "description": "",
  "id": "capec-106:-cross-site-scripting-through-log-files",
  "keyword": "Feature",
  "tags": [
    {
      "line": 1,
      "name": "@capec106"
    }
  ]
});
formatter.scenario({
  "comments": [
    {
      "line": 3,
      "value": "#1. Explore"
    }
  ],
  "line": 4,
  "name": "Step1.1 Probe for log injection vulnerability",
  "description": "",
  "id": "capec-106:-cross-site-scripting-through-log-files;step1.1-probe-for-log-injection-vulnerability",
  "type": "scenario",
  "keyword": "Scenario"
});
formatter.step({
  "line": 5,
  "name": "prepare to Probe for log injection vulnerability",
  "keyword": "Given "
});
formatter.step({
  "line": 6,
  "name": "Try to Probe for log injection vulnerability",
  "keyword": "When "
});
formatter.step({
  "comments": [
    {
      "line": 7,
      "value": "# assertion for attack step success"
    }
  ],
  "line": 8,
  "name": "Assert the success of Probe for log injection vulnerability",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 9,
      "value": "#assertions for security pattern testing (checker whether the pattern consequences are observed)"
    }
  ],
  "line": 10,
  "name": "assert the consequences of the pattern secure logger",
  "keyword": "Then "
});
formatter.match({
  "location": "probeforloginjectionvulnerability.preprobeforloginjectionvulnerability()"
});
formatter.result({
  "duration": 74947,
  "status": "passed"
});
formatter.match({
  "location": "probeforloginjectionvulnerability.tryprobeforloginjectionvulnerability()"
});
formatter.result({
  "duration": 13309,
  "status": "passed"
});
formatter.match({
  "location": "probeforloginjectionvulnerability.assprobeforloginjectionvulnerability()"
});
formatter.result({
  "duration": 9485,
  "status": "passed"
});
formatter.match({
  "location": "PatternSteps.asssecurelogger()"
});
formatter.result({
  "duration": 17860,
  "status": "passed"
});
formatter.uri("CAPEC_106_Step_1_2.feature");
formatter.feature({
  "line": 2,
  "name": "CAPEC-106: Cross Site Scripting through Log Files",
  "description": "",
  "id": "capec-106:-cross-site-scripting-through-log-files",
  "keyword": "Feature",
  "tags": [
    {
      "line": 1,
      "name": "@capec106"
    }
  ]
});
formatter.scenario({
  "comments": [
    {
      "line": 3,
      "value": "#1. Explore"
    }
  ],
  "line": 4,
  "name": "Step1.2 Probe for cross-site scripting vulnerability",
  "description": "",
  "id": "capec-106:-cross-site-scripting-through-log-files;step1.2-probe-for-cross-site-scripting-vulnerability",
  "type": "scenario",
  "keyword": "Scenario"
});
formatter.step({
  "line": 5,
  "name": "prepare to Probe for cross-site scripting vulnerability",
  "keyword": "Given "
});
formatter.step({
  "line": 6,
  "name": "Try to Probe for cross-site scripting vulnerability",
  "keyword": "When "
});
formatter.step({
  "comments": [
    {
      "line": 7,
      "value": "# assertion for attack step success"
    }
  ],
  "line": 8,
  "name": "Assert the success of Probe for cross-site scripting vulnerability",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 9,
      "value": "#assertions for security pattern testing (checker whether the pattern consequences are observed)"
    }
  ],
  "line": 10,
  "name": "assert the consequences of the pattern secure logger",
  "keyword": "Then "
});
formatter.match({
  "location": "probeforcrosssitescriptingvulnerability.preprobeforcrosssitescriptingvulnerability()"
});
formatter.result({
  "duration": 2266821,
  "error_message": "net.continuumsecurity.proxy.ProxyException: org.zaproxy.clientapi.core.ClientApiException: java.net.ConnectException: Connection refused\n\tat net.continuumsecurity.proxy.ZAProxyScanner.validateMinimumRequiredZapVersion(ZAProxyScanner.java:96)\n\tat net.continuumsecurity.proxy.ZAProxyScanner.\u003cinit\u003e(ZAProxyScanner.java:38)\n\tat steps.probeforcrosssitescriptingvulnerability.preprobeforcrosssitescriptingvulnerability(probeforcrosssitescriptingvulnerability.java:15)\n\tat ✽.Given prepare to Probe for cross-site scripting vulnerability(CAPEC_106_Step_1_2.feature:5)\nCaused by: org.zaproxy.clientapi.core.ClientApiException: java.net.ConnectException: Connection refused\n\tat org.zaproxy.clientapi.core.ClientApi.callApiDom(ClientApi.java:307)\n\tat org.zaproxy.clientapi.core.ClientApi.callApi(ClientApi.java:289)\n\tat org.zaproxy.clientapi.gen.Core.version(Core.java:158)\n\tat net.continuumsecurity.proxy.ZAProxyScanner.validateMinimumRequiredZapVersion(ZAProxyScanner.java:85)\n\tat net.continuumsecurity.proxy.ZAProxyScanner.\u003cinit\u003e(ZAProxyScanner.java:38)\n\tat steps.probeforcrosssitescriptingvulnerability.preprobeforcrosssitescriptingvulnerability(probeforcrosssitescriptingvulnerability.java:15)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.lang.reflect.Method.invoke(Method.java:498)\n\tat cucumber.runtime.Utils$1.call(Utils.java:37)\n\tat cucumber.runtime.Timeout.timeout(Timeout.java:13)\n\tat cucumber.runtime.Utils.invoke(Utils.java:31)\n\tat cucumber.runtime.java.JavaStepDefinition.execute(JavaStepDefinition.java:37)\n\tat cucumber.runtime.StepDefinitionMatch.runStep(StepDefinitionMatch.java:37)\n\tat cucumber.runtime.Runtime.runStep(Runtime.java:298)\n\tat cucumber.runtime.model.StepContainer.runStep(StepContainer.java:44)\n\tat cucumber.runtime.model.StepContainer.runSteps(StepContainer.java:39)\n\tat cucumber.runtime.model.CucumberScenario.run(CucumberScenario.java:48)\n\tat cucumber.runtime.junit.ExecutionUnitRunner.run(ExecutionUnitRunner.java:91)\n\tat cucumber.runtime.junit.FeatureRunner.runChild(FeatureRunner.java:63)\n\tat cucumber.runtime.junit.FeatureRunner.runChild(FeatureRunner.java:18)\n\tat org.junit.runners.ParentRunner$3.run(ParentRunner.java:238)\n\tat org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:63)\n\tat org.junit.runners.ParentRunner.runChildren(ParentRunner.java:236)\n\tat org.junit.runners.ParentRunner.access$000(ParentRunner.java:53)\n\tat org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:229)\n\tat org.junit.runners.ParentRunner.run(ParentRunner.java:309)\n\tat cucumber.runtime.junit.FeatureRunner.run(FeatureRunner.java:70)\n\tat cucumber.api.junit.Cucumber.runChild(Cucumber.java:93)\n\tat cucumber.api.junit.Cucumber.runChild(Cucumber.java:37)\n\tat org.junit.runners.ParentRunner$3.run(ParentRunner.java:238)\n\tat org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:63)\n\tat org.junit.runners.ParentRunner.runChildren(ParentRunner.java:236)\n\tat org.junit.runners.ParentRunner.access$000(ParentRunner.java:53)\n\tat org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:229)\n\tat org.junit.internal.runners.statements.RunAfters.evaluate(RunAfters.java:27)\n\tat org.junit.runners.ParentRunner.run(ParentRunner.java:309)\n\tat cucumber.api.junit.Cucumber.run(Cucumber.java:98)\n\tat org.eclipse.jdt.internal.junit4.runner.JUnit4TestReference.run(JUnit4TestReference.java:86)\n\tat org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:459)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:678)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:382)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:192)\nCaused by: java.net.ConnectException: Connection refused\n\tat java.net.PlainSocketImpl.socketConnect(Native Method)\n\tat java.net.AbstractPlainSocketImpl.doConnect(AbstractPlainSocketImpl.java:350)\n\tat java.net.AbstractPlainSocketImpl.connectToAddress(AbstractPlainSocketImpl.java:206)\n\tat java.net.AbstractPlainSocketImpl.connect(AbstractPlainSocketImpl.java:188)\n\tat java.net.Socket.connect(Socket.java:589)\n\tat java.net.Socket.connect(Socket.java:538)\n\tat sun.net.NetworkClient.doConnect(NetworkClient.java:180)\n\tat sun.net.www.http.HttpClient.openServer(HttpClient.java:432)\n\tat sun.net.www.http.HttpClient$1.run(HttpClient.java:484)\n\tat sun.net.www.http.HttpClient$1.run(HttpClient.java:482)\n\tat java.security.AccessController.doPrivileged(Native Method)\n\tat sun.net.www.http.HttpClient.privilegedOpenServer(HttpClient.java:481)\n\tat sun.net.www.http.HttpClient.openServer(HttpClient.java:522)\n\tat sun.net.www.http.HttpClient.\u003cinit\u003e(HttpClient.java:211)\n\tat sun.net.www.http.HttpClient.New(HttpClient.java:308)\n\tat sun.net.www.http.HttpClient.New(HttpClient.java:326)\n\tat sun.net.www.protocol.http.HttpURLConnection.getNewHttpClient(HttpURLConnection.java:1169)\n\tat sun.net.www.protocol.http.HttpURLConnection.plainConnect0(HttpURLConnection.java:1148)\n\tat sun.net.www.protocol.http.HttpURLConnection.plainConnect(HttpURLConnection.java:999)\n\tat sun.net.www.protocol.http.HttpURLConnection.connect(HttpURLConnection.java:933)\n\tat org.zaproxy.clientapi.core.ClientApi.getConnectionInputStream(ClientApi.java:313)\n\tat org.zaproxy.clientapi.core.ClientApi.callApiDom(ClientApi.java:305)\n\t... 44 more\n",
  "status": "failed"
});
formatter.match({
  "location": "probeforcrosssitescriptingvulnerability.tryprobeforcrosssitescriptingvulnerability()"
});
formatter.result({
  "status": "skipped"
});
formatter.match({
  "location": "probeforcrosssitescriptingvulnerability.assprobeforcrosssitescriptingvulnerability()"
});
formatter.result({
  "status": "skipped"
});
formatter.match({
  "location": "PatternSteps.asssecurelogger()"
});
formatter.result({
  "status": "skipped"
});
formatter.uri("CAPEC_106_Step_2_1.feature");
formatter.feature({
  "line": 2,
  "name": "CAPEC-106: Cross Site Scripting through Log Files",
  "description": "",
  "id": "capec-106:-cross-site-scripting-through-log-files",
  "keyword": "Feature",
  "tags": [
    {
      "line": 1,
      "name": "@capec106"
    }
  ]
});
formatter.scenario({
  "comments": [
    {
      "line": 3,
      "value": "#2. Experiment"
    }
  ],
  "line": 4,
  "name": "Step2.1 Confirm exploitability",
  "description": "",
  "id": "capec-106:-cross-site-scripting-through-log-files;step2.1-confirm-exploitability",
  "type": "scenario",
  "keyword": "Scenario"
});
formatter.step({
  "line": 5,
  "name": "prepare to Confirm exploitability",
  "keyword": "Given "
});
formatter.step({
  "line": 6,
  "name": "Try to Confirm exploitability",
  "keyword": "When "
});
formatter.step({
  "comments": [
    {
      "line": 7,
      "value": "# assertion for attack step success"
    }
  ],
  "line": 8,
  "name": "Assert the success of Confirm exploitability",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 9,
      "value": "#assertions for security pattern testing (checker whether the pattern consequences are observed)"
    }
  ],
  "line": 10,
  "name": "assert the consequences of the pattern",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 11,
      "value": "#"
    }
  ],
  "line": 12,
  "name": "assert the consequences of the pattern audit interceptor",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 13,
      "value": "# depends secure logger"
    }
  ],
  "line": 14,
  "name": "assert the consequences of the pattern secure logger",
  "keyword": "Then "
});
formatter.match({
  "location": "confirmexploitability.preconfirmexploitability()"
});
formatter.result({
  "duration": 81321,
  "status": "passed"
});
formatter.match({
  "location": "confirmexploitability.tryconfirmexploitability()"
});
formatter.result({
  "duration": 19838,
  "status": "passed"
});
formatter.match({
  "location": "confirmexploitability.assconfirmexploitability()"
});
formatter.result({
  "duration": 18464,
  "status": "passed"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({
  "location": "PatternSteps.assauditinterceptor()"
});
formatter.result({
  "status": "skipped"
});
formatter.match({
  "location": "PatternSteps.asssecurelogger()"
});
formatter.result({
  "status": "skipped"
});
formatter.uri("CAPEC_106_Step_3_1.feature");
formatter.feature({
  "line": 2,
  "name": "CAPEC-106: Cross Site Scripting through Log Files",
  "description": "",
  "id": "capec-106:-cross-site-scripting-through-log-files",
  "keyword": "Feature",
  "tags": [
    {
      "line": 1,
      "name": "@capec106"
    }
  ]
});
formatter.scenario({
  "comments": [
    {
      "line": 3,
      "value": "#3. Exploit"
    }
  ],
  "line": 4,
  "name": "Step3.1 Inject System Logs with Malicious Scripts",
  "description": "",
  "id": "capec-106:-cross-site-scripting-through-log-files;step3.1-inject-system-logs-with-malicious-scripts",
  "type": "scenario",
  "keyword": "Scenario"
});
formatter.step({
  "line": 5,
  "name": "prepare to Inject System Logs with Malicious Scripts",
  "keyword": "Given "
});
formatter.step({
  "line": 6,
  "name": "Try to Inject System Logs with Malicious Scripts",
  "keyword": "When "
});
formatter.step({
  "comments": [
    {
      "line": 7,
      "value": "# assertion for attack step success"
    }
  ],
  "line": 8,
  "name": "Assert the success of Inject System Logs with Malicious Scripts",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 9,
      "value": "#assertions for security pattern testing (checker whether the pattern consequences are observed)"
    }
  ],
  "line": 10,
  "name": "assert the consequences of the pattern",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 11,
      "value": "#"
    }
  ],
  "line": 12,
  "name": "assert the consequences of the pattern audit interceptor",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 13,
      "value": "# depends secure logger"
    }
  ],
  "line": 14,
  "name": "assert the consequences of the pattern secure logger",
  "keyword": "Then "
});
formatter.match({
  "location": "injectsystemlogswithmaliciousscripts.preinjectsystemlogswithmaliciousscripts()"
});
formatter.result({
  "duration": 76460,
  "status": "passed"
});
formatter.match({
  "location": "injectsystemlogswithmaliciousscripts.tryinjectsystemlogswithmaliciousscripts()"
});
formatter.result({
  "duration": 19880,
  "status": "passed"
});
formatter.match({
  "location": "injectsystemlogswithmaliciousscripts.assinjectsystemlogswithmaliciousscripts()"
});
formatter.result({
  "duration": 23124,
  "status": "passed"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({
  "location": "PatternSteps.assauditinterceptor()"
});
formatter.result({
  "status": "skipped"
});
formatter.match({
  "location": "PatternSteps.asssecurelogger()"
});
formatter.result({
  "status": "skipped"
});
formatter.uri("CAPEC_107_Step_1_1.feature");
formatter.feature({
  "line": 2,
  "name": "CAPEC-107: Cross Site Tracing",
  "description": "",
  "id": "capec-107:-cross-site-tracing",
  "keyword": "Feature",
  "tags": [
    {
      "line": 1,
      "name": "@capec107"
    }
  ]
});
formatter.scenario({
  "comments": [
    {
      "line": 3,
      "value": "#1. Explore"
    }
  ],
  "line": 4,
  "name": "Step1.1 Determine if HTTP Trace is enabled",
  "description": "",
  "id": "capec-107:-cross-site-tracing;step1.1-determine-if-http-trace-is-enabled",
  "type": "scenario",
  "keyword": "Scenario"
});
formatter.step({
  "line": 5,
  "name": "prepare to Determine if HTTP Trace is enabled",
  "keyword": "Given "
});
formatter.step({
  "line": 6,
  "name": "Try to Determine if HTTP Trace is enabled",
  "keyword": "When "
});
formatter.step({
  "comments": [
    {
      "line": 7,
      "value": "# assertion for attack step success"
    }
  ],
  "line": 8,
  "name": "Assert the success of Determine if HTTP Trace is enabled",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 9,
      "value": "#assertions for security pattern testing (checker whether the pattern consequences are observed)"
    }
  ],
  "line": 10,
  "name": "assert the consequences of the pattern",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 11,
      "value": "#"
    }
  ],
  "line": 12,
  "name": "assert the consequences of the pattern audit interceptor",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 13,
      "value": "# depends secure logger"
    }
  ],
  "line": 14,
  "name": "assert the consequences of the pattern secure logger",
  "keyword": "Then "
});
formatter.match({
  "location": "determineifhttptraceisenabled.predetermineifhttptraceisenabled()"
});
formatter.result({
  "duration": 75144,
  "status": "passed"
});
formatter.match({
  "location": "determineifhttptraceisenabled.trydetermineifhttptraceisenabled()"
});
formatter.result({
  "duration": 11322,
  "status": "passed"
});
formatter.match({
  "location": "determineifhttptraceisenabled.assdetermineifhttptraceisenabled()"
});
formatter.result({
  "duration": 10718,
  "status": "passed"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({
  "location": "PatternSteps.assauditinterceptor()"
});
formatter.result({
  "status": "skipped"
});
formatter.match({
  "location": "PatternSteps.asssecurelogger()"
});
formatter.result({
  "status": "skipped"
});
formatter.uri("CAPEC_107_Step_2_1.feature");
formatter.feature({
  "line": 2,
  "name": "CAPEC-107: Cross Site Tracing",
  "description": "",
  "id": "capec-107:-cross-site-tracing",
  "keyword": "Feature",
  "tags": [
    {
      "line": 1,
      "name": "@capec107"
    }
  ]
});
formatter.scenario({
  "comments": [
    {
      "line": 3,
      "value": "#2. Experiment"
    }
  ],
  "line": 4,
  "name": "Step2.1 Identify mechanism to launch HTTP Trace request",
  "description": "",
  "id": "capec-107:-cross-site-tracing;step2.1-identify-mechanism-to-launch-http-trace-request",
  "type": "scenario",
  "keyword": "Scenario"
});
formatter.step({
  "line": 5,
  "name": "prepare to Identify mechanism to launch HTTP Trace request",
  "keyword": "Given "
});
formatter.step({
  "line": 6,
  "name": "Try to Identify mechanism to launch HTTP Trace request",
  "keyword": "When "
});
formatter.step({
  "comments": [
    {
      "line": 7,
      "value": "# assertion for attack step success"
    }
  ],
  "line": 8,
  "name": "Assert the success of Identify mechanism to launch HTTP Trace request",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 9,
      "value": "#assertions for security pattern testing (checker whether the pattern consequences are observed)"
    }
  ],
  "line": 10,
  "name": "assert the consequences of the pattern",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 11,
      "value": "#"
    }
  ],
  "line": 12,
  "name": "assert the consequences of the pattern audit interceptor",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 13,
      "value": "# depends secure logger"
    }
  ],
  "line": 14,
  "name": "assert the consequences of the pattern secure logger",
  "keyword": "Then "
});
formatter.match({
  "location": "identifymechanismtolaunchhttptracerequest.preidentifymechanismtolaunchhttptracerequest()"
});
formatter.result({
  "duration": 64339,
  "status": "passed"
});
formatter.match({
  "location": "identifymechanismtolaunchhttptracerequest.tryidentifymechanismtolaunchhttptracerequest()"
});
formatter.result({
  "duration": 13082,
  "status": "passed"
});
formatter.match({
  "location": "identifymechanismtolaunchhttptracerequest.assidentifymechanismtolaunchhttptracerequest()"
});
formatter.result({
  "duration": 11258,
  "status": "passed"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({
  "location": "PatternSteps.assauditinterceptor()"
});
formatter.result({
  "status": "skipped"
});
formatter.match({
  "location": "PatternSteps.asssecurelogger()"
});
formatter.result({
  "status": "skipped"
});
formatter.uri("CAPEC_107_Step_3_1.feature");
formatter.feature({
  "line": 2,
  "name": "CAPEC-107: Cross Site Tracing",
  "description": "",
  "id": "capec-107:-cross-site-tracing",
  "keyword": "Feature",
  "tags": [
    {
      "line": 1,
      "name": "@capec107"
    }
  ]
});
formatter.scenario({
  "comments": [
    {
      "line": 3,
      "value": "#3. Exploit"
    }
  ],
  "line": 4,
  "name": "Step3.1 Create a malicious script that pings the web server with HTTP TRACE request",
  "description": "",
  "id": "capec-107:-cross-site-tracing;step3.1-create-a-malicious-script-that-pings-the-web-server-with-http-trace-request",
  "type": "scenario",
  "keyword": "Scenario"
});
formatter.step({
  "line": 5,
  "name": "prepare to Create a malicious script that pings the web server with HTTP TRACE request",
  "keyword": "Given "
});
formatter.step({
  "line": 6,
  "name": "Try to Create a malicious script that pings the web server with HTTP TRACE request",
  "keyword": "When "
});
formatter.step({
  "comments": [
    {
      "line": 7,
      "value": "# assertion for attack step success"
    }
  ],
  "line": 8,
  "name": "Assert the success of Create a malicious script that pings the web server with HTTP TRACE request",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 9,
      "value": "#assertions for security pattern testing (checker whether the pattern consequences are observed)"
    }
  ],
  "line": 10,
  "name": "assert the consequences of the pattern",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 11,
      "value": "#"
    }
  ],
  "line": 12,
  "name": "assert the consequences of the pattern audit interceptor",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 13,
      "value": "# depends secure logger"
    }
  ],
  "line": 14,
  "name": "assert the consequences of the pattern secure logger",
  "keyword": "Then "
});
formatter.match({
  "location": "createamaliciousscriptthatpingsthewebserverwithhttptracerequest.precreateamaliciousscriptthatpingsthewebserverwithhttptracerequest()"
});
formatter.result({
  "duration": 89528,
  "status": "passed"
});
formatter.match({
  "location": "createamaliciousscriptthatpingsthewebserverwithhttptracerequest.trycreateamaliciousscriptthatpingsthewebserverwithhttptracerequest()"
});
formatter.result({
  "duration": 21635,
  "status": "passed"
});
formatter.match({
  "location": "createamaliciousscriptthatpingsthewebserverwithhttptracerequest.asscreateamaliciousscriptthatpingsthewebserverwithhttptracerequest()"
});
formatter.result({
  "duration": 17807,
  "status": "passed"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({
  "location": "PatternSteps.assauditinterceptor()"
});
formatter.result({
  "status": "skipped"
});
formatter.match({
  "location": "PatternSteps.asssecurelogger()"
});
formatter.result({
  "status": "skipped"
});
formatter.uri("CAPEC_107_Step_3_2.feature");
formatter.feature({
  "line": 2,
  "name": "CAPEC-107: Cross Site Tracing",
  "description": "",
  "id": "capec-107:-cross-site-tracing",
  "keyword": "Feature",
  "tags": [
    {
      "line": 1,
      "name": "@capec107"
    }
  ]
});
formatter.scenario({
  "comments": [
    {
      "line": 3,
      "value": "#3. Exploit"
    }
  ],
  "line": 4,
  "name": "Step3.2 Execute malicious HTTP Trace launching script",
  "description": "",
  "id": "capec-107:-cross-site-tracing;step3.2-execute-malicious-http-trace-launching-script",
  "type": "scenario",
  "keyword": "Scenario"
});
formatter.step({
  "line": 5,
  "name": "prepare to Execute malicious HTTP Trace launching script",
  "keyword": "Given "
});
formatter.step({
  "line": 6,
  "name": "Try to Execute malicious HTTP Trace launching script",
  "keyword": "When "
});
formatter.step({
  "comments": [
    {
      "line": 7,
      "value": "# assertion for attack step success"
    }
  ],
  "line": 8,
  "name": "Assert the success of Execute malicious HTTP Trace launching script",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 9,
      "value": "#assertions for security pattern testing (checker whether the pattern consequences are observed)"
    }
  ],
  "line": 10,
  "name": "assert the consequences of the pattern",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 11,
      "value": "#"
    }
  ],
  "line": 12,
  "name": "assert the consequences of the pattern audit interceptor",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 13,
      "value": "# depends secure logger"
    }
  ],
  "line": 14,
  "name": "assert the consequences of the pattern secure logger",
  "keyword": "Then "
});
formatter.match({
  "location": "executemalicioushttptracelaunchingscript.preexecutemalicioushttptracelaunchingscript()"
});
formatter.result({
  "duration": 83014,
  "status": "passed"
});
formatter.match({
  "location": "executemalicioushttptracelaunchingscript.tryexecutemalicioushttptracelaunchingscript()"
});
formatter.result({
  "duration": 25157,
  "status": "passed"
});
formatter.match({
  "location": "executemalicioushttptracelaunchingscript.assexecutemalicioushttptracelaunchingscript()"
});
formatter.result({
  "duration": 24906,
  "status": "passed"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({
  "location": "PatternSteps.assauditinterceptor()"
});
formatter.result({
  "status": "skipped"
});
formatter.match({
  "location": "PatternSteps.asssecurelogger()"
});
formatter.result({
  "status": "skipped"
});
formatter.uri("CAPEC_108_Step_1_1.feature");
formatter.feature({
  "line": 2,
  "name": "CAPEC-108: Command Line Execution through SQL Injection",
  "description": "",
  "id": "capec-108:-command-line-execution-through-sql-injection",
  "keyword": "Feature",
  "tags": [
    {
      "line": 1,
      "name": "@capec108"
    }
  ]
});
formatter.scenario({
  "comments": [
    {
      "line": 3,
      "value": "#1. Explore"
    }
  ],
  "line": 4,
  "name": "Step1.1 Probe for SQL Injection vulnerability",
  "description": "",
  "id": "capec-108:-command-line-execution-through-sql-injection;step1.1-probe-for-sql-injection-vulnerability",
  "type": "scenario",
  "keyword": "Scenario"
});
formatter.step({
  "line": 5,
  "name": "prepare to Probe for SQL Injection vulnerability",
  "keyword": "Given "
});
formatter.step({
  "line": 6,
  "name": "Try to Probe for SQL Injection vulnerability",
  "keyword": "When "
});
formatter.step({
  "comments": [
    {
      "line": 7,
      "value": "# assertion for attack step success"
    }
  ],
  "line": 8,
  "name": "Assert the success of Probe for SQL Injection vulnerability",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 9,
      "value": "#assertions for security pattern testing (checker whether the pattern consequences are observed)"
    }
  ],
  "line": 10,
  "name": "assert the consequences of the pattern application firewall",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 11,
      "value": "# alternative input guard"
    }
  ],
  "line": 12,
  "name": "assert the consequences of the pattern input guard",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 13,
      "value": "# alternative application firewall"
    }
  ],
  "line": 14,
  "name": "assert the consequences of the pattern secure logger",
  "keyword": "Then "
});
formatter.match({
  "location": "probeforsqlinjectionvulnerability.preprobeforsqlinjectionvulnerability()"
});
formatter.result({
  "duration": 2501493,
  "error_message": "net.continuumsecurity.proxy.ProxyException: org.zaproxy.clientapi.core.ClientApiException: java.net.ConnectException: Connection refused\n\tat net.continuumsecurity.proxy.ZAProxyScanner.validateMinimumRequiredZapVersion(ZAProxyScanner.java:96)\n\tat net.continuumsecurity.proxy.ZAProxyScanner.\u003cinit\u003e(ZAProxyScanner.java:38)\n\tat steps.probeforsqlinjectionvulnerability.preprobeforsqlinjectionvulnerability(probeforsqlinjectionvulnerability.java:16)\n\tat ✽.Given prepare to Probe for SQL Injection vulnerability(CAPEC_108_Step_1_1.feature:5)\nCaused by: org.zaproxy.clientapi.core.ClientApiException: java.net.ConnectException: Connection refused\n\tat org.zaproxy.clientapi.core.ClientApi.callApiDom(ClientApi.java:307)\n\tat org.zaproxy.clientapi.core.ClientApi.callApi(ClientApi.java:289)\n\tat org.zaproxy.clientapi.gen.Core.version(Core.java:158)\n\tat net.continuumsecurity.proxy.ZAProxyScanner.validateMinimumRequiredZapVersion(ZAProxyScanner.java:85)\n\tat net.continuumsecurity.proxy.ZAProxyScanner.\u003cinit\u003e(ZAProxyScanner.java:38)\n\tat steps.probeforsqlinjectionvulnerability.preprobeforsqlinjectionvulnerability(probeforsqlinjectionvulnerability.java:16)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.lang.reflect.Method.invoke(Method.java:498)\n\tat cucumber.runtime.Utils$1.call(Utils.java:37)\n\tat cucumber.runtime.Timeout.timeout(Timeout.java:13)\n\tat cucumber.runtime.Utils.invoke(Utils.java:31)\n\tat cucumber.runtime.java.JavaStepDefinition.execute(JavaStepDefinition.java:37)\n\tat cucumber.runtime.StepDefinitionMatch.runStep(StepDefinitionMatch.java:37)\n\tat cucumber.runtime.Runtime.runStep(Runtime.java:298)\n\tat cucumber.runtime.model.StepContainer.runStep(StepContainer.java:44)\n\tat cucumber.runtime.model.StepContainer.runSteps(StepContainer.java:39)\n\tat cucumber.runtime.model.CucumberScenario.run(CucumberScenario.java:48)\n\tat cucumber.runtime.junit.ExecutionUnitRunner.run(ExecutionUnitRunner.java:91)\n\tat cucumber.runtime.junit.FeatureRunner.runChild(FeatureRunner.java:63)\n\tat cucumber.runtime.junit.FeatureRunner.runChild(FeatureRunner.java:18)\n\tat org.junit.runners.ParentRunner$3.run(ParentRunner.java:238)\n\tat org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:63)\n\tat org.junit.runners.ParentRunner.runChildren(ParentRunner.java:236)\n\tat org.junit.runners.ParentRunner.access$000(ParentRunner.java:53)\n\tat org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:229)\n\tat org.junit.runners.ParentRunner.run(ParentRunner.java:309)\n\tat cucumber.runtime.junit.FeatureRunner.run(FeatureRunner.java:70)\n\tat cucumber.api.junit.Cucumber.runChild(Cucumber.java:93)\n\tat cucumber.api.junit.Cucumber.runChild(Cucumber.java:37)\n\tat org.junit.runners.ParentRunner$3.run(ParentRunner.java:238)\n\tat org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:63)\n\tat org.junit.runners.ParentRunner.runChildren(ParentRunner.java:236)\n\tat org.junit.runners.ParentRunner.access$000(ParentRunner.java:53)\n\tat org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:229)\n\tat org.junit.internal.runners.statements.RunAfters.evaluate(RunAfters.java:27)\n\tat org.junit.runners.ParentRunner.run(ParentRunner.java:309)\n\tat cucumber.api.junit.Cucumber.run(Cucumber.java:98)\n\tat org.eclipse.jdt.internal.junit4.runner.JUnit4TestReference.run(JUnit4TestReference.java:86)\n\tat org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:459)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:678)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:382)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:192)\nCaused by: java.net.ConnectException: Connection refused\n\tat java.net.PlainSocketImpl.socketConnect(Native Method)\n\tat java.net.AbstractPlainSocketImpl.doConnect(AbstractPlainSocketImpl.java:350)\n\tat java.net.AbstractPlainSocketImpl.connectToAddress(AbstractPlainSocketImpl.java:206)\n\tat java.net.AbstractPlainSocketImpl.connect(AbstractPlainSocketImpl.java:188)\n\tat java.net.Socket.connect(Socket.java:589)\n\tat java.net.Socket.connect(Socket.java:538)\n\tat sun.net.NetworkClient.doConnect(NetworkClient.java:180)\n\tat sun.net.www.http.HttpClient.openServer(HttpClient.java:432)\n\tat sun.net.www.http.HttpClient$1.run(HttpClient.java:484)\n\tat sun.net.www.http.HttpClient$1.run(HttpClient.java:482)\n\tat java.security.AccessController.doPrivileged(Native Method)\n\tat sun.net.www.http.HttpClient.privilegedOpenServer(HttpClient.java:481)\n\tat sun.net.www.http.HttpClient.openServer(HttpClient.java:522)\n\tat sun.net.www.http.HttpClient.\u003cinit\u003e(HttpClient.java:211)\n\tat sun.net.www.http.HttpClient.New(HttpClient.java:308)\n\tat sun.net.www.http.HttpClient.New(HttpClient.java:326)\n\tat sun.net.www.protocol.http.HttpURLConnection.getNewHttpClient(HttpURLConnection.java:1169)\n\tat sun.net.www.protocol.http.HttpURLConnection.plainConnect0(HttpURLConnection.java:1148)\n\tat sun.net.www.protocol.http.HttpURLConnection.plainConnect(HttpURLConnection.java:999)\n\tat sun.net.www.protocol.http.HttpURLConnection.connect(HttpURLConnection.java:933)\n\tat org.zaproxy.clientapi.core.ClientApi.getConnectionInputStream(ClientApi.java:313)\n\tat org.zaproxy.clientapi.core.ClientApi.callApiDom(ClientApi.java:305)\n\t... 44 more\n",
  "status": "failed"
});
formatter.match({
  "location": "probeforsqlinjectionvulnerability.tryprobeforsqlinjectionvulnerability()"
});
formatter.result({
  "status": "skipped"
});
formatter.match({
  "location": "probeforsqlinjectionvulnerability.assprobeforsqlinjectionvulnerability()"
});
formatter.result({
  "status": "skipped"
});
formatter.match({
  "location": "PatternSteps.assapplicationfirewall()"
});
formatter.result({
  "status": "skipped"
});
formatter.match({
  "location": "PatternSteps.assinputguard()"
});
formatter.result({
  "status": "skipped"
});
formatter.match({
  "location": "PatternSteps.asssecurelogger()"
});
formatter.result({
  "status": "skipped"
});
formatter.uri("CAPEC_108_Step_2_1.feature");
formatter.feature({
  "line": 2,
  "name": "CAPEC-108: Command Line Execution through SQL Injection",
  "description": "",
  "id": "capec-108:-command-line-execution-through-sql-injection",
  "keyword": "Feature",
  "tags": [
    {
      "line": 1,
      "name": "@capec108"
    }
  ]
});
formatter.scenario({
  "comments": [
    {
      "line": 3,
      "value": "#2. Exploit"
    }
  ],
  "line": 4,
  "name": "Step2.1 Achieve arbitrary command execution through SQL Injection with the MSSQL_xp_cmdshell directive",
  "description": "",
  "id": "capec-108:-command-line-execution-through-sql-injection;step2.1-achieve-arbitrary-command-execution-through-sql-injection-with-the-mssql-xp-cmdshell-directive",
  "type": "scenario",
  "keyword": "Scenario"
});
formatter.step({
  "line": 5,
  "name": "prepare to Achieve arbitrary command execution through SQL Injection with the MSSQL_xp_cmdshell directive",
  "keyword": "Given "
});
formatter.step({
  "line": 6,
  "name": "Try to Achieve arbitrary command execution through SQL Injection with the MSSQL_xp_cmdshell directive",
  "keyword": "When "
});
formatter.step({
  "comments": [
    {
      "line": 7,
      "value": "# assertion for attack step success"
    }
  ],
  "line": 8,
  "name": "Assert the success of Achieve arbitrary command execution through SQL Injection with the MSSQL_xp_cmdshell directive",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 9,
      "value": "#assertions for security pattern testing (checker whether the pattern consequences are observed)"
    }
  ],
  "line": 10,
  "name": "assert the consequences of the pattern secure logger",
  "keyword": "Then "
});
formatter.step({
  "line": 11,
  "name": "assert the consequences of the pattern application firewall",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 12,
      "value": "# alternative input guard"
    }
  ],
  "line": 13,
  "name": "assert the consequences of the pattern input guard",
  "keyword": "Then "
});
formatter.match({
  "location": "achievearbitrarycommandexecutionthroughsqlinjectionwiththemssqlxpcmdshelldirective.preachievearbitrarycommandexecutionthroughsqlinjectionwiththemssqlxpcmdshelldirective()"
});
formatter.result({
  "duration": 77713,
  "status": "passed"
});
formatter.match({
  "location": "achievearbitrarycommandexecutionthroughsqlinjectionwiththemssqlxpcmdshelldirective.tryachievearbitrarycommandexecutionthroughsqlinjectionwiththemssqlxpcmdshelldirective()"
});
formatter.result({
  "duration": 12694,
  "status": "passed"
});
formatter.match({
  "location": "achievearbitrarycommandexecutionthroughsqlinjectionwiththemssqlxpcmdshelldirective.assachievearbitrarycommandexecutionthroughsqlinjectionwiththemssqlxpcmdshelldirective()"
});
formatter.result({
  "duration": 13878,
  "status": "passed"
});
formatter.match({
  "location": "PatternSteps.asssecurelogger()"
});
formatter.result({
  "duration": 20096,
  "status": "passed"
});
formatter.match({
  "location": "PatternSteps.assapplicationfirewall()"
});
formatter.result({
  "duration": 10611,
  "status": "passed"
});
formatter.match({
  "location": "PatternSteps.assinputguard()"
});
formatter.result({
  "duration": 9669,
  "status": "passed"
});
formatter.uri("CAPEC_108_Step_2_2.feature");
formatter.feature({
  "line": 2,
  "name": "CAPEC-108: Command Line Execution through SQL Injection",
  "description": "",
  "id": "capec-108:-command-line-execution-through-sql-injection",
  "keyword": "Feature",
  "tags": [
    {
      "line": 1,
      "name": "@capec108"
    }
  ]
});
formatter.scenario({
  "comments": [
    {
      "line": 3,
      "value": "#2. Exploit"
    }
  ],
  "line": 4,
  "name": "Step2.2 Inject malicious data in the database",
  "description": "",
  "id": "capec-108:-command-line-execution-through-sql-injection;step2.2-inject-malicious-data-in-the-database",
  "type": "scenario",
  "keyword": "Scenario"
});
formatter.step({
  "line": 5,
  "name": "prepare to Inject malicious data in the database",
  "keyword": "Given "
});
formatter.step({
  "line": 6,
  "name": "Try to Inject malicious data in the database",
  "keyword": "When "
});
formatter.step({
  "comments": [
    {
      "line": 7,
      "value": "# assertion for attack step success"
    }
  ],
  "line": 8,
  "name": "Assert the success of Inject malicious data in the database",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 9,
      "value": "#assertions for security pattern testing (checker whether the pattern consequences are observed)"
    }
  ],
  "line": 10,
  "name": "assert the consequences of the pattern application firewall",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 11,
      "value": "# alternative input guard"
    }
  ],
  "line": 12,
  "name": "assert the consequences of the pattern input guard",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 13,
      "value": "# alternative application firewall"
    }
  ],
  "line": 14,
  "name": "assert the consequences of the pattern secure logger",
  "keyword": "Then "
});
formatter.match({
  "location": "injectmaliciousdatainthedatabase.preinjectmaliciousdatainthedatabase()"
});
formatter.result({
  "duration": 48365,
  "status": "passed"
});
formatter.match({
  "location": "injectmaliciousdatainthedatabase.tryinjectmaliciousdatainthedatabase()"
});
formatter.result({
  "duration": 10887,
  "status": "passed"
});
formatter.match({
  "location": "injectmaliciousdatainthedatabase.assinjectmaliciousdatainthedatabase()"
});
formatter.result({
  "duration": 9785,
  "status": "passed"
});
formatter.match({
  "location": "PatternSteps.assapplicationfirewall()"
});
formatter.result({
  "duration": 16621,
  "status": "passed"
});
formatter.match({
  "location": "PatternSteps.assinputguard()"
});
formatter.result({
  "duration": 8584,
  "status": "passed"
});
formatter.match({
  "location": "PatternSteps.asssecurelogger()"
});
formatter.result({
  "duration": 10843,
  "status": "passed"
});
formatter.uri("CAPEC_108_Step_2_3.feature");
formatter.feature({
  "line": 2,
  "name": "CAPEC-108: Command Line Execution through SQL Injection",
  "description": "",
  "id": "capec-108:-command-line-execution-through-sql-injection",
  "keyword": "Feature",
  "tags": [
    {
      "line": 1,
      "name": "@capec108"
    }
  ]
});
formatter.scenario({
  "comments": [
    {
      "line": 3,
      "value": "#2. Exploit"
    }
  ],
  "line": 4,
  "name": "Step2.3 Trigger command line execution with injected arguments",
  "description": "",
  "id": "capec-108:-command-line-execution-through-sql-injection;step2.3-trigger-command-line-execution-with-injected-arguments",
  "type": "scenario",
  "keyword": "Scenario"
});
formatter.step({
  "line": 5,
  "name": "prepare to Trigger command line execution with injected arguments",
  "keyword": "Given "
});
formatter.step({
  "line": 6,
  "name": "Try to Trigger command line execution with injected arguments",
  "keyword": "When "
});
formatter.step({
  "comments": [
    {
      "line": 7,
      "value": "# assertion for attack step success"
    }
  ],
  "line": 8,
  "name": "Assert the success of Trigger command line execution with injected arguments",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 9,
      "value": "#assertions for security pattern testing (checker whether the pattern consequences are observed)"
    }
  ],
  "line": 10,
  "name": "assert the consequences of the pattern",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 11,
      "value": "#"
    }
  ],
  "line": 12,
  "name": "assert the consequences of the pattern audit interceptor",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 13,
      "value": "# depends secure logger"
    }
  ],
  "line": 14,
  "name": "assert the consequences of the pattern secure logger",
  "keyword": "Then "
});
formatter.match({
  "location": "triggercommandlineexecutionwithinjectedarguments.pretriggercommandlineexecutionwithinjectedarguments()"
});
formatter.result({
  "duration": 70271,
  "status": "passed"
});
formatter.match({
  "location": "triggercommandlineexecutionwithinjectedarguments.trytriggercommandlineexecutionwithinjectedarguments()"
});
formatter.result({
  "duration": 45097,
  "status": "passed"
});
formatter.match({
  "location": "triggercommandlineexecutionwithinjectedarguments.asstriggercommandlineexecutionwithinjectedarguments()"
});
formatter.result({
  "duration": 9379,
  "status": "passed"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({
  "location": "PatternSteps.assauditinterceptor()"
});
formatter.result({
  "status": "skipped"
});
formatter.match({
  "location": "PatternSteps.asssecurelogger()"
});
formatter.result({
  "status": "skipped"
});
formatter.uri("CAPEC_109_Step_1_1.feature");
formatter.feature({
  "line": 2,
  "name": "CAPEC-109: Object Relational Mapping Injection",
  "description": "",
  "id": "capec-109:-object-relational-mapping-injection",
  "keyword": "Feature",
  "tags": [
    {
      "line": 1,
      "name": "@capec109"
    }
  ]
});
formatter.scenario({
  "comments": [
    {
      "line": 3,
      "value": "#1. Explore"
    }
  ],
  "line": 4,
  "name": "Step1.1 Determine Persistence Framework Used",
  "description": "",
  "id": "capec-109:-object-relational-mapping-injection;step1.1-determine-persistence-framework-used",
  "type": "scenario",
  "keyword": "Scenario"
});
formatter.step({
  "line": 5,
  "name": "prepare to Determine Persistence Framework Used",
  "keyword": "Given "
});
formatter.step({
  "line": 6,
  "name": "Try to Determine Persistence Framework Used",
  "keyword": "When "
});
formatter.step({
  "comments": [
    {
      "line": 7,
      "value": "# assertion for attack step success"
    }
  ],
  "line": 8,
  "name": "Assert the success of Determine Persistence Framework Used",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 9,
      "value": "#assertions for security pattern testing (checker whether the pattern consequences are observed)"
    }
  ],
  "line": 10,
  "name": "assert the consequences of the pattern",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 11,
      "value": "#"
    }
  ],
  "line": 12,
  "name": "assert the consequences of the pattern audit interceptor",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 13,
      "value": "# depends secure logger"
    }
  ],
  "line": 14,
  "name": "assert the consequences of the pattern secure logger",
  "keyword": "Then "
});
formatter.match({
  "location": "determinepersistenceframeworkused.predeterminepersistenceframeworkused()"
});
formatter.result({
  "duration": 83514,
  "status": "passed"
});
formatter.match({
  "location": "determinepersistenceframeworkused.trydeterminepersistenceframeworkused()"
});
formatter.result({
  "duration": 46602,
  "status": "passed"
});
formatter.match({
  "location": "determinepersistenceframeworkused.assdeterminepersistenceframeworkused()"
});
formatter.result({
  "duration": 12891,
  "status": "passed"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({
  "location": "PatternSteps.assauditinterceptor()"
});
formatter.result({
  "status": "skipped"
});
formatter.match({
  "location": "PatternSteps.asssecurelogger()"
});
formatter.result({
  "status": "skipped"
});
formatter.uri("CAPEC_109_Step_1_2.feature");
formatter.feature({
  "line": 2,
  "name": "CAPEC-109: Object Relational Mapping Injection",
  "description": "",
  "id": "capec-109:-object-relational-mapping-injection",
  "keyword": "Feature",
  "tags": [
    {
      "line": 1,
      "name": "@capec109"
    }
  ]
});
formatter.scenario({
  "comments": [
    {
      "line": 3,
      "value": "#1. Explore"
    }
  ],
  "line": 4,
  "name": "Step1.2 Probe for ORM Injection vulnerabilities",
  "description": "",
  "id": "capec-109:-object-relational-mapping-injection;step1.2-probe-for-orm-injection-vulnerabilities",
  "type": "scenario",
  "keyword": "Scenario"
});
formatter.step({
  "line": 5,
  "name": "prepare to Probe for ORM Injection vulnerabilities",
  "keyword": "Given "
});
formatter.step({
  "line": 6,
  "name": "Try to Probe for ORM Injection vulnerabilities",
  "keyword": "When "
});
formatter.step({
  "comments": [
    {
      "line": 7,
      "value": "# assertion for attack step success"
    }
  ],
  "line": 8,
  "name": "Assert the success of Probe for ORM Injection vulnerabilities",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 9,
      "value": "#assertions for security pattern testing (checker whether the pattern consequences are observed)"
    }
  ],
  "line": 10,
  "name": "assert the consequences of the pattern",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 11,
      "value": "#"
    }
  ],
  "line": 12,
  "name": "assert the consequences of the pattern audit interceptor",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 13,
      "value": "# depends secure logger"
    }
  ],
  "line": 14,
  "name": "assert the consequences of the pattern secure logger",
  "keyword": "Then "
});
formatter.match({
  "location": "probefororminjectionvulnerabilities.preprobefororminjectionvulnerabilities()"
});
formatter.result({
  "duration": 79856,
  "status": "passed"
});
formatter.match({
  "location": "probefororminjectionvulnerabilities.tryprobefororminjectionvulnerabilities()"
});
formatter.result({
  "duration": 10338,
  "status": "passed"
});
formatter.match({
  "location": "probefororminjectionvulnerabilities.assprobefororminjectionvulnerabilities()"
});
formatter.result({
  "duration": 9253,
  "status": "passed"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({
  "location": "PatternSteps.assauditinterceptor()"
});
formatter.result({
  "status": "skipped"
});
formatter.match({
  "location": "PatternSteps.asssecurelogger()"
});
formatter.result({
  "status": "skipped"
});
formatter.uri("CAPEC_109_Step_2_1.feature");
formatter.feature({
  "line": 2,
  "name": "CAPEC-109: Object Relational Mapping Injection",
  "description": "",
  "id": "capec-109:-object-relational-mapping-injection",
  "keyword": "Feature",
  "tags": [
    {
      "line": 1,
      "name": "@capec109"
    }
  ]
});
formatter.scenario({
  "comments": [
    {
      "line": 3,
      "value": "#2. Exploit"
    }
  ],
  "line": 4,
  "name": "Step2.1 Perform SQL Injection through the generated data access layer",
  "description": "",
  "id": "capec-109:-object-relational-mapping-injection;step2.1-perform-sql-injection-through-the-generated-data-access-layer",
  "type": "scenario",
  "keyword": "Scenario"
});
formatter.step({
  "line": 5,
  "name": "prepare to Perform SQL Injection through the generated data access layer",
  "keyword": "Given "
});
formatter.step({
  "line": 6,
  "name": "Try to Perform SQL Injection through the generated data access layer",
  "keyword": "When "
});
formatter.step({
  "comments": [
    {
      "line": 7,
      "value": "# assertion for attack step success"
    }
  ],
  "line": 8,
  "name": "Assert the success of Perform SQL Injection through the generated data access layer",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 9,
      "value": "#assertions for security pattern testing (checker whether the pattern consequences are observed)"
    }
  ],
  "line": 10,
  "name": "assert the consequences of the pattern",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 11,
      "value": "#"
    }
  ],
  "line": 12,
  "name": "assert the consequences of the pattern audit interceptor",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 13,
      "value": "# depends secure logger"
    }
  ],
  "line": 14,
  "name": "assert the consequences of the pattern secure logger",
  "keyword": "Then "
});
formatter.match({
  "location": "performsqlinjectionthroughthegenerateddataaccesslayer.preperformsqlinjectionthroughthegenerateddataaccesslayer()"
});
formatter.result({
  "duration": 53679,
  "status": "passed"
});
formatter.match({
  "location": "performsqlinjectionthroughthegenerateddataaccesslayer.tryperformsqlinjectionthroughthegenerateddataaccesslayer()"
});
formatter.result({
  "duration": 9153,
  "status": "passed"
});
formatter.match({
  "location": "performsqlinjectionthroughthegenerateddataaccesslayer.assperformsqlinjectionthroughthegenerateddataaccesslayer()"
});
formatter.result({
  "duration": 9126,
  "status": "passed"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({
  "location": "PatternSteps.assauditinterceptor()"
});
formatter.result({
  "status": "skipped"
});
formatter.match({
  "location": "PatternSteps.asssecurelogger()"
});
formatter.result({
  "status": "skipped"
});
formatter.uri("CAPEC_10_Step_1_1.feature");
formatter.feature({
  "line": 2,
  "name": "CAPEC-10: Buffer Overflow via Environment Variables",
  "description": "",
  "id": "capec-10:-buffer-overflow-via-environment-variables",
  "keyword": "Feature",
  "tags": [
    {
      "line": 1,
      "name": "@capec10"
    }
  ]
});
formatter.scenario({
  "comments": [
    {
      "line": 3,
      "value": "#1. Explore"
    }
  ],
  "line": 4,
  "name": "Step1.1",
  "description": "",
  "id": "capec-10:-buffer-overflow-via-environment-variables;step1.1",
  "type": "scenario",
  "keyword": "Scenario"
});
formatter.step({
  "line": 5,
  "name": "prepare to",
  "keyword": "Given "
});
formatter.step({
  "line": 6,
  "name": "Try to",
  "keyword": "When "
});
formatter.step({
  "comments": [
    {
      "line": 7,
      "value": "# assertion for attack step success"
    }
  ],
  "line": 8,
  "name": "Assert the success of",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 9,
      "value": "#assertions for security pattern testing (checker whether the pattern consequences are observed)"
    }
  ],
  "line": 10,
  "name": "assert the consequences of the pattern",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 11,
      "value": "#"
    }
  ],
  "line": 12,
  "name": "assert the consequences of the pattern audit interceptor",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 13,
      "value": "# depends secure logger"
    }
  ],
  "line": 14,
  "name": "assert the consequences of the pattern secure logger",
  "keyword": "Then "
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({
  "location": "PatternSteps.assauditinterceptor()"
});
formatter.result({
  "status": "skipped"
});
formatter.match({
  "location": "PatternSteps.asssecurelogger()"
});
formatter.result({
  "status": "skipped"
});
formatter.uri("CAPEC_10_Step_2_1.feature");
formatter.feature({
  "line": 2,
  "name": "CAPEC-10: Buffer Overflow via Environment Variables",
  "description": "",
  "id": "capec-10:-buffer-overflow-via-environment-variables",
  "keyword": "Feature",
  "tags": [
    {
      "line": 1,
      "name": "@capec10"
    }
  ]
});
formatter.scenario({
  "comments": [
    {
      "line": 3,
      "value": "#2. Experiment"
    }
  ],
  "line": 4,
  "name": "Step2.1",
  "description": "",
  "id": "capec-10:-buffer-overflow-via-environment-variables;step2.1",
  "type": "scenario",
  "keyword": "Scenario"
});
formatter.step({
  "line": 5,
  "name": "prepare to",
  "keyword": "Given "
});
formatter.step({
  "line": 6,
  "name": "Try to",
  "keyword": "When "
});
formatter.step({
  "comments": [
    {
      "line": 7,
      "value": "# assertion for attack step success"
    }
  ],
  "line": 8,
  "name": "Assert the success of",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 9,
      "value": "#assertions for security pattern testing (checker whether the pattern consequences are observed)"
    }
  ],
  "line": 10,
  "name": "assert the consequences of the pattern",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 11,
      "value": "#"
    }
  ],
  "line": 12,
  "name": "assert the consequences of the pattern audit interceptor",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 13,
      "value": "# depends secure logger"
    }
  ],
  "line": 14,
  "name": "assert the consequences of the pattern secure logger",
  "keyword": "Then "
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({
  "location": "PatternSteps.assauditinterceptor()"
});
formatter.result({
  "status": "skipped"
});
formatter.match({
  "location": "PatternSteps.asssecurelogger()"
});
formatter.result({
  "status": "skipped"
});
formatter.uri("CAPEC_10_Step_3_1.feature");
formatter.feature({
  "line": 2,
  "name": "CAPEC-10: Buffer Overflow via Environment Variables",
  "description": "",
  "id": "capec-10:-buffer-overflow-via-environment-variables",
  "keyword": "Feature",
  "tags": [
    {
      "line": 1,
      "name": "@capec10"
    }
  ]
});
formatter.scenario({
  "comments": [
    {
      "line": 3,
      "value": "#3. Exploit"
    }
  ],
  "line": 4,
  "name": "Step3.1",
  "description": "",
  "id": "capec-10:-buffer-overflow-via-environment-variables;step3.1",
  "type": "scenario",
  "keyword": "Scenario"
});
formatter.step({
  "line": 5,
  "name": "prepare to",
  "keyword": "Given "
});
formatter.step({
  "line": 6,
  "name": "Try to",
  "keyword": "When "
});
formatter.step({
  "comments": [
    {
      "line": 7,
      "value": "# assertion for attack step success"
    }
  ],
  "line": 8,
  "name": "Assert the success of",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 9,
      "value": "#assertions for security pattern testing (checker whether the pattern consequences are observed)"
    }
  ],
  "line": 10,
  "name": "assert the consequences of the pattern",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 11,
      "value": "#"
    }
  ],
  "line": 12,
  "name": "assert the consequences of the pattern audit interceptor",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 13,
      "value": "# depends secure logger"
    }
  ],
  "line": 14,
  "name": "assert the consequences of the pattern secure logger",
  "keyword": "Then "
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({
  "location": "PatternSteps.assauditinterceptor()"
});
formatter.result({
  "status": "skipped"
});
formatter.match({
  "location": "PatternSteps.asssecurelogger()"
});
formatter.result({
  "status": "skipped"
});
formatter.uri("CAPEC_110_Step_1_1.feature");
formatter.feature({
  "line": 2,
  "name": "CAPEC-110: SQL Injection through SOAP Parameter Tampering",
  "description": "",
  "id": "capec-110:-sql-injection-through-soap-parameter-tampering",
  "keyword": "Feature",
  "tags": [
    {
      "line": 1,
      "name": "@capec110"
    }
  ]
});
formatter.scenario({
  "comments": [
    {
      "line": 3,
      "value": "#1. Explore"
    }
  ],
  "line": 4,
  "name": "Step1.1 Detect Incorrect SOAP Parameter Handling",
  "description": "",
  "id": "capec-110:-sql-injection-through-soap-parameter-tampering;step1.1-detect-incorrect-soap-parameter-handling",
  "type": "scenario",
  "keyword": "Scenario"
});
formatter.step({
  "line": 5,
  "name": "prepare to Detect Incorrect SOAP Parameter Handling",
  "keyword": "Given "
});
formatter.step({
  "line": 6,
  "name": "Try to Detect Incorrect SOAP Parameter Handling",
  "keyword": "When "
});
formatter.step({
  "comments": [
    {
      "line": 7,
      "value": "# assertion for attack step success"
    }
  ],
  "line": 8,
  "name": "Assert the success of Detect Incorrect SOAP Parameter Handling",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 9,
      "value": "#assertions for security pattern testing (checker whether the pattern consequences are observed)"
    }
  ],
  "line": 10,
  "name": "assert the consequences of the pattern",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 11,
      "value": "#"
    }
  ],
  "line": 12,
  "name": "assert the consequences of the pattern audit interceptor",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 13,
      "value": "# depends secure logger"
    }
  ],
  "line": 14,
  "name": "assert the consequences of the pattern secure logger",
  "keyword": "Then "
});
formatter.match({
  "location": "detectincorrectsoapparameterhandling.predetectincorrectsoapparameterhandling()"
});
formatter.result({
  "duration": 53098,
  "status": "passed"
});
formatter.match({
  "location": "detectincorrectsoapparameterhandling.trydetectincorrectsoapparameterhandling()"
});
formatter.result({
  "duration": 11189,
  "status": "passed"
});
formatter.match({
  "location": "detectincorrectsoapparameterhandling.assdetectincorrectsoapparameterhandling()"
});
formatter.result({
  "duration": 10118,
  "status": "passed"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({
  "location": "PatternSteps.assauditinterceptor()"
});
formatter.result({
  "status": "skipped"
});
formatter.match({
  "location": "PatternSteps.asssecurelogger()"
});
formatter.result({
  "status": "skipped"
});
formatter.uri("CAPEC_110_Step_2_1.feature");
formatter.feature({
  "line": 2,
  "name": "CAPEC-110: SQL Injection through SOAP Parameter Tampering",
  "description": "",
  "id": "capec-110:-sql-injection-through-soap-parameter-tampering",
  "keyword": "Feature",
  "tags": [
    {
      "line": 1,
      "name": "@capec110"
    }
  ]
});
formatter.scenario({
  "comments": [
    {
      "line": 3,
      "value": "#2. Experiment"
    }
  ],
  "line": 4,
  "name": "Step2.1 Probe for SQL Injection vulnerability",
  "description": "",
  "id": "capec-110:-sql-injection-through-soap-parameter-tampering;step2.1-probe-for-sql-injection-vulnerability",
  "type": "scenario",
  "keyword": "Scenario"
});
formatter.step({
  "line": 5,
  "name": "prepare to Probe for SQL Injection vulnerability",
  "keyword": "Given "
});
formatter.step({
  "line": 6,
  "name": "Try to Probe for SQL Injection vulnerability",
  "keyword": "When "
});
formatter.step({
  "comments": [
    {
      "line": 7,
      "value": "# assertion for attack step success"
    }
  ],
  "line": 8,
  "name": "Assert the success of Probe for SQL Injection vulnerability",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 9,
      "value": "#assertions for security pattern testing (checker whether the pattern consequences are observed)"
    }
  ],
  "line": 10,
  "name": "assert the consequences of the pattern application firewall",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 11,
      "value": "# alternative input guard"
    }
  ],
  "line": 12,
  "name": "assert the consequences of the pattern input guard",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 13,
      "value": "# alternative application firewall"
    }
  ],
  "line": 14,
  "name": "assert the consequences of the pattern secure logger",
  "keyword": "Then "
});
formatter.match({
  "location": "probeforsqlinjectionvulnerability.preprobeforsqlinjectionvulnerability()"
});
formatter.result({
  "duration": 1861610,
  "error_message": "net.continuumsecurity.proxy.ProxyException: org.zaproxy.clientapi.core.ClientApiException: java.net.ConnectException: Connection refused\n\tat net.continuumsecurity.proxy.ZAProxyScanner.validateMinimumRequiredZapVersion(ZAProxyScanner.java:96)\n\tat net.continuumsecurity.proxy.ZAProxyScanner.\u003cinit\u003e(ZAProxyScanner.java:38)\n\tat steps.probeforsqlinjectionvulnerability.preprobeforsqlinjectionvulnerability(probeforsqlinjectionvulnerability.java:16)\n\tat ✽.Given prepare to Probe for SQL Injection vulnerability(CAPEC_110_Step_2_1.feature:5)\nCaused by: org.zaproxy.clientapi.core.ClientApiException: java.net.ConnectException: Connection refused\n\tat org.zaproxy.clientapi.core.ClientApi.callApiDom(ClientApi.java:307)\n\tat org.zaproxy.clientapi.core.ClientApi.callApi(ClientApi.java:289)\n\tat org.zaproxy.clientapi.gen.Core.version(Core.java:158)\n\tat net.continuumsecurity.proxy.ZAProxyScanner.validateMinimumRequiredZapVersion(ZAProxyScanner.java:85)\n\tat net.continuumsecurity.proxy.ZAProxyScanner.\u003cinit\u003e(ZAProxyScanner.java:38)\n\tat steps.probeforsqlinjectionvulnerability.preprobeforsqlinjectionvulnerability(probeforsqlinjectionvulnerability.java:16)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.lang.reflect.Method.invoke(Method.java:498)\n\tat cucumber.runtime.Utils$1.call(Utils.java:37)\n\tat cucumber.runtime.Timeout.timeout(Timeout.java:13)\n\tat cucumber.runtime.Utils.invoke(Utils.java:31)\n\tat cucumber.runtime.java.JavaStepDefinition.execute(JavaStepDefinition.java:37)\n\tat cucumber.runtime.StepDefinitionMatch.runStep(StepDefinitionMatch.java:37)\n\tat cucumber.runtime.Runtime.runStep(Runtime.java:298)\n\tat cucumber.runtime.model.StepContainer.runStep(StepContainer.java:44)\n\tat cucumber.runtime.model.StepContainer.runSteps(StepContainer.java:39)\n\tat cucumber.runtime.model.CucumberScenario.run(CucumberScenario.java:48)\n\tat cucumber.runtime.junit.ExecutionUnitRunner.run(ExecutionUnitRunner.java:91)\n\tat cucumber.runtime.junit.FeatureRunner.runChild(FeatureRunner.java:63)\n\tat cucumber.runtime.junit.FeatureRunner.runChild(FeatureRunner.java:18)\n\tat org.junit.runners.ParentRunner$3.run(ParentRunner.java:238)\n\tat org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:63)\n\tat org.junit.runners.ParentRunner.runChildren(ParentRunner.java:236)\n\tat org.junit.runners.ParentRunner.access$000(ParentRunner.java:53)\n\tat org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:229)\n\tat org.junit.runners.ParentRunner.run(ParentRunner.java:309)\n\tat cucumber.runtime.junit.FeatureRunner.run(FeatureRunner.java:70)\n\tat cucumber.api.junit.Cucumber.runChild(Cucumber.java:93)\n\tat cucumber.api.junit.Cucumber.runChild(Cucumber.java:37)\n\tat org.junit.runners.ParentRunner$3.run(ParentRunner.java:238)\n\tat org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:63)\n\tat org.junit.runners.ParentRunner.runChildren(ParentRunner.java:236)\n\tat org.junit.runners.ParentRunner.access$000(ParentRunner.java:53)\n\tat org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:229)\n\tat org.junit.internal.runners.statements.RunAfters.evaluate(RunAfters.java:27)\n\tat org.junit.runners.ParentRunner.run(ParentRunner.java:309)\n\tat cucumber.api.junit.Cucumber.run(Cucumber.java:98)\n\tat org.eclipse.jdt.internal.junit4.runner.JUnit4TestReference.run(JUnit4TestReference.java:86)\n\tat org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:459)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:678)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:382)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:192)\nCaused by: java.net.ConnectException: Connection refused\n\tat java.net.PlainSocketImpl.socketConnect(Native Method)\n\tat java.net.AbstractPlainSocketImpl.doConnect(AbstractPlainSocketImpl.java:350)\n\tat java.net.AbstractPlainSocketImpl.connectToAddress(AbstractPlainSocketImpl.java:206)\n\tat java.net.AbstractPlainSocketImpl.connect(AbstractPlainSocketImpl.java:188)\n\tat java.net.Socket.connect(Socket.java:589)\n\tat java.net.Socket.connect(Socket.java:538)\n\tat sun.net.NetworkClient.doConnect(NetworkClient.java:180)\n\tat sun.net.www.http.HttpClient.openServer(HttpClient.java:432)\n\tat sun.net.www.http.HttpClient$1.run(HttpClient.java:484)\n\tat sun.net.www.http.HttpClient$1.run(HttpClient.java:482)\n\tat java.security.AccessController.doPrivileged(Native Method)\n\tat sun.net.www.http.HttpClient.privilegedOpenServer(HttpClient.java:481)\n\tat sun.net.www.http.HttpClient.openServer(HttpClient.java:522)\n\tat sun.net.www.http.HttpClient.\u003cinit\u003e(HttpClient.java:211)\n\tat sun.net.www.http.HttpClient.New(HttpClient.java:308)\n\tat sun.net.www.http.HttpClient.New(HttpClient.java:326)\n\tat sun.net.www.protocol.http.HttpURLConnection.getNewHttpClient(HttpURLConnection.java:1169)\n\tat sun.net.www.protocol.http.HttpURLConnection.plainConnect0(HttpURLConnection.java:1148)\n\tat sun.net.www.protocol.http.HttpURLConnection.plainConnect(HttpURLConnection.java:999)\n\tat sun.net.www.protocol.http.HttpURLConnection.connect(HttpURLConnection.java:933)\n\tat org.zaproxy.clientapi.core.ClientApi.getConnectionInputStream(ClientApi.java:313)\n\tat org.zaproxy.clientapi.core.ClientApi.callApiDom(ClientApi.java:305)\n\t... 44 more\n",
  "status": "failed"
});
formatter.match({
  "location": "probeforsqlinjectionvulnerability.tryprobeforsqlinjectionvulnerability()"
});
formatter.result({
  "status": "skipped"
});
formatter.match({
  "location": "probeforsqlinjectionvulnerability.assprobeforsqlinjectionvulnerability()"
});
formatter.result({
  "status": "skipped"
});
formatter.match({
  "location": "PatternSteps.assapplicationfirewall()"
});
formatter.result({
  "status": "skipped"
});
formatter.match({
  "location": "PatternSteps.assinputguard()"
});
formatter.result({
  "status": "skipped"
});
formatter.match({
  "location": "PatternSteps.asssecurelogger()"
});
formatter.result({
  "status": "skipped"
});
formatter.uri("CAPEC_110_Step_3_1.feature");
formatter.feature({
  "line": 2,
  "name": "CAPEC-110: SQL Injection through SOAP Parameter Tampering",
  "description": "",
  "id": "capec-110:-sql-injection-through-soap-parameter-tampering",
  "keyword": "Feature",
  "tags": [
    {
      "line": 1,
      "name": "@capec110"
    }
  ]
});
formatter.scenario({
  "comments": [
    {
      "line": 3,
      "value": "#3. Exploit"
    }
  ],
  "line": 4,
  "name": "Step3.1 Inject SQL via SOAP Parameters",
  "description": "",
  "id": "capec-110:-sql-injection-through-soap-parameter-tampering;step3.1-inject-sql-via-soap-parameters",
  "type": "scenario",
  "keyword": "Scenario"
});
formatter.step({
  "line": 5,
  "name": "prepare to Inject SQL via SOAP Parameters",
  "keyword": "Given "
});
formatter.step({
  "line": 6,
  "name": "Try to Inject SQL via SOAP Parameters",
  "keyword": "When "
});
formatter.step({
  "comments": [
    {
      "line": 7,
      "value": "# assertion for attack step success"
    }
  ],
  "line": 8,
  "name": "Assert the success of Inject SQL via SOAP Parameters",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 9,
      "value": "#assertions for security pattern testing (checker whether the pattern consequences are observed)"
    }
  ],
  "line": 10,
  "name": "assert the consequences of the pattern",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 11,
      "value": "#"
    }
  ],
  "line": 12,
  "name": "assert the consequences of the pattern audit interceptor",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 13,
      "value": "# depends secure logger"
    }
  ],
  "line": 14,
  "name": "assert the consequences of the pattern secure logger",
  "keyword": "Then "
});
formatter.match({
  "location": "injectsqlviasoapparameters.preinjectsqlviasoapparameters()"
});
formatter.result({
  "duration": 55401,
  "status": "passed"
});
formatter.match({
  "location": "injectsqlviasoapparameters.tryinjectsqlviasoapparameters()"
});
formatter.result({
  "duration": 11483,
  "status": "passed"
});
formatter.match({
  "location": "injectsqlviasoapparameters.assinjectsqlviasoapparameters()"
});
formatter.result({
  "duration": 10749,
  "status": "passed"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({
  "location": "PatternSteps.assauditinterceptor()"
});
formatter.result({
  "status": "skipped"
});
formatter.match({
  "location": "PatternSteps.asssecurelogger()"
});
formatter.result({
  "status": "skipped"
});
formatter.uri("CAPEC_111_Step_1_1.feature");
formatter.feature({
  "line": 2,
  "name": "CAPEC-111: JSON Hijacking (aka JavaScript Hijacking)",
  "description": "",
  "id": "capec-111:-json-hijacking-(aka-javascript-hijacking)",
  "keyword": "Feature",
  "tags": [
    {
      "line": 1,
      "name": "@capec111"
    }
  ]
});
formatter.scenario({
  "comments": [
    {
      "line": 3,
      "value": "#1. Explore"
    }
  ],
  "line": 4,
  "name": "Step1.1 Understand How to Request JSON Responses from the Target System",
  "description": "",
  "id": "capec-111:-json-hijacking-(aka-javascript-hijacking);step1.1-understand-how-to-request-json-responses-from-the-target-system",
  "type": "scenario",
  "keyword": "Scenario"
});
formatter.step({
  "line": 5,
  "name": "prepare to Understand How to Request JSON Responses from the Target System",
  "keyword": "Given "
});
formatter.step({
  "line": 6,
  "name": "Try to Understand How to Request JSON Responses from the Target System",
  "keyword": "When "
});
formatter.step({
  "comments": [
    {
      "line": 7,
      "value": "# assertion for attack step success"
    }
  ],
  "line": 8,
  "name": "Assert the success of Understand How to Request JSON Responses from the Target System",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 9,
      "value": "#assertions for security pattern testing (checker whether the pattern consequences are observed)"
    }
  ],
  "line": 10,
  "name": "assert the consequences of the pattern",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 11,
      "value": "#"
    }
  ],
  "line": 12,
  "name": "assert the consequences of the pattern audit interceptor",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 13,
      "value": "# depends secure logger"
    }
  ],
  "line": 14,
  "name": "assert the consequences of the pattern secure logger",
  "keyword": "Then "
});
formatter.match({
  "location": "understandhowtorequestjsonresponsesfromthetargetsystem.preunderstandhowtorequestjsonresponsesfromthetargetsystem()"
});
formatter.result({
  "duration": 66444,
  "status": "passed"
});
formatter.match({
  "location": "understandhowtorequestjsonresponsesfromthetargetsystem.tryunderstandhowtorequestjsonresponsesfromthetargetsystem()"
});
formatter.result({
  "duration": 16264,
  "status": "passed"
});
formatter.match({
  "location": "understandhowtorequestjsonresponsesfromthetargetsystem.assunderstandhowtorequestjsonresponsesfromthetargetsystem()"
});
formatter.result({
  "duration": 15425,
  "status": "passed"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({
  "location": "PatternSteps.assauditinterceptor()"
});
formatter.result({
  "status": "skipped"
});
formatter.match({
  "location": "PatternSteps.asssecurelogger()"
});
formatter.result({
  "status": "skipped"
});
formatter.uri("CAPEC_111_Step_2_1.feature");
formatter.feature({
  "line": 2,
  "name": "CAPEC-111: JSON Hijacking (aka JavaScript Hijacking)",
  "description": "",
  "id": "capec-111:-json-hijacking-(aka-javascript-hijacking)",
  "keyword": "Feature",
  "tags": [
    {
      "line": 1,
      "name": "@capec111"
    }
  ]
});
formatter.scenario({
  "comments": [
    {
      "line": 3,
      "value": "#2. Experiment"
    }
  ],
  "line": 4,
  "name": "Step2.1 Craft a malicious website",
  "description": "",
  "id": "capec-111:-json-hijacking-(aka-javascript-hijacking);step2.1-craft-a-malicious-website",
  "type": "scenario",
  "keyword": "Scenario"
});
formatter.step({
  "line": 5,
  "name": "prepare to Craft a malicious website",
  "keyword": "Given "
});
formatter.step({
  "line": 6,
  "name": "Try to Craft a malicious website",
  "keyword": "When "
});
formatter.step({
  "comments": [
    {
      "line": 7,
      "value": "# assertion for attack step success"
    }
  ],
  "line": 8,
  "name": "Assert the success of Craft a malicious website",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 9,
      "value": "#assertions for security pattern testing (checker whether the pattern consequences are observed)"
    }
  ],
  "line": 10,
  "name": "assert the consequences of the pattern",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 11,
      "value": "#"
    }
  ],
  "line": 12,
  "name": "assert the consequences of the pattern audit interceptor",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 13,
      "value": "# depends secure logger"
    }
  ],
  "line": 14,
  "name": "assert the consequences of the pattern secure logger",
  "keyword": "Then "
});
formatter.match({
  "location": "craftamaliciouswebsite.precraftamaliciouswebsite()"
});
formatter.result({
  "duration": 91052,
  "status": "passed"
});
formatter.match({
  "location": "craftamaliciouswebsite.trycraftamaliciouswebsite()"
});
formatter.result({
  "duration": 18514,
  "status": "passed"
});
formatter.match({
  "location": "craftamaliciouswebsite.asscraftamaliciouswebsite()"
});
formatter.result({
  "duration": 21585,
  "status": "passed"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({
  "location": "PatternSteps.assauditinterceptor()"
});
formatter.result({
  "status": "skipped"
});
formatter.match({
  "location": "PatternSteps.asssecurelogger()"
});
formatter.result({
  "status": "skipped"
});
formatter.uri("CAPEC_111_Step_3_1.feature");
formatter.feature({
  "line": 2,
  "name": "CAPEC-111: JSON Hijacking (aka JavaScript Hijacking)",
  "description": "",
  "id": "capec-111:-json-hijacking-(aka-javascript-hijacking)",
  "keyword": "Feature",
  "tags": [
    {
      "line": 1,
      "name": "@capec111"
    }
  ]
});
formatter.scenario({
  "comments": [
    {
      "line": 3,
      "value": "#3. Exploit"
    }
  ],
  "line": 4,
  "name": "Step3.1 Launch JSON hijack",
  "description": "",
  "id": "capec-111:-json-hijacking-(aka-javascript-hijacking);step3.1-launch-json-hijack",
  "type": "scenario",
  "keyword": "Scenario"
});
formatter.step({
  "line": 5,
  "name": "prepare to Launch JSON hijack",
  "keyword": "Given "
});
formatter.step({
  "line": 6,
  "name": "Try to Launch JSON hijack",
  "keyword": "When "
});
formatter.step({
  "comments": [
    {
      "line": 7,
      "value": "# assertion for attack step success"
    }
  ],
  "line": 8,
  "name": "Assert the success of Launch JSON hijack",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 9,
      "value": "#assertions for security pattern testing (checker whether the pattern consequences are observed)"
    }
  ],
  "line": 10,
  "name": "assert the consequences of the pattern",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 11,
      "value": "#"
    }
  ],
  "line": 12,
  "name": "assert the consequences of the pattern audit interceptor",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 13,
      "value": "# depends secure logger"
    }
  ],
  "line": 14,
  "name": "assert the consequences of the pattern secure logger",
  "keyword": "Then "
});
formatter.match({
  "location": "launchjsonhijack.prelaunchjsonhijack()"
});
formatter.result({
  "duration": 87320,
  "status": "passed"
});
formatter.match({
  "location": "launchjsonhijack.trylaunchjsonhijack()"
});
formatter.result({
  "duration": 20783,
  "status": "passed"
});
formatter.match({
  "location": "launchjsonhijack.asslaunchjsonhijack()"
});
formatter.result({
  "duration": 15147,
  "status": "passed"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({
  "location": "PatternSteps.assauditinterceptor()"
});
formatter.result({
  "status": "skipped"
});
formatter.match({
  "location": "PatternSteps.asssecurelogger()"
});
formatter.result({
  "status": "skipped"
});
formatter.uri("CAPEC_112_Step_1_1.feature");
formatter.feature({
  "line": 2,
  "name": "CAPEC-112: Brute Force",
  "description": "",
  "id": "capec-112:-brute-force",
  "keyword": "Feature",
  "tags": [
    {
      "line": 1,
      "name": "@capec112"
    }
  ]
});
formatter.scenario({
  "comments": [
    {
      "line": 3,
      "value": "#1. Explore"
    }
  ],
  "line": 4,
  "name": "Step1.1 Determine secret testing procedure",
  "description": "",
  "id": "capec-112:-brute-force;step1.1-determine-secret-testing-procedure",
  "type": "scenario",
  "keyword": "Scenario"
});
formatter.step({
  "line": 5,
  "name": "prepare to Determine secret testing procedure",
  "keyword": "Given "
});
formatter.step({
  "line": 6,
  "name": "Try to Determine secret testing procedure",
  "keyword": "When "
});
formatter.step({
  "comments": [
    {
      "line": 7,
      "value": "# assertion for attack step success"
    }
  ],
  "line": 8,
  "name": "Assert the success of Determine secret testing procedure",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 9,
      "value": "#assertions for security pattern testing (checker whether the pattern consequences are observed)"
    }
  ],
  "line": 10,
  "name": "assert the consequences of the pattern",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 11,
      "value": "#"
    }
  ],
  "line": 12,
  "name": "assert the consequences of the pattern audit interceptor",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 13,
      "value": "# depends secure logger"
    }
  ],
  "line": 14,
  "name": "assert the consequences of the pattern secure logger",
  "keyword": "Then "
});
formatter.match({
  "location": "determinesecrettestingprocedure.predeterminesecrettestingprocedure()"
});
formatter.result({
  "duration": 82420,
  "status": "passed"
});
formatter.match({
  "location": "determinesecrettestingprocedure.trydeterminesecrettestingprocedure()"
});
formatter.result({
  "duration": 14107,
  "status": "passed"
});
formatter.match({
  "location": "determinesecrettestingprocedure.assdeterminesecrettestingprocedure()"
});
formatter.result({
  "duration": 15224,
  "status": "passed"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({
  "location": "PatternSteps.assauditinterceptor()"
});
formatter.result({
  "status": "skipped"
});
formatter.match({
  "location": "PatternSteps.asssecurelogger()"
});
formatter.result({
  "status": "skipped"
});
formatter.uri("CAPEC_112_Step_1_2.feature");
formatter.feature({
  "line": 2,
  "name": "CAPEC-112: Brute Force",
  "description": "",
  "id": "capec-112:-brute-force",
  "keyword": "Feature",
  "tags": [
    {
      "line": 1,
      "name": "@capec112"
    }
  ]
});
formatter.scenario({
  "comments": [
    {
      "line": 3,
      "value": "#1. Explore"
    }
  ],
  "line": 4,
  "name": "Step1.2 Reduce search space",
  "description": "",
  "id": "capec-112:-brute-force;step1.2-reduce-search-space",
  "type": "scenario",
  "keyword": "Scenario"
});
formatter.step({
  "line": 5,
  "name": "prepare to Reduce search space",
  "keyword": "Given "
});
formatter.step({
  "line": 6,
  "name": "Try to Reduce search space",
  "keyword": "When "
});
formatter.step({
  "comments": [
    {
      "line": 7,
      "value": "# assertion for attack step success"
    }
  ],
  "line": 8,
  "name": "Assert the success of Reduce search space",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 9,
      "value": "#assertions for security pattern testing (checker whether the pattern consequences are observed)"
    }
  ],
  "line": 10,
  "name": "assert the consequences of the pattern",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 11,
      "value": "#"
    }
  ],
  "line": 12,
  "name": "assert the consequences of the pattern audit interceptor",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 13,
      "value": "# depends secure logger"
    }
  ],
  "line": 14,
  "name": "assert the consequences of the pattern secure logger",
  "keyword": "Then "
});
formatter.match({
  "location": "reducesearchspace.prereducesearchspace()"
});
formatter.result({
  "duration": 77449,
  "status": "passed"
});
formatter.match({
  "location": "reducesearchspace.tryreducesearchspace()"
});
formatter.result({
  "duration": 16360,
  "status": "passed"
});
formatter.match({
  "location": "reducesearchspace.assreducesearchspace()"
});
formatter.result({
  "duration": 27236,
  "status": "passed"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({
  "location": "PatternSteps.assauditinterceptor()"
});
formatter.result({
  "status": "skipped"
});
formatter.match({
  "location": "PatternSteps.asssecurelogger()"
});
formatter.result({
  "status": "skipped"
});
formatter.uri("CAPEC_112_Step_1_3.feature");
formatter.feature({
  "line": 2,
  "name": "CAPEC-112: Brute Force",
  "description": "",
  "id": "capec-112:-brute-force",
  "keyword": "Feature",
  "tags": [
    {
      "line": 1,
      "name": "@capec112"
    }
  ]
});
formatter.scenario({
  "comments": [
    {
      "line": 3,
      "value": "#1. Explore"
    }
  ],
  "line": 4,
  "name": "Step1.3 Expand victory conditions",
  "description": "",
  "id": "capec-112:-brute-force;step1.3-expand-victory-conditions",
  "type": "scenario",
  "keyword": "Scenario"
});
formatter.step({
  "line": 5,
  "name": "prepare to Expand victory conditions",
  "keyword": "Given "
});
formatter.step({
  "line": 6,
  "name": "Try to Expand victory conditions",
  "keyword": "When "
});
formatter.step({
  "comments": [
    {
      "line": 7,
      "value": "# assertion for attack step success"
    }
  ],
  "line": 8,
  "name": "Assert the success of Expand victory conditions",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 9,
      "value": "#assertions for security pattern testing (checker whether the pattern consequences are observed)"
    }
  ],
  "line": 10,
  "name": "assert the consequences of the pattern",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 11,
      "value": "#"
    }
  ],
  "line": 12,
  "name": "assert the consequences of the pattern audit interceptor",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 13,
      "value": "# depends secure logger"
    }
  ],
  "line": 14,
  "name": "assert the consequences of the pattern secure logger",
  "keyword": "Then "
});
formatter.match({
  "location": "expandvictoryconditions.preexpandvictoryconditions()"
});
formatter.result({
  "duration": 105767,
  "status": "passed"
});
formatter.match({
  "location": "expandvictoryconditions.tryexpandvictoryconditions()"
});
formatter.result({
  "duration": 33612,
  "status": "passed"
});
formatter.match({
  "location": "expandvictoryconditions.assexpandvictoryconditions()"
});
formatter.result({
  "duration": 18646,
  "status": "passed"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({
  "location": "PatternSteps.assauditinterceptor()"
});
formatter.result({
  "status": "skipped"
});
formatter.match({
  "location": "PatternSteps.asssecurelogger()"
});
formatter.result({
  "status": "skipped"
});
formatter.uri("CAPEC_112_Step_2_1.feature");
formatter.feature({
  "line": 2,
  "name": "CAPEC-112: Brute Force",
  "description": "",
  "id": "capec-112:-brute-force",
  "keyword": "Feature",
  "tags": [
    {
      "line": 1,
      "name": "@capec112"
    }
  ]
});
formatter.scenario({
  "comments": [
    {
      "line": 3,
      "value": "#2. Exploit"
    }
  ],
  "line": 4,
  "name": "Step2.1 Gather information so attack can be performed independently.",
  "description": "",
  "id": "capec-112:-brute-force;step2.1-gather-information-so-attack-can-be-performed-independently.",
  "type": "scenario",
  "keyword": "Scenario"
});
formatter.step({
  "line": 5,
  "name": "prepare to Gather information so attack can be performed independently.",
  "keyword": "Given "
});
formatter.step({
  "line": 6,
  "name": "Try to Gather information so attack can be performed independently.",
  "keyword": "When "
});
formatter.step({
  "comments": [
    {
      "line": 7,
      "value": "# assertion for attack step success"
    }
  ],
  "line": 8,
  "name": "Assert the success of Gather information so attack can be performed independently.",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 9,
      "value": "#assertions for security pattern testing (checker whether the pattern consequences are observed)"
    }
  ],
  "line": 10,
  "name": "assert the consequences of the pattern",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 11,
      "value": "#"
    }
  ],
  "line": 12,
  "name": "assert the consequences of the pattern audit interceptor",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 13,
      "value": "# depends secure logger"
    }
  ],
  "line": 14,
  "name": "assert the consequences of the pattern secure logger",
  "keyword": "Then "
});
formatter.match({
  "location": "gatherinformationsoattackcanbeperformedindependently.pregatherinformationsoattackcanbeperformedindependently()"
});
formatter.result({
  "duration": 87647,
  "status": "passed"
});
formatter.match({
  "location": "gatherinformationsoattackcanbeperformedindependently.trygatherinformationsoattackcanbeperformedindependently()"
});
formatter.result({
  "duration": 23196,
  "status": "passed"
});
formatter.match({
  "location": "gatherinformationsoattackcanbeperformedindependently.assgatherinformationsoattackcanbeperformedindependently()"
});
formatter.result({
  "duration": 15935,
  "status": "passed"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({
  "location": "PatternSteps.assauditinterceptor()"
});
formatter.result({
  "status": "skipped"
});
formatter.match({
  "location": "PatternSteps.asssecurelogger()"
});
formatter.result({
  "status": "skipped"
});
formatter.uri("CAPEC_11_Step_1_1.feature");
formatter.feature({
  "line": 2,
  "name": "CAPEC-11: Cause Web Server Misclassification",
  "description": "",
  "id": "capec-11:-cause-web-server-misclassification",
  "keyword": "Feature",
  "tags": [
    {
      "line": 1,
      "name": "@capec11"
    }
  ]
});
formatter.scenario({
  "comments": [
    {
      "line": 3,
      "value": "#1. Explore"
    }
  ],
  "line": 4,
  "name": "Step1.1 Footprint file input vectors",
  "description": "",
  "id": "capec-11:-cause-web-server-misclassification;step1.1-footprint-file-input-vectors",
  "type": "scenario",
  "keyword": "Scenario"
});
formatter.step({
  "line": 5,
  "name": "prepare to Footprint file input vectors",
  "keyword": "Given "
});
formatter.step({
  "line": 6,
  "name": "Try to Footprint file input vectors",
  "keyword": "When "
});
formatter.step({
  "comments": [
    {
      "line": 7,
      "value": "# assertion for attack step success"
    }
  ],
  "line": 8,
  "name": "Assert the success of Footprint file input vectors",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 9,
      "value": "#assertions for security pattern testing (checker whether the pattern consequences are observed)"
    }
  ],
  "line": 10,
  "name": "assert the consequences of the pattern",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 11,
      "value": "#"
    }
  ],
  "line": 12,
  "name": "assert the consequences of the pattern audit interceptor",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 13,
      "value": "# depends secure logger"
    }
  ],
  "line": 14,
  "name": "assert the consequences of the pattern secure logger",
  "keyword": "Then "
});
formatter.match({
  "location": "footprintfileinputvectors.prefootprintfileinputvectors()"
});
formatter.result({
  "duration": 60546,
  "status": "passed"
});
formatter.match({
  "location": "footprintfileinputvectors.tryfootprintfileinputvectors()"
});
formatter.result({
  "duration": 26927,
  "status": "passed"
});
formatter.match({
  "location": "footprintfileinputvectors.assfootprintfileinputvectors()"
});
formatter.result({
  "duration": 23857,
  "status": "passed"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({
  "location": "PatternSteps.assauditinterceptor()"
});
formatter.result({
  "status": "skipped"
});
formatter.match({
  "location": "PatternSteps.asssecurelogger()"
});
formatter.result({
  "status": "skipped"
});
formatter.uri("CAPEC_11_Step_2_1.feature");
formatter.feature({
  "line": 2,
  "name": "CAPEC-11: Cause Web Server Misclassification",
  "description": "",
  "id": "capec-11:-cause-web-server-misclassification",
  "keyword": "Feature",
  "tags": [
    {
      "line": 1,
      "name": "@capec11"
    }
  ]
});
formatter.scenario({
  "comments": [
    {
      "line": 3,
      "value": "#2. Experiment"
    }
  ],
  "line": 4,
  "name": "Step2.1 File misclassification shotgunning",
  "description": "",
  "id": "capec-11:-cause-web-server-misclassification;step2.1-file-misclassification-shotgunning",
  "type": "scenario",
  "keyword": "Scenario"
});
formatter.step({
  "line": 5,
  "name": "prepare to File misclassification shotgunning",
  "keyword": "Given "
});
formatter.step({
  "line": 6,
  "name": "Try to File misclassification shotgunning",
  "keyword": "When "
});
formatter.step({
  "comments": [
    {
      "line": 7,
      "value": "# assertion for attack step success"
    }
  ],
  "line": 8,
  "name": "Assert the success of File misclassification shotgunning",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 9,
      "value": "#assertions for security pattern testing (checker whether the pattern consequences are observed)"
    }
  ],
  "line": 10,
  "name": "assert the consequences of the pattern audit interceptor",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 11,
      "value": "# depends secure logger"
    }
  ],
  "line": 12,
  "name": "assert the consequences of the pattern secure logger",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 13,
      "value": "# benifits audit interceptor"
    }
  ],
  "line": 14,
  "name": "assert the consequences of the pattern application firewall",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 15,
      "value": "# alternative input guard"
    }
  ],
  "line": 16,
  "name": "assert the consequences of the pattern input guard",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 17,
      "value": "# alternative application firewall"
    }
  ],
  "line": 18,
  "name": "assert the consequences of the pattern pathname canonicalization",
  "keyword": "Then "
});
formatter.match({
  "location": "filemisclassificationshotgunning.prefilemisclassificationshotgunning()"
});
formatter.result({
  "duration": 91360,
  "status": "passed"
});
formatter.match({
  "location": "filemisclassificationshotgunning.tryfilemisclassificationshotgunning()"
});
formatter.result({
  "duration": 19286,
  "status": "passed"
});
formatter.match({
  "location": "filemisclassificationshotgunning.assfilemisclassificationshotgunning()"
});
formatter.result({
  "duration": 16031,
  "status": "passed"
});
formatter.match({
  "location": "PatternSteps.assauditinterceptor()"
});
formatter.result({
  "duration": 34005,
  "status": "passed"
});
formatter.match({
  "location": "PatternSteps.asssecurelogger()"
});
formatter.result({
  "duration": 51157,
  "status": "passed"
});
formatter.match({
  "location": "PatternSteps.assapplicationfirewall()"
});
formatter.result({
  "duration": 10824,
  "status": "passed"
});
formatter.match({
  "location": "PatternSteps.assinputguard()"
});
formatter.result({
  "duration": 10516,
  "status": "passed"
});
formatter.match({
  "location": "PatternSteps.asspathnamecanonicalization()"
});
formatter.result({
  "duration": 17453,
  "status": "passed"
});
formatter.uri("CAPEC_11_Step_2_2.feature");
formatter.feature({
  "line": 2,
  "name": "CAPEC-11: Cause Web Server Misclassification",
  "description": "",
  "id": "capec-11:-cause-web-server-misclassification",
  "keyword": "Feature",
  "tags": [
    {
      "line": 1,
      "name": "@capec11"
    }
  ]
});
formatter.scenario({
  "comments": [
    {
      "line": 3,
      "value": "#2. Experiment"
    }
  ],
  "line": 4,
  "name": "Step2.2 File misclassification sniping",
  "description": "",
  "id": "capec-11:-cause-web-server-misclassification;step2.2-file-misclassification-sniping",
  "type": "scenario",
  "keyword": "Scenario"
});
formatter.step({
  "line": 5,
  "name": "prepare to File misclassification sniping",
  "keyword": "Given "
});
formatter.step({
  "line": 6,
  "name": "Try to File misclassification sniping",
  "keyword": "When "
});
formatter.step({
  "comments": [
    {
      "line": 7,
      "value": "# assertion for attack step success"
    }
  ],
  "line": 8,
  "name": "Assert the success of File misclassification sniping",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 9,
      "value": "#assertions for security pattern testing (checker whether the pattern consequences are observed)"
    }
  ],
  "line": 10,
  "name": "assert the consequences of the pattern audit interceptor",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 11,
      "value": "# depends secure logger"
    }
  ],
  "line": 12,
  "name": "assert the consequences of the pattern secure logger",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 13,
      "value": "# benifits audit interceptor"
    }
  ],
  "line": 14,
  "name": "assert the consequences of the pattern application firewall",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 15,
      "value": "# alternative input guard"
    }
  ],
  "line": 16,
  "name": "assert the consequences of the pattern input guard",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 17,
      "value": "# alternative application firewall"
    }
  ],
  "line": 18,
  "name": "assert the consequences of the pattern pathname canonicalization",
  "keyword": "Then "
});
formatter.match({
  "location": "filemisclassificationsniping.prefilemisclassificationsniping()"
});
formatter.result({
  "duration": 84163,
  "status": "passed"
});
formatter.match({
  "location": "filemisclassificationsniping.tryfilemisclassificationsniping()"
});
formatter.result({
  "duration": 19584,
  "status": "passed"
});
formatter.match({
  "location": "filemisclassificationsniping.assfilemisclassificationsniping()"
});
formatter.result({
  "duration": 38052,
  "status": "passed"
});
formatter.match({
  "location": "PatternSteps.assauditinterceptor()"
});
formatter.result({
  "duration": 39664,
  "status": "passed"
});
formatter.match({
  "location": "PatternSteps.asssecurelogger()"
});
formatter.result({
  "duration": 18381,
  "status": "passed"
});
formatter.match({
  "location": "PatternSteps.assapplicationfirewall()"
});
formatter.result({
  "duration": 23155,
  "status": "passed"
});
formatter.match({
  "location": "PatternSteps.assinputguard()"
});
formatter.result({
  "duration": 26740,
  "status": "passed"
});
formatter.match({
  "location": "PatternSteps.asspathnamecanonicalization()"
});
formatter.result({
  "duration": 22986,
  "status": "passed"
});
formatter.uri("CAPEC_11_Step_3_1.feature");
formatter.feature({
  "line": 2,
  "name": "CAPEC-11: Cause Web Server Misclassification",
  "description": "",
  "id": "capec-11:-cause-web-server-misclassification",
  "keyword": "Feature",
  "tags": [
    {
      "line": 1,
      "name": "@capec11"
    }
  ]
});
formatter.scenario({
  "comments": [
    {
      "line": 3,
      "value": "#3. Exploit"
    }
  ],
  "line": 4,
  "name": "Step3.1 Disclose information",
  "description": "",
  "id": "capec-11:-cause-web-server-misclassification;step3.1-disclose-information",
  "type": "scenario",
  "keyword": "Scenario"
});
formatter.step({
  "line": 5,
  "name": "prepare to Disclose information",
  "keyword": "Given "
});
formatter.step({
  "line": 6,
  "name": "Try to Disclose information",
  "keyword": "When "
});
formatter.step({
  "comments": [
    {
      "line": 7,
      "value": "# assertion for attack step success"
    }
  ],
  "line": 8,
  "name": "Assert the success of Disclose information",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 9,
      "value": "#assertions for security pattern testing (checker whether the pattern consequences are observed)"
    }
  ],
  "line": 10,
  "name": "assert the consequences of the pattern application firewall",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 11,
      "value": "# alternative input guard"
    }
  ],
  "line": 12,
  "name": "assert the consequences of the pattern input guard",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 13,
      "value": "# alternative application firewall"
    }
  ],
  "line": 14,
  "name": "assert the consequences of the pattern pathname canonicalization",
  "keyword": "Then "
});
formatter.match({
  "location": "discloseinformation.prediscloseinformation()"
});
formatter.result({
  "duration": 87879,
  "status": "passed"
});
formatter.match({
  "location": "discloseinformation.trydiscloseinformation()"
});
formatter.result({
  "duration": 16575,
  "status": "passed"
});
formatter.match({
  "location": "discloseinformation.assdiscloseinformation()"
});
formatter.result({
  "duration": 14428,
  "status": "passed"
});
formatter.match({
  "location": "PatternSteps.assapplicationfirewall()"
});
formatter.result({
  "duration": 32982,
  "status": "passed"
});
formatter.match({
  "location": "PatternSteps.assinputguard()"
});
formatter.result({
  "duration": 13542,
  "status": "passed"
});
formatter.match({
  "location": "PatternSteps.asspathnamecanonicalization()"
});
formatter.result({
  "duration": 13833,
  "status": "passed"
});
formatter.uri("CAPEC_120_Step_1_1.feature");
formatter.feature({
  "line": 2,
  "name": "CAPEC-120: Double Encoding",
  "description": "",
  "id": "capec-120:-double-encoding",
  "keyword": "Feature",
  "tags": [
    {
      "line": 1,
      "name": "@capec120"
    }
  ]
});
formatter.scenario({
  "comments": [
    {
      "line": 3,
      "value": "#1. Experiment"
    }
  ],
  "line": 4,
  "name": "Step1.1",
  "description": "",
  "id": "capec-120:-double-encoding;step1.1",
  "type": "scenario",
  "keyword": "Scenario"
});
formatter.step({
  "line": 5,
  "name": "prepare to",
  "keyword": "Given "
});
formatter.step({
  "line": 6,
  "name": "Try to",
  "keyword": "When "
});
formatter.step({
  "comments": [
    {
      "line": 7,
      "value": "# assertion for attack step success"
    }
  ],
  "line": 8,
  "name": "Assert the success of",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 9,
      "value": "#assertions for security pattern testing (checker whether the pattern consequences are observed)"
    }
  ],
  "line": 10,
  "name": "assert the consequences of the pattern",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 11,
      "value": "#"
    }
  ],
  "line": 12,
  "name": "assert the consequences of the pattern audit interceptor",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 13,
      "value": "# depends secure logger"
    }
  ],
  "line": 14,
  "name": "assert the consequences of the pattern secure logger",
  "keyword": "Then "
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({
  "location": "PatternSteps.assauditinterceptor()"
});
formatter.result({
  "status": "skipped"
});
formatter.match({
  "location": "PatternSteps.asssecurelogger()"
});
formatter.result({
  "status": "skipped"
});
formatter.uri("CAPEC_127_Step_1_1.feature");
formatter.feature({
  "line": 2,
  "name": "CAPEC-127: Directory Indexing",
  "description": "",
  "id": "capec-127:-directory-indexing",
  "keyword": "Feature",
  "tags": [
    {
      "line": 1,
      "name": "@capec127"
    }
  ]
});
formatter.scenario({
  "comments": [
    {
      "line": 3,
      "value": "#1. Explore"
    }
  ],
  "line": 4,
  "name": "Step1.1 Directory Discovery",
  "description": "",
  "id": "capec-127:-directory-indexing;step1.1-directory-discovery",
  "type": "scenario",
  "keyword": "Scenario"
});
formatter.step({
  "line": 5,
  "name": "prepare to Directory Discovery",
  "keyword": "Given "
});
formatter.step({
  "line": 6,
  "name": "Try to Directory Discovery",
  "keyword": "When "
});
formatter.step({
  "comments": [
    {
      "line": 7,
      "value": "# assertion for attack step success"
    }
  ],
  "line": 8,
  "name": "Assert the success of Directory Discovery",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 9,
      "value": "#assertions for security pattern testing (checker whether the pattern consequences are observed)"
    }
  ],
  "line": 10,
  "name": "assert the consequences of the pattern",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 11,
      "value": "#"
    }
  ],
  "line": 12,
  "name": "assert the consequences of the pattern audit interceptor",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 13,
      "value": "# depends secure logger"
    }
  ],
  "line": 14,
  "name": "assert the consequences of the pattern secure logger",
  "keyword": "Then "
});
formatter.match({
  "location": "directorydiscovery.predirectorydiscovery()"
});
formatter.result({
  "duration": 82851,
  "status": "passed"
});
formatter.match({
  "location": "directorydiscovery.trydirectorydiscovery()"
});
formatter.result({
  "duration": 25572,
  "status": "passed"
});
formatter.match({
  "location": "directorydiscovery.assdirectorydiscovery()"
});
formatter.result({
  "duration": 13930,
  "status": "passed"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({
  "location": "PatternSteps.assauditinterceptor()"
});
formatter.result({
  "status": "skipped"
});
formatter.match({
  "location": "PatternSteps.asssecurelogger()"
});
formatter.result({
  "status": "skipped"
});
formatter.uri("CAPEC_127_Step_2_1.feature");
formatter.feature({
  "line": 2,
  "name": "CAPEC-127: Directory Indexing",
  "description": "",
  "id": "capec-127:-directory-indexing",
  "keyword": "Feature",
  "tags": [
    {
      "line": 1,
      "name": "@capec127"
    }
  ]
});
formatter.scenario({
  "comments": [
    {
      "line": 3,
      "value": "#2. Experiment"
    }
  ],
  "line": 4,
  "name": "Step2.1 Iteratively explore directory/file structures",
  "description": "",
  "id": "capec-127:-directory-indexing;step2.1-iteratively-explore-directory/file-structures",
  "type": "scenario",
  "keyword": "Scenario"
});
formatter.step({
  "line": 5,
  "name": "prepare to Iteratively explore directory/file structures",
  "keyword": "Given "
});
formatter.step({
  "line": 6,
  "name": "Try to Iteratively explore directory/file structures",
  "keyword": "When "
});
formatter.step({
  "comments": [
    {
      "line": 7,
      "value": "# assertion for attack step success"
    }
  ],
  "line": 8,
  "name": "Assert the success of Iteratively explore directory/file structures",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 9,
      "value": "#assertions for security pattern testing (checker whether the pattern consequences are observed)"
    }
  ],
  "line": 10,
  "name": "assert the consequences of the pattern",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 11,
      "value": "#"
    }
  ],
  "line": 12,
  "name": "assert the consequences of the pattern audit interceptor",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 13,
      "value": "# depends secure logger"
    }
  ],
  "line": 14,
  "name": "assert the consequences of the pattern secure logger",
  "keyword": "Then "
});
formatter.match({
  "location": "iterativelyexploredirectoryfilestructures.preiterativelyexploredirectoryfilestructures()"
});
formatter.result({
  "duration": 75339,
  "status": "passed"
});
formatter.match({
  "location": "iterativelyexploredirectoryfilestructures.tryiterativelyexploredirectoryfilestructures()"
});
formatter.result({
  "duration": 14558,
  "status": "passed"
});
formatter.match({
  "location": "iterativelyexploredirectoryfilestructures.assiterativelyexploredirectoryfilestructures()"
});
formatter.result({
  "duration": 11680,
  "status": "passed"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({
  "location": "PatternSteps.assauditinterceptor()"
});
formatter.result({
  "status": "skipped"
});
formatter.match({
  "location": "PatternSteps.asssecurelogger()"
});
formatter.result({
  "status": "skipped"
});
formatter.uri("CAPEC_127_Step_3_1.feature");
formatter.feature({
  "line": 2,
  "name": "CAPEC-127: Directory Indexing",
  "description": "",
  "id": "capec-127:-directory-indexing",
  "keyword": "Feature",
  "tags": [
    {
      "line": 1,
      "name": "@capec127"
    }
  ]
});
formatter.scenario({
  "comments": [
    {
      "line": 3,
      "value": "#3. Exploit"
    }
  ],
  "line": 4,
  "name": "Step3.1 Read directories or files which are not intended for public viewing.",
  "description": "",
  "id": "capec-127:-directory-indexing;step3.1-read-directories-or-files-which-are-not-intended-for-public-viewing.",
  "type": "scenario",
  "keyword": "Scenario"
});
formatter.step({
  "line": 5,
  "name": "prepare to Read directories or files which are not intended for public viewing.",
  "keyword": "Given "
});
formatter.step({
  "line": 6,
  "name": "Try to Read directories or files which are not intended for public viewing.",
  "keyword": "When "
});
formatter.step({
  "comments": [
    {
      "line": 7,
      "value": "# assertion for attack step success"
    }
  ],
  "line": 8,
  "name": "Assert the success of Read directories or files which are not intended for public viewing.",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 9,
      "value": "#assertions for security pattern testing (checker whether the pattern consequences are observed)"
    }
  ],
  "line": 10,
  "name": "assert the consequences of the pattern audit interceptor",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 11,
      "value": "# depends secure logger"
    }
  ],
  "line": 12,
  "name": "assert the consequences of the pattern secure logger",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 13,
      "value": "# benifits audit interceptor"
    }
  ],
  "line": 14,
  "name": "assert the consequences of the pattern application firewall",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 15,
      "value": "# alternative input guard"
    }
  ],
  "line": 16,
  "name": "assert the consequences of the pattern input guard",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 17,
      "value": "# alternative application firewall"
    }
  ],
  "line": 18,
  "name": "assert the consequences of the pattern",
  "keyword": "Then "
});
formatter.match({
  "location": "readdirectoriesorfileswhicharenotintendedforpublicviewing.prereaddirectoriesorfileswhicharenotintendedforpublicviewing()"
});
formatter.result({
  "duration": 86019,
  "status": "passed"
});
formatter.match({
  "location": "readdirectoriesorfileswhicharenotintendedforpublicviewing.tryreaddirectoriesorfileswhicharenotintendedforpublicviewing()"
});
formatter.result({
  "duration": 20096,
  "status": "passed"
});
formatter.match({
  "location": "readdirectoriesorfileswhicharenotintendedforpublicviewing.assreaddirectoriesorfileswhicharenotintendedforpublicviewing()"
});
formatter.result({
  "duration": 20169,
  "status": "passed"
});
formatter.match({
  "location": "PatternSteps.assauditinterceptor()"
});
formatter.result({
  "duration": 60745,
  "status": "passed"
});
formatter.match({
  "location": "PatternSteps.asssecurelogger()"
});
formatter.result({
  "duration": 18424,
  "status": "passed"
});
formatter.match({
  "location": "PatternSteps.assapplicationfirewall()"
});
formatter.result({
  "duration": 15806,
  "status": "passed"
});
formatter.match({
  "location": "PatternSteps.assinputguard()"
});
formatter.result({
  "duration": 16272,
  "status": "passed"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.uri("CAPEC_12_Step_1_1.feature");
formatter.feature({
  "line": 2,
  "name": "CAPEC-12: Choosing Message Identifier",
  "description": "",
  "id": "capec-12:-choosing-message-identifier",
  "keyword": "Feature",
  "tags": [
    {
      "line": 1,
      "name": "@capec12"
    }
  ]
});
formatter.scenario({
  "comments": [
    {
      "line": 3,
      "value": "#1. Explore"
    }
  ],
  "line": 4,
  "name": "Step1.1",
  "description": "",
  "id": "capec-12:-choosing-message-identifier;step1.1",
  "type": "scenario",
  "keyword": "Scenario"
});
formatter.step({
  "line": 5,
  "name": "prepare to",
  "keyword": "Given "
});
formatter.step({
  "line": 6,
  "name": "Try to",
  "keyword": "When "
});
formatter.step({
  "comments": [
    {
      "line": 7,
      "value": "# assertion for attack step success"
    }
  ],
  "line": 8,
  "name": "Assert the success of",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 9,
      "value": "#assertions for security pattern testing (checker whether the pattern consequences are observed)"
    }
  ],
  "line": 10,
  "name": "assert the consequences of the pattern",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 11,
      "value": "#"
    }
  ],
  "line": 12,
  "name": "assert the consequences of the pattern audit interceptor",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 13,
      "value": "# depends secure logger"
    }
  ],
  "line": 14,
  "name": "assert the consequences of the pattern secure logger",
  "keyword": "Then "
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({
  "location": "PatternSteps.assauditinterceptor()"
});
formatter.result({
  "status": "skipped"
});
formatter.match({
  "location": "PatternSteps.asssecurelogger()"
});
formatter.result({
  "status": "skipped"
});
formatter.uri("CAPEC_12_Step_2_1.feature");
formatter.feature({
  "line": 2,
  "name": "CAPEC-12: Choosing Message Identifier",
  "description": "",
  "id": "capec-12:-choosing-message-identifier",
  "keyword": "Feature",
  "tags": [
    {
      "line": 1,
      "name": "@capec12"
    }
  ]
});
formatter.scenario({
  "comments": [
    {
      "line": 3,
      "value": "#2. Experiment"
    }
  ],
  "line": 4,
  "name": "Step2.1",
  "description": "",
  "id": "capec-12:-choosing-message-identifier;step2.1",
  "type": "scenario",
  "keyword": "Scenario"
});
formatter.step({
  "line": 5,
  "name": "prepare to",
  "keyword": "Given "
});
formatter.step({
  "line": 6,
  "name": "Try to",
  "keyword": "When "
});
formatter.step({
  "comments": [
    {
      "line": 7,
      "value": "# assertion for attack step success"
    }
  ],
  "line": 8,
  "name": "Assert the success of",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 9,
      "value": "#assertions for security pattern testing (checker whether the pattern consequences are observed)"
    }
  ],
  "line": 10,
  "name": "assert the consequences of the pattern",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 11,
      "value": "#"
    }
  ],
  "line": 12,
  "name": "assert the consequences of the pattern audit interceptor",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 13,
      "value": "# depends secure logger"
    }
  ],
  "line": 14,
  "name": "assert the consequences of the pattern secure logger",
  "keyword": "Then "
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({
  "location": "PatternSteps.assauditinterceptor()"
});
formatter.result({
  "status": "skipped"
});
formatter.match({
  "location": "PatternSteps.asssecurelogger()"
});
formatter.result({
  "status": "skipped"
});
formatter.uri("CAPEC_132_Step_1_1.feature");
formatter.feature({
  "line": 2,
  "name": "CAPEC-132: Symlink Attack",
  "description": "",
  "id": "capec-132:-symlink-attack",
  "keyword": "Feature",
  "tags": [
    {
      "line": 1,
      "name": "@capec132"
    }
  ]
});
formatter.scenario({
  "comments": [
    {
      "line": 3,
      "value": "#1. Explore"
    }
  ],
  "line": 4,
  "name": "Step1.1 Identify Target",
  "description": "",
  "id": "capec-132:-symlink-attack;step1.1-identify-target",
  "type": "scenario",
  "keyword": "Scenario"
});
formatter.step({
  "line": 5,
  "name": "prepare to Identify Target",
  "keyword": "Given "
});
formatter.step({
  "line": 6,
  "name": "Try to Identify Target",
  "keyword": "When "
});
formatter.step({
  "comments": [
    {
      "line": 7,
      "value": "# assertion for attack step success"
    }
  ],
  "line": 8,
  "name": "Assert the success of Identify Target",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 9,
      "value": "#assertions for security pattern testing (checker whether the pattern consequences are observed)"
    }
  ],
  "line": 10,
  "name": "assert the consequences of the pattern secure logger",
  "keyword": "Then "
});
formatter.match({
  "location": "identifytarget.preidentifytarget()"
});
formatter.result({
  "duration": 78468,
  "status": "passed"
});
formatter.match({
  "location": "identifytarget.tryidentifytarget()"
});
formatter.result({
  "duration": 10983,
  "status": "passed"
});
formatter.match({
  "location": "identifytarget.assidentifytarget()"
});
formatter.result({
  "duration": 9912,
  "status": "passed"
});
formatter.match({
  "location": "PatternSteps.asssecurelogger()"
});
formatter.result({
  "duration": 20670,
  "status": "passed"
});
formatter.uri("CAPEC_132_Step_2_1.feature");
formatter.feature({
  "line": 2,
  "name": "CAPEC-132: Symlink Attack",
  "description": "",
  "id": "capec-132:-symlink-attack",
  "keyword": "Feature",
  "tags": [
    {
      "line": 1,
      "name": "@capec132"
    }
  ]
});
formatter.scenario({
  "comments": [
    {
      "line": 3,
      "value": "#2. Experiment"
    }
  ],
  "line": 4,
  "name": "Step2.1 Try to create symlinks to different files",
  "description": "",
  "id": "capec-132:-symlink-attack;step2.1-try-to-create-symlinks-to-different-files",
  "type": "scenario",
  "keyword": "Scenario"
});
formatter.step({
  "line": 5,
  "name": "prepare to Try to create symlinks to different files",
  "keyword": "Given "
});
formatter.step({
  "line": 6,
  "name": "Try to Try to create symlinks to different files",
  "keyword": "When "
});
formatter.step({
  "comments": [
    {
      "line": 7,
      "value": "# assertion for attack step success"
    }
  ],
  "line": 8,
  "name": "Assert the success of Try to create symlinks to different files",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 9,
      "value": "#assertions for security pattern testing (checker whether the pattern consequences are observed)"
    }
  ],
  "line": 10,
  "name": "assert the consequences of the pattern secure logger",
  "keyword": "Then "
});
formatter.match({
  "location": "trytocreatesymlinkstodifferentfiles.pretrytocreatesymlinkstodifferentfiles()"
});
formatter.result({
  "duration": 125933,
  "status": "passed"
});
formatter.match({
  "location": "trytocreatesymlinkstodifferentfiles.trytrytocreatesymlinkstodifferentfiles()"
});
formatter.result({
  "duration": 12188,
  "status": "passed"
});
formatter.match({
  "location": "trytocreatesymlinkstodifferentfiles.asstrytocreatesymlinkstodifferentfiles()"
});
formatter.result({
  "duration": 10932,
  "status": "passed"
});
formatter.match({
  "location": "PatternSteps.asssecurelogger()"
});
formatter.result({
  "duration": 38709,
  "status": "passed"
});
formatter.uri("CAPEC_132_Step_3_1.feature");
formatter.feature({
  "line": 2,
  "name": "CAPEC-132: Symlink Attack",
  "description": "",
  "id": "capec-132:-symlink-attack",
  "keyword": "Feature",
  "tags": [
    {
      "line": 1,
      "name": "@capec132"
    }
  ]
});
formatter.scenario({
  "comments": [
    {
      "line": 3,
      "value": "#3. Exploit"
    }
  ],
  "line": 4,
  "name": "Step3.1 Target application operates on created symlinks to sensitive files",
  "description": "",
  "id": "capec-132:-symlink-attack;step3.1-target-application-operates-on-created-symlinks-to-sensitive-files",
  "type": "scenario",
  "keyword": "Scenario"
});
formatter.step({
  "line": 5,
  "name": "prepare to Target application operates on created symlinks to sensitive files",
  "keyword": "Given "
});
formatter.step({
  "line": 6,
  "name": "Try to Target application operates on created symlinks to sensitive files",
  "keyword": "When "
});
formatter.step({
  "comments": [
    {
      "line": 7,
      "value": "# assertion for attack step success"
    }
  ],
  "line": 8,
  "name": "Assert the success of Target application operates on created symlinks to sensitive files",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 9,
      "value": "#assertions for security pattern testing (checker whether the pattern consequences are observed)"
    }
  ],
  "line": 10,
  "name": "assert the consequences of the pattern secure logger",
  "keyword": "Then "
});
formatter.match({
  "location": "targetapplicationoperatesoncreatedsymlinkstosensitivefiles.pretargetapplicationoperatesoncreatedsymlinkstosensitivefiles()"
});
formatter.result({
  "duration": 71050,
  "status": "passed"
});
formatter.match({
  "location": "targetapplicationoperatesoncreatedsymlinkstosensitivefiles.trytargetapplicationoperatesoncreatedsymlinkstosensitivefiles()"
});
formatter.result({
  "duration": 16945,
  "status": "passed"
});
formatter.match({
  "location": "targetapplicationoperatesoncreatedsymlinkstosensitivefiles.asstargetapplicationoperatesoncreatedsymlinkstosensitivefiles()"
});
formatter.result({
  "duration": 12091,
  "status": "passed"
});
formatter.match({
  "location": "PatternSteps.asssecurelogger()"
});
formatter.result({
  "duration": 25102,
  "status": "passed"
});
formatter.uri("CAPEC_135_Step_1_1.feature");
formatter.feature({
  "line": 2,
  "name": "CAPEC-135: Format String Injection",
  "description": "",
  "id": "capec-135:-format-string-injection",
  "keyword": "Feature",
  "tags": [
    {
      "line": 1,
      "name": "@capec135"
    }
  ]
});
formatter.scenario({
  "comments": [
    {
      "line": 3,
      "value": "#1. Explore"
    }
  ],
  "line": 4,
  "name": "Step1.1 Survey application",
  "description": "",
  "id": "capec-135:-format-string-injection;step1.1-survey-application",
  "type": "scenario",
  "keyword": "Scenario"
});
formatter.step({
  "line": 5,
  "name": "prepare to Survey application",
  "keyword": "Given "
});
formatter.step({
  "line": 6,
  "name": "Try to Survey application",
  "keyword": "When "
});
formatter.step({
  "comments": [
    {
      "line": 7,
      "value": "# assertion for attack step success"
    }
  ],
  "line": 8,
  "name": "Assert the success of Survey application",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 9,
      "value": "#assertions for security pattern testing (checker whether the pattern consequences are observed)"
    }
  ],
  "line": 10,
  "name": "assert the consequences of the pattern",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 11,
      "value": "#"
    }
  ],
  "line": 12,
  "name": "assert the consequences of the pattern audit interceptor",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 13,
      "value": "# depends secure logger"
    }
  ],
  "line": 14,
  "name": "assert the consequences of the pattern secure logger",
  "keyword": "Then "
});
formatter.match({
  "location": "survey.presurvey()"
});
formatter.result({
  "duration": 0,
  "error_message": "cucumber.runtime.AmbiguousStepDefinitionsException: ✽.Given prepare to Survey application(CAPEC_135_Step_1_1.feature:5) matches more than one step definition:\n  prepare to Survey in survey.presurvey()\n  prepare to Survey application in surveyapplication.presurveyapplication()\n\n\tat cucumber.runtime.RuntimeGlue.stepDefinitionMatch(RuntimeGlue.java:71)\n\tat cucumber.runtime.Runtime.runStep(Runtime.java:265)\n\tat cucumber.runtime.model.StepContainer.runStep(StepContainer.java:44)\n\tat cucumber.runtime.model.StepContainer.runSteps(StepContainer.java:39)\n\tat cucumber.runtime.model.CucumberScenario.run(CucumberScenario.java:48)\n\tat cucumber.runtime.junit.ExecutionUnitRunner.run(ExecutionUnitRunner.java:91)\n\tat cucumber.runtime.junit.FeatureRunner.runChild(FeatureRunner.java:63)\n\tat cucumber.runtime.junit.FeatureRunner.runChild(FeatureRunner.java:18)\n\tat org.junit.runners.ParentRunner$3.run(ParentRunner.java:238)\n\tat org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:63)\n\tat org.junit.runners.ParentRunner.runChildren(ParentRunner.java:236)\n\tat org.junit.runners.ParentRunner.access$000(ParentRunner.java:53)\n\tat org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:229)\n\tat org.junit.runners.ParentRunner.run(ParentRunner.java:309)\n\tat cucumber.runtime.junit.FeatureRunner.run(FeatureRunner.java:70)\n\tat cucumber.api.junit.Cucumber.runChild(Cucumber.java:93)\n\tat cucumber.api.junit.Cucumber.runChild(Cucumber.java:37)\n\tat org.junit.runners.ParentRunner$3.run(ParentRunner.java:238)\n\tat org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:63)\n\tat org.junit.runners.ParentRunner.runChildren(ParentRunner.java:236)\n\tat org.junit.runners.ParentRunner.access$000(ParentRunner.java:53)\n\tat org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:229)\n\tat org.junit.internal.runners.statements.RunAfters.evaluate(RunAfters.java:27)\n\tat org.junit.runners.ParentRunner.run(ParentRunner.java:309)\n\tat cucumber.api.junit.Cucumber.run(Cucumber.java:98)\n\tat org.eclipse.jdt.internal.junit4.runner.JUnit4TestReference.run(JUnit4TestReference.java:86)\n\tat org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:459)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:678)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:382)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:192)\n",
  "status": "failed"
});
formatter.match({
  "location": "survey.trysurvey()"
});
formatter.result({
  "duration": 0,
  "error_message": "cucumber.runtime.AmbiguousStepDefinitionsException: ✽.When Try to Survey application(CAPEC_135_Step_1_1.feature:6) matches more than one step definition:\n  Try to Survey in survey.trysurvey()\n  Try to Survey application in surveyapplication.trysurveyapplication()\n\n\tat cucumber.runtime.RuntimeGlue.stepDefinitionMatch(RuntimeGlue.java:71)\n\tat cucumber.runtime.Runtime.runStep(Runtime.java:265)\n\tat cucumber.runtime.model.StepContainer.runStep(StepContainer.java:44)\n\tat cucumber.runtime.model.StepContainer.runSteps(StepContainer.java:39)\n\tat cucumber.runtime.model.CucumberScenario.run(CucumberScenario.java:48)\n\tat cucumber.runtime.junit.ExecutionUnitRunner.run(ExecutionUnitRunner.java:91)\n\tat cucumber.runtime.junit.FeatureRunner.runChild(FeatureRunner.java:63)\n\tat cucumber.runtime.junit.FeatureRunner.runChild(FeatureRunner.java:18)\n\tat org.junit.runners.ParentRunner$3.run(ParentRunner.java:238)\n\tat org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:63)\n\tat org.junit.runners.ParentRunner.runChildren(ParentRunner.java:236)\n\tat org.junit.runners.ParentRunner.access$000(ParentRunner.java:53)\n\tat org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:229)\n\tat org.junit.runners.ParentRunner.run(ParentRunner.java:309)\n\tat cucumber.runtime.junit.FeatureRunner.run(FeatureRunner.java:70)\n\tat cucumber.api.junit.Cucumber.runChild(Cucumber.java:93)\n\tat cucumber.api.junit.Cucumber.runChild(Cucumber.java:37)\n\tat org.junit.runners.ParentRunner$3.run(ParentRunner.java:238)\n\tat org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:63)\n\tat org.junit.runners.ParentRunner.runChildren(ParentRunner.java:236)\n\tat org.junit.runners.ParentRunner.access$000(ParentRunner.java:53)\n\tat org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:229)\n\tat org.junit.internal.runners.statements.RunAfters.evaluate(RunAfters.java:27)\n\tat org.junit.runners.ParentRunner.run(ParentRunner.java:309)\n\tat cucumber.api.junit.Cucumber.run(Cucumber.java:98)\n\tat org.eclipse.jdt.internal.junit4.runner.JUnit4TestReference.run(JUnit4TestReference.java:86)\n\tat org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:459)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:678)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:382)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:192)\n",
  "status": "failed"
});
formatter.match({
  "location": "survey.asssurvey()"
});
formatter.result({
  "duration": 0,
  "error_message": "cucumber.runtime.AmbiguousStepDefinitionsException: ✽.Then Assert the success of Survey application(CAPEC_135_Step_1_1.feature:8) matches more than one step definition:\n  Assert the success of Survey in survey.asssurvey()\n  Assert the success of Survey application in surveyapplication.asssurveyapplication()\n\n\tat cucumber.runtime.RuntimeGlue.stepDefinitionMatch(RuntimeGlue.java:71)\n\tat cucumber.runtime.Runtime.runStep(Runtime.java:265)\n\tat cucumber.runtime.model.StepContainer.runStep(StepContainer.java:44)\n\tat cucumber.runtime.model.StepContainer.runSteps(StepContainer.java:39)\n\tat cucumber.runtime.model.CucumberScenario.run(CucumberScenario.java:48)\n\tat cucumber.runtime.junit.ExecutionUnitRunner.run(ExecutionUnitRunner.java:91)\n\tat cucumber.runtime.junit.FeatureRunner.runChild(FeatureRunner.java:63)\n\tat cucumber.runtime.junit.FeatureRunner.runChild(FeatureRunner.java:18)\n\tat org.junit.runners.ParentRunner$3.run(ParentRunner.java:238)\n\tat org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:63)\n\tat org.junit.runners.ParentRunner.runChildren(ParentRunner.java:236)\n\tat org.junit.runners.ParentRunner.access$000(ParentRunner.java:53)\n\tat org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:229)\n\tat org.junit.runners.ParentRunner.run(ParentRunner.java:309)\n\tat cucumber.runtime.junit.FeatureRunner.run(FeatureRunner.java:70)\n\tat cucumber.api.junit.Cucumber.runChild(Cucumber.java:93)\n\tat cucumber.api.junit.Cucumber.runChild(Cucumber.java:37)\n\tat org.junit.runners.ParentRunner$3.run(ParentRunner.java:238)\n\tat org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:63)\n\tat org.junit.runners.ParentRunner.runChildren(ParentRunner.java:236)\n\tat org.junit.runners.ParentRunner.access$000(ParentRunner.java:53)\n\tat org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:229)\n\tat org.junit.internal.runners.statements.RunAfters.evaluate(RunAfters.java:27)\n\tat org.junit.runners.ParentRunner.run(ParentRunner.java:309)\n\tat cucumber.api.junit.Cucumber.run(Cucumber.java:98)\n\tat org.eclipse.jdt.internal.junit4.runner.JUnit4TestReference.run(JUnit4TestReference.java:86)\n\tat org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:459)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:678)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:382)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:192)\n",
  "status": "failed"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({
  "location": "PatternSteps.assauditinterceptor()"
});
formatter.result({
  "status": "skipped"
});
formatter.match({
  "location": "PatternSteps.asssecurelogger()"
});
formatter.result({
  "status": "skipped"
});
formatter.uri("CAPEC_135_Step_2_1.feature");
formatter.feature({
  "line": 2,
  "name": "CAPEC-135: Format String Injection",
  "description": "",
  "id": "capec-135:-format-string-injection",
  "keyword": "Feature",
  "tags": [
    {
      "line": 1,
      "name": "@capec135"
    }
  ]
});
formatter.scenario({
  "comments": [
    {
      "line": 3,
      "value": "#2. Experiment"
    }
  ],
  "line": 4,
  "name": "Step2.1 Determine user-controllable input susceptible to format string injection",
  "description": "",
  "id": "capec-135:-format-string-injection;step2.1-determine-user-controllable-input-susceptible-to-format-string-injection",
  "type": "scenario",
  "keyword": "Scenario"
});
formatter.step({
  "line": 5,
  "name": "prepare to Determine user-controllable input susceptible to format string injection",
  "keyword": "Given "
});
formatter.step({
  "line": 6,
  "name": "Try to Determine user-controllable input susceptible to format string injection",
  "keyword": "When "
});
formatter.step({
  "comments": [
    {
      "line": 7,
      "value": "# assertion for attack step success"
    }
  ],
  "line": 8,
  "name": "Assert the success of Determine user-controllable input susceptible to format string injection",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 9,
      "value": "#assertions for security pattern testing (checker whether the pattern consequences are observed)"
    }
  ],
  "line": 10,
  "name": "assert the consequences of the pattern secure logger",
  "keyword": "Then "
});
formatter.step({
  "line": 11,
  "name": "assert the consequences of the pattern application firewall",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 12,
      "value": "# alternative output guard"
    },
    {
      "line": 13,
      "value": "# alternative input guard"
    }
  ],
  "line": 14,
  "name": "assert the consequences of the pattern input guard",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 15,
      "value": "# alternative application firewall"
    },
    {
      "line": 16,
      "value": "# benifits output guard"
    }
  ],
  "line": 17,
  "name": "assert the consequences of the pattern pathname canonicalization",
  "keyword": "Then "
});
formatter.step({
  "line": 18,
  "name": "assert the consequences of the pattern output guard",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 19,
      "value": "# alternative application firewall"
    },
    {
      "line": 20,
      "value": "# benifits input guard"
    }
  ],
  "line": 21,
  "name": "assert the consequences of the pattern comparator checked fault tolerant system",
  "keyword": "Then "
});
formatter.match({
  "location": "determineusercontrollableinputsusceptibletoformatstringinjection.predetermineusercontrollableinputsusceptibletoformatstringinjection()"
});
formatter.result({
  "duration": 2374814,
  "error_message": "net.continuumsecurity.proxy.ProxyException: org.zaproxy.clientapi.core.ClientApiException: java.net.ConnectException: Connection refused\n\tat net.continuumsecurity.proxy.ZAProxyScanner.validateMinimumRequiredZapVersion(ZAProxyScanner.java:96)\n\tat net.continuumsecurity.proxy.ZAProxyScanner.\u003cinit\u003e(ZAProxyScanner.java:38)\n\tat steps.determineusercontrollableinputsusceptibletoformatstringinjection.predetermineusercontrollableinputsusceptibletoformatstringinjection(determineusercontrollableinputsusceptibletoformatstringinjection.java:17)\n\tat ✽.Given prepare to Determine user-controllable input susceptible to format string injection(CAPEC_135_Step_2_1.feature:5)\nCaused by: org.zaproxy.clientapi.core.ClientApiException: java.net.ConnectException: Connection refused\n\tat org.zaproxy.clientapi.core.ClientApi.callApiDom(ClientApi.java:307)\n\tat org.zaproxy.clientapi.core.ClientApi.callApi(ClientApi.java:289)\n\tat org.zaproxy.clientapi.gen.Core.version(Core.java:158)\n\tat net.continuumsecurity.proxy.ZAProxyScanner.validateMinimumRequiredZapVersion(ZAProxyScanner.java:85)\n\tat net.continuumsecurity.proxy.ZAProxyScanner.\u003cinit\u003e(ZAProxyScanner.java:38)\n\tat steps.determineusercontrollableinputsusceptibletoformatstringinjection.predetermineusercontrollableinputsusceptibletoformatstringinjection(determineusercontrollableinputsusceptibletoformatstringinjection.java:17)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.lang.reflect.Method.invoke(Method.java:498)\n\tat cucumber.runtime.Utils$1.call(Utils.java:37)\n\tat cucumber.runtime.Timeout.timeout(Timeout.java:13)\n\tat cucumber.runtime.Utils.invoke(Utils.java:31)\n\tat cucumber.runtime.java.JavaStepDefinition.execute(JavaStepDefinition.java:37)\n\tat cucumber.runtime.StepDefinitionMatch.runStep(StepDefinitionMatch.java:37)\n\tat cucumber.runtime.Runtime.runStep(Runtime.java:298)\n\tat cucumber.runtime.model.StepContainer.runStep(StepContainer.java:44)\n\tat cucumber.runtime.model.StepContainer.runSteps(StepContainer.java:39)\n\tat cucumber.runtime.model.CucumberScenario.run(CucumberScenario.java:48)\n\tat cucumber.runtime.junit.ExecutionUnitRunner.run(ExecutionUnitRunner.java:91)\n\tat cucumber.runtime.junit.FeatureRunner.runChild(FeatureRunner.java:63)\n\tat cucumber.runtime.junit.FeatureRunner.runChild(FeatureRunner.java:18)\n\tat org.junit.runners.ParentRunner$3.run(ParentRunner.java:238)\n\tat org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:63)\n\tat org.junit.runners.ParentRunner.runChildren(ParentRunner.java:236)\n\tat org.junit.runners.ParentRunner.access$000(ParentRunner.java:53)\n\tat org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:229)\n\tat org.junit.runners.ParentRunner.run(ParentRunner.java:309)\n\tat cucumber.runtime.junit.FeatureRunner.run(FeatureRunner.java:70)\n\tat cucumber.api.junit.Cucumber.runChild(Cucumber.java:93)\n\tat cucumber.api.junit.Cucumber.runChild(Cucumber.java:37)\n\tat org.junit.runners.ParentRunner$3.run(ParentRunner.java:238)\n\tat org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:63)\n\tat org.junit.runners.ParentRunner.runChildren(ParentRunner.java:236)\n\tat org.junit.runners.ParentRunner.access$000(ParentRunner.java:53)\n\tat org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:229)\n\tat org.junit.internal.runners.statements.RunAfters.evaluate(RunAfters.java:27)\n\tat org.junit.runners.ParentRunner.run(ParentRunner.java:309)\n\tat cucumber.api.junit.Cucumber.run(Cucumber.java:98)\n\tat org.eclipse.jdt.internal.junit4.runner.JUnit4TestReference.run(JUnit4TestReference.java:86)\n\tat org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:459)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:678)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:382)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:192)\nCaused by: java.net.ConnectException: Connection refused\n\tat java.net.PlainSocketImpl.socketConnect(Native Method)\n\tat java.net.AbstractPlainSocketImpl.doConnect(AbstractPlainSocketImpl.java:350)\n\tat java.net.AbstractPlainSocketImpl.connectToAddress(AbstractPlainSocketImpl.java:206)\n\tat java.net.AbstractPlainSocketImpl.connect(AbstractPlainSocketImpl.java:188)\n\tat java.net.Socket.connect(Socket.java:589)\n\tat java.net.Socket.connect(Socket.java:538)\n\tat sun.net.NetworkClient.doConnect(NetworkClient.java:180)\n\tat sun.net.www.http.HttpClient.openServer(HttpClient.java:432)\n\tat sun.net.www.http.HttpClient$1.run(HttpClient.java:484)\n\tat sun.net.www.http.HttpClient$1.run(HttpClient.java:482)\n\tat java.security.AccessController.doPrivileged(Native Method)\n\tat sun.net.www.http.HttpClient.privilegedOpenServer(HttpClient.java:481)\n\tat sun.net.www.http.HttpClient.openServer(HttpClient.java:522)\n\tat sun.net.www.http.HttpClient.\u003cinit\u003e(HttpClient.java:211)\n\tat sun.net.www.http.HttpClient.New(HttpClient.java:308)\n\tat sun.net.www.http.HttpClient.New(HttpClient.java:326)\n\tat sun.net.www.protocol.http.HttpURLConnection.getNewHttpClient(HttpURLConnection.java:1169)\n\tat sun.net.www.protocol.http.HttpURLConnection.plainConnect0(HttpURLConnection.java:1148)\n\tat sun.net.www.protocol.http.HttpURLConnection.plainConnect(HttpURLConnection.java:999)\n\tat sun.net.www.protocol.http.HttpURLConnection.connect(HttpURLConnection.java:933)\n\tat org.zaproxy.clientapi.core.ClientApi.getConnectionInputStream(ClientApi.java:313)\n\tat org.zaproxy.clientapi.core.ClientApi.callApiDom(ClientApi.java:305)\n\t... 44 more\n",
  "status": "failed"
});
formatter.match({
  "location": "determineusercontrollableinputsusceptibletoformatstringinjection.trydetermineusercontrollableinputsusceptibletoformatstringinjection()"
});
formatter.result({
  "status": "skipped"
});
formatter.match({
  "location": "determineusercontrollableinputsusceptibletoformatstringinjection.assdetermineusercontrollableinputsusceptibletoformatstringinjection()"
});
formatter.result({
  "status": "skipped"
});
formatter.match({
  "location": "PatternSteps.asssecurelogger()"
});
formatter.result({
  "status": "skipped"
});
formatter.match({
  "location": "PatternSteps.assapplicationfirewall()"
});
formatter.result({
  "status": "skipped"
});
formatter.match({
  "location": "PatternSteps.assinputguard()"
});
formatter.result({
  "status": "skipped"
});
formatter.match({
  "location": "PatternSteps.asspathnamecanonicalization()"
});
formatter.result({
  "status": "skipped"
});
formatter.match({
  "location": "PatternSteps.assoutputguard()"
});
formatter.result({
  "status": "skipped"
});
formatter.match({
  "location": "PatternSteps.asscomparatorcheckedfaulttolerantsystem()"
});
formatter.result({
  "status": "skipped"
});
formatter.uri("CAPEC_135_Step_3_1.feature");
formatter.feature({
  "line": 2,
  "name": "CAPEC-135: Format String Injection",
  "description": "",
  "id": "capec-135:-format-string-injection",
  "keyword": "Feature",
  "tags": [
    {
      "line": 1,
      "name": "@capec135"
    }
  ]
});
formatter.scenario({
  "comments": [
    {
      "line": 3,
      "value": "#3. Exploit"
    }
  ],
  "line": 4,
  "name": "Step3.1 Try to exploit the Format String Injection vulnerability",
  "description": "",
  "id": "capec-135:-format-string-injection;step3.1-try-to-exploit-the-format-string-injection-vulnerability",
  "type": "scenario",
  "keyword": "Scenario"
});
formatter.step({
  "line": 5,
  "name": "prepare to Try to exploit the Format String Injection vulnerability",
  "keyword": "Given "
});
formatter.step({
  "line": 6,
  "name": "Try to Try to exploit the Format String Injection vulnerability",
  "keyword": "When "
});
formatter.step({
  "comments": [
    {
      "line": 7,
      "value": "# assertion for attack step success"
    }
  ],
  "line": 8,
  "name": "Assert the success of Try to exploit the Format String Injection vulnerability",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 9,
      "value": "#assertions for security pattern testing (checker whether the pattern consequences are observed)"
    }
  ],
  "line": 10,
  "name": "assert the consequences of the pattern",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 11,
      "value": "#"
    }
  ],
  "line": 12,
  "name": "assert the consequences of the pattern audit interceptor",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 13,
      "value": "# depends secure logger"
    }
  ],
  "line": 14,
  "name": "assert the consequences of the pattern secure logger",
  "keyword": "Then "
});
formatter.match({
  "location": "trytoexploittheformatstringinjectionvulnerability.pretrytoexploittheformatstringinjectionvulnerability()"
});
formatter.result({
  "duration": 93634,
  "status": "passed"
});
formatter.match({
  "location": "trytoexploittheformatstringinjectionvulnerability.trytrytoexploittheformatstringinjectionvulnerability()"
});
formatter.result({
  "duration": 13232,
  "status": "passed"
});
formatter.match({
  "location": "trytoexploittheformatstringinjectionvulnerability.asstrytoexploittheformatstringinjectionvulnerability()"
});
formatter.result({
  "duration": 10853,
  "status": "passed"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({
  "location": "PatternSteps.assauditinterceptor()"
});
formatter.result({
  "status": "skipped"
});
formatter.match({
  "location": "PatternSteps.asssecurelogger()"
});
formatter.result({
  "status": "skipped"
});
formatter.uri("CAPEC_136_Step_1_1.feature");
formatter.feature({
  "line": 2,
  "name": "CAPEC-136: LDAP Injection",
  "description": "",
  "id": "capec-136:-ldap-injection",
  "keyword": "Feature",
  "tags": [
    {
      "line": 1,
      "name": "@capec136"
    }
  ]
});
formatter.scenario({
  "comments": [
    {
      "line": 3,
      "value": "#1. Explore"
    }
  ],
  "line": 4,
  "name": "Step1.1 Survey application",
  "description": "",
  "id": "capec-136:-ldap-injection;step1.1-survey-application",
  "type": "scenario",
  "keyword": "Scenario"
});
formatter.step({
  "line": 5,
  "name": "prepare to Survey application",
  "keyword": "Given "
});
formatter.step({
  "line": 6,
  "name": "Try to Survey application",
  "keyword": "When "
});
formatter.step({
  "comments": [
    {
      "line": 7,
      "value": "# assertion for attack step success"
    }
  ],
  "line": 8,
  "name": "Assert the success of Survey application",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 9,
      "value": "#assertions for security pattern testing (checker whether the pattern consequences are observed)"
    }
  ],
  "line": 10,
  "name": "assert the consequences of the pattern",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 11,
      "value": "#"
    }
  ],
  "line": 12,
  "name": "assert the consequences of the pattern audit interceptor",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 13,
      "value": "# depends secure logger"
    }
  ],
  "line": 14,
  "name": "assert the consequences of the pattern secure logger",
  "keyword": "Then "
});
formatter.match({
  "location": "survey.presurvey()"
});
formatter.result({
  "duration": 0,
  "error_message": "cucumber.runtime.AmbiguousStepDefinitionsException: ✽.Given prepare to Survey application(CAPEC_136_Step_1_1.feature:5) matches more than one step definition:\n  prepare to Survey in survey.presurvey()\n  prepare to Survey application in surveyapplication.presurveyapplication()\n\n\tat cucumber.runtime.RuntimeGlue.stepDefinitionMatch(RuntimeGlue.java:71)\n\tat cucumber.runtime.Runtime.runStep(Runtime.java:265)\n\tat cucumber.runtime.model.StepContainer.runStep(StepContainer.java:44)\n\tat cucumber.runtime.model.StepContainer.runSteps(StepContainer.java:39)\n\tat cucumber.runtime.model.CucumberScenario.run(CucumberScenario.java:48)\n\tat cucumber.runtime.junit.ExecutionUnitRunner.run(ExecutionUnitRunner.java:91)\n\tat cucumber.runtime.junit.FeatureRunner.runChild(FeatureRunner.java:63)\n\tat cucumber.runtime.junit.FeatureRunner.runChild(FeatureRunner.java:18)\n\tat org.junit.runners.ParentRunner$3.run(ParentRunner.java:238)\n\tat org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:63)\n\tat org.junit.runners.ParentRunner.runChildren(ParentRunner.java:236)\n\tat org.junit.runners.ParentRunner.access$000(ParentRunner.java:53)\n\tat org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:229)\n\tat org.junit.runners.ParentRunner.run(ParentRunner.java:309)\n\tat cucumber.runtime.junit.FeatureRunner.run(FeatureRunner.java:70)\n\tat cucumber.api.junit.Cucumber.runChild(Cucumber.java:93)\n\tat cucumber.api.junit.Cucumber.runChild(Cucumber.java:37)\n\tat org.junit.runners.ParentRunner$3.run(ParentRunner.java:238)\n\tat org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:63)\n\tat org.junit.runners.ParentRunner.runChildren(ParentRunner.java:236)\n\tat org.junit.runners.ParentRunner.access$000(ParentRunner.java:53)\n\tat org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:229)\n\tat org.junit.internal.runners.statements.RunAfters.evaluate(RunAfters.java:27)\n\tat org.junit.runners.ParentRunner.run(ParentRunner.java:309)\n\tat cucumber.api.junit.Cucumber.run(Cucumber.java:98)\n\tat org.eclipse.jdt.internal.junit4.runner.JUnit4TestReference.run(JUnit4TestReference.java:86)\n\tat org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:459)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:678)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:382)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:192)\n",
  "status": "failed"
});
formatter.match({
  "location": "survey.trysurvey()"
});
formatter.result({
  "duration": 0,
  "error_message": "cucumber.runtime.AmbiguousStepDefinitionsException: ✽.When Try to Survey application(CAPEC_136_Step_1_1.feature:6) matches more than one step definition:\n  Try to Survey in survey.trysurvey()\n  Try to Survey application in surveyapplication.trysurveyapplication()\n\n\tat cucumber.runtime.RuntimeGlue.stepDefinitionMatch(RuntimeGlue.java:71)\n\tat cucumber.runtime.Runtime.runStep(Runtime.java:265)\n\tat cucumber.runtime.model.StepContainer.runStep(StepContainer.java:44)\n\tat cucumber.runtime.model.StepContainer.runSteps(StepContainer.java:39)\n\tat cucumber.runtime.model.CucumberScenario.run(CucumberScenario.java:48)\n\tat cucumber.runtime.junit.ExecutionUnitRunner.run(ExecutionUnitRunner.java:91)\n\tat cucumber.runtime.junit.FeatureRunner.runChild(FeatureRunner.java:63)\n\tat cucumber.runtime.junit.FeatureRunner.runChild(FeatureRunner.java:18)\n\tat org.junit.runners.ParentRunner$3.run(ParentRunner.java:238)\n\tat org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:63)\n\tat org.junit.runners.ParentRunner.runChildren(ParentRunner.java:236)\n\tat org.junit.runners.ParentRunner.access$000(ParentRunner.java:53)\n\tat org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:229)\n\tat org.junit.runners.ParentRunner.run(ParentRunner.java:309)\n\tat cucumber.runtime.junit.FeatureRunner.run(FeatureRunner.java:70)\n\tat cucumber.api.junit.Cucumber.runChild(Cucumber.java:93)\n\tat cucumber.api.junit.Cucumber.runChild(Cucumber.java:37)\n\tat org.junit.runners.ParentRunner$3.run(ParentRunner.java:238)\n\tat org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:63)\n\tat org.junit.runners.ParentRunner.runChildren(ParentRunner.java:236)\n\tat org.junit.runners.ParentRunner.access$000(ParentRunner.java:53)\n\tat org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:229)\n\tat org.junit.internal.runners.statements.RunAfters.evaluate(RunAfters.java:27)\n\tat org.junit.runners.ParentRunner.run(ParentRunner.java:309)\n\tat cucumber.api.junit.Cucumber.run(Cucumber.java:98)\n\tat org.eclipse.jdt.internal.junit4.runner.JUnit4TestReference.run(JUnit4TestReference.java:86)\n\tat org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:459)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:678)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:382)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:192)\n",
  "status": "failed"
});
formatter.match({
  "location": "survey.asssurvey()"
});
formatter.result({
  "duration": 0,
  "error_message": "cucumber.runtime.AmbiguousStepDefinitionsException: ✽.Then Assert the success of Survey application(CAPEC_136_Step_1_1.feature:8) matches more than one step definition:\n  Assert the success of Survey in survey.asssurvey()\n  Assert the success of Survey application in surveyapplication.asssurveyapplication()\n\n\tat cucumber.runtime.RuntimeGlue.stepDefinitionMatch(RuntimeGlue.java:71)\n\tat cucumber.runtime.Runtime.runStep(Runtime.java:265)\n\tat cucumber.runtime.model.StepContainer.runStep(StepContainer.java:44)\n\tat cucumber.runtime.model.StepContainer.runSteps(StepContainer.java:39)\n\tat cucumber.runtime.model.CucumberScenario.run(CucumberScenario.java:48)\n\tat cucumber.runtime.junit.ExecutionUnitRunner.run(ExecutionUnitRunner.java:91)\n\tat cucumber.runtime.junit.FeatureRunner.runChild(FeatureRunner.java:63)\n\tat cucumber.runtime.junit.FeatureRunner.runChild(FeatureRunner.java:18)\n\tat org.junit.runners.ParentRunner$3.run(ParentRunner.java:238)\n\tat org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:63)\n\tat org.junit.runners.ParentRunner.runChildren(ParentRunner.java:236)\n\tat org.junit.runners.ParentRunner.access$000(ParentRunner.java:53)\n\tat org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:229)\n\tat org.junit.runners.ParentRunner.run(ParentRunner.java:309)\n\tat cucumber.runtime.junit.FeatureRunner.run(FeatureRunner.java:70)\n\tat cucumber.api.junit.Cucumber.runChild(Cucumber.java:93)\n\tat cucumber.api.junit.Cucumber.runChild(Cucumber.java:37)\n\tat org.junit.runners.ParentRunner$3.run(ParentRunner.java:238)\n\tat org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:63)\n\tat org.junit.runners.ParentRunner.runChildren(ParentRunner.java:236)\n\tat org.junit.runners.ParentRunner.access$000(ParentRunner.java:53)\n\tat org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:229)\n\tat org.junit.internal.runners.statements.RunAfters.evaluate(RunAfters.java:27)\n\tat org.junit.runners.ParentRunner.run(ParentRunner.java:309)\n\tat cucumber.api.junit.Cucumber.run(Cucumber.java:98)\n\tat org.eclipse.jdt.internal.junit4.runner.JUnit4TestReference.run(JUnit4TestReference.java:86)\n\tat org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:459)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:678)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:382)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:192)\n",
  "status": "failed"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({
  "location": "PatternSteps.assauditinterceptor()"
});
formatter.result({
  "status": "skipped"
});
formatter.match({
  "location": "PatternSteps.asssecurelogger()"
});
formatter.result({
  "status": "skipped"
});
formatter.uri("CAPEC_136_Step_2_1.feature");
formatter.feature({
  "line": 2,
  "name": "CAPEC-136: LDAP Injection",
  "description": "",
  "id": "capec-136:-ldap-injection",
  "keyword": "Feature",
  "tags": [
    {
      "line": 1,
      "name": "@capec136"
    }
  ]
});
formatter.scenario({
  "comments": [
    {
      "line": 3,
      "value": "#2. Experiment"
    }
  ],
  "line": 4,
  "name": "Step2.1 Determine user-controllable input susceptible to LDAP injection",
  "description": "",
  "id": "capec-136:-ldap-injection;step2.1-determine-user-controllable-input-susceptible-to-ldap-injection",
  "type": "scenario",
  "keyword": "Scenario"
});
formatter.step({
  "line": 5,
  "name": "prepare to Determine user-controllable input susceptible to LDAP injection",
  "keyword": "Given "
});
formatter.step({
  "line": 6,
  "name": "Try to Determine user-controllable input susceptible to LDAP injection",
  "keyword": "When "
});
formatter.step({
  "comments": [
    {
      "line": 7,
      "value": "# assertion for attack step success"
    }
  ],
  "line": 8,
  "name": "Assert the success of Determine user-controllable input susceptible to LDAP injection",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 9,
      "value": "#assertions for security pattern testing (checker whether the pattern consequences are observed)"
    }
  ],
  "line": 10,
  "name": "assert the consequences of the pattern application firewall",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 11,
      "value": "# alternative input guard"
    }
  ],
  "line": 12,
  "name": "assert the consequences of the pattern input guard",
  "keyword": "Then "
});
formatter.match({
  "location": "determineusercontrollableinputsusceptibletoldapinjection.predetermineusercontrollableinputsusceptibletoldapinjection()"
});
formatter.result({
  "duration": 2348669,
  "error_message": "net.continuumsecurity.proxy.ProxyException: org.zaproxy.clientapi.core.ClientApiException: java.net.ConnectException: Connection refused\n\tat net.continuumsecurity.proxy.ZAProxyScanner.validateMinimumRequiredZapVersion(ZAProxyScanner.java:96)\n\tat net.continuumsecurity.proxy.ZAProxyScanner.\u003cinit\u003e(ZAProxyScanner.java:38)\n\tat steps.determineusercontrollableinputsusceptibletoldapinjection.predetermineusercontrollableinputsusceptibletoldapinjection(determineusercontrollableinputsusceptibletoldapinjection.java:15)\n\tat ✽.Given prepare to Determine user-controllable input susceptible to LDAP injection(CAPEC_136_Step_2_1.feature:5)\nCaused by: org.zaproxy.clientapi.core.ClientApiException: java.net.ConnectException: Connection refused\n\tat org.zaproxy.clientapi.core.ClientApi.callApiDom(ClientApi.java:307)\n\tat org.zaproxy.clientapi.core.ClientApi.callApi(ClientApi.java:289)\n\tat org.zaproxy.clientapi.gen.Core.version(Core.java:158)\n\tat net.continuumsecurity.proxy.ZAProxyScanner.validateMinimumRequiredZapVersion(ZAProxyScanner.java:85)\n\tat net.continuumsecurity.proxy.ZAProxyScanner.\u003cinit\u003e(ZAProxyScanner.java:38)\n\tat steps.determineusercontrollableinputsusceptibletoldapinjection.predetermineusercontrollableinputsusceptibletoldapinjection(determineusercontrollableinputsusceptibletoldapinjection.java:15)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.lang.reflect.Method.invoke(Method.java:498)\n\tat cucumber.runtime.Utils$1.call(Utils.java:37)\n\tat cucumber.runtime.Timeout.timeout(Timeout.java:13)\n\tat cucumber.runtime.Utils.invoke(Utils.java:31)\n\tat cucumber.runtime.java.JavaStepDefinition.execute(JavaStepDefinition.java:37)\n\tat cucumber.runtime.StepDefinitionMatch.runStep(StepDefinitionMatch.java:37)\n\tat cucumber.runtime.Runtime.runStep(Runtime.java:298)\n\tat cucumber.runtime.model.StepContainer.runStep(StepContainer.java:44)\n\tat cucumber.runtime.model.StepContainer.runSteps(StepContainer.java:39)\n\tat cucumber.runtime.model.CucumberScenario.run(CucumberScenario.java:48)\n\tat cucumber.runtime.junit.ExecutionUnitRunner.run(ExecutionUnitRunner.java:91)\n\tat cucumber.runtime.junit.FeatureRunner.runChild(FeatureRunner.java:63)\n\tat cucumber.runtime.junit.FeatureRunner.runChild(FeatureRunner.java:18)\n\tat org.junit.runners.ParentRunner$3.run(ParentRunner.java:238)\n\tat org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:63)\n\tat org.junit.runners.ParentRunner.runChildren(ParentRunner.java:236)\n\tat org.junit.runners.ParentRunner.access$000(ParentRunner.java:53)\n\tat org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:229)\n\tat org.junit.runners.ParentRunner.run(ParentRunner.java:309)\n\tat cucumber.runtime.junit.FeatureRunner.run(FeatureRunner.java:70)\n\tat cucumber.api.junit.Cucumber.runChild(Cucumber.java:93)\n\tat cucumber.api.junit.Cucumber.runChild(Cucumber.java:37)\n\tat org.junit.runners.ParentRunner$3.run(ParentRunner.java:238)\n\tat org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:63)\n\tat org.junit.runners.ParentRunner.runChildren(ParentRunner.java:236)\n\tat org.junit.runners.ParentRunner.access$000(ParentRunner.java:53)\n\tat org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:229)\n\tat org.junit.internal.runners.statements.RunAfters.evaluate(RunAfters.java:27)\n\tat org.junit.runners.ParentRunner.run(ParentRunner.java:309)\n\tat cucumber.api.junit.Cucumber.run(Cucumber.java:98)\n\tat org.eclipse.jdt.internal.junit4.runner.JUnit4TestReference.run(JUnit4TestReference.java:86)\n\tat org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:459)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:678)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:382)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:192)\nCaused by: java.net.ConnectException: Connection refused\n\tat java.net.PlainSocketImpl.socketConnect(Native Method)\n\tat java.net.AbstractPlainSocketImpl.doConnect(AbstractPlainSocketImpl.java:350)\n\tat java.net.AbstractPlainSocketImpl.connectToAddress(AbstractPlainSocketImpl.java:206)\n\tat java.net.AbstractPlainSocketImpl.connect(AbstractPlainSocketImpl.java:188)\n\tat java.net.Socket.connect(Socket.java:589)\n\tat java.net.Socket.connect(Socket.java:538)\n\tat sun.net.NetworkClient.doConnect(NetworkClient.java:180)\n\tat sun.net.www.http.HttpClient.openServer(HttpClient.java:432)\n\tat sun.net.www.http.HttpClient$1.run(HttpClient.java:484)\n\tat sun.net.www.http.HttpClient$1.run(HttpClient.java:482)\n\tat java.security.AccessController.doPrivileged(Native Method)\n\tat sun.net.www.http.HttpClient.privilegedOpenServer(HttpClient.java:481)\n\tat sun.net.www.http.HttpClient.openServer(HttpClient.java:522)\n\tat sun.net.www.http.HttpClient.\u003cinit\u003e(HttpClient.java:211)\n\tat sun.net.www.http.HttpClient.New(HttpClient.java:308)\n\tat sun.net.www.http.HttpClient.New(HttpClient.java:326)\n\tat sun.net.www.protocol.http.HttpURLConnection.getNewHttpClient(HttpURLConnection.java:1169)\n\tat sun.net.www.protocol.http.HttpURLConnection.plainConnect0(HttpURLConnection.java:1148)\n\tat sun.net.www.protocol.http.HttpURLConnection.plainConnect(HttpURLConnection.java:999)\n\tat sun.net.www.protocol.http.HttpURLConnection.connect(HttpURLConnection.java:933)\n\tat org.zaproxy.clientapi.core.ClientApi.getConnectionInputStream(ClientApi.java:313)\n\tat org.zaproxy.clientapi.core.ClientApi.callApiDom(ClientApi.java:305)\n\t... 44 more\n",
  "status": "failed"
});
formatter.match({
  "location": "determineusercontrollableinputsusceptibletoldapinjection.trydetermineusercontrollableinputsusceptibletoldapinjection()"
});
formatter.result({
  "status": "skipped"
});
formatter.match({
  "location": "determineusercontrollableinputsusceptibletoldapinjection.assdetermineusercontrollableinputsusceptibletoldapinjection()"
});
formatter.result({
  "status": "skipped"
});
formatter.match({
  "location": "PatternSteps.assapplicationfirewall()"
});
formatter.result({
  "status": "skipped"
});
formatter.match({
  "location": "PatternSteps.assinputguard()"
});
formatter.result({
  "status": "skipped"
});
formatter.uri("CAPEC_136_Step_2_2.feature");
formatter.feature({
  "line": 2,
  "name": "CAPEC-136: LDAP Injection",
  "description": "",
  "id": "capec-136:-ldap-injection",
  "keyword": "Feature",
  "tags": [
    {
      "line": 1,
      "name": "@capec136"
    }
  ]
});
formatter.scenario({
  "comments": [
    {
      "line": 3,
      "value": "#2. Experiment"
    }
  ],
  "line": 4,
  "name": "Step2.2 Try to exploit the LDAP injection vulnerability",
  "description": "",
  "id": "capec-136:-ldap-injection;step2.2-try-to-exploit-the-ldap-injection-vulnerability",
  "type": "scenario",
  "keyword": "Scenario"
});
formatter.step({
  "line": 5,
  "name": "prepare to Try to exploit the LDAP injection vulnerability",
  "keyword": "Given "
});
formatter.step({
  "line": 6,
  "name": "Try to Try to exploit the LDAP injection vulnerability",
  "keyword": "When "
});
formatter.step({
  "comments": [
    {
      "line": 7,
      "value": "# assertion for attack step success"
    }
  ],
  "line": 8,
  "name": "Assert the success of Try to exploit the LDAP injection vulnerability",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 9,
      "value": "#assertions for security pattern testing (checker whether the pattern consequences are observed)"
    }
  ],
  "line": 10,
  "name": "assert the consequences of the pattern application firewall",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 11,
      "value": "# alternative input guard"
    }
  ],
  "line": 12,
  "name": "assert the consequences of the pattern input guard",
  "keyword": "Then "
});
formatter.match({
  "location": "trytoexploittheldapinjectionvulnerability.pretrytoexploittheldapinjectionvulnerability()"
});
formatter.result({
  "duration": 83610,
  "status": "passed"
});
formatter.match({
  "location": "trytoexploittheldapinjectionvulnerability.trytrytoexploittheldapinjectionvulnerability()"
});
formatter.result({
  "duration": 15831,
  "status": "passed"
});
formatter.match({
  "location": "trytoexploittheldapinjectionvulnerability.asstrytoexploittheldapinjectionvulnerability()"
});
formatter.result({
  "duration": 13833,
  "status": "passed"
});
formatter.match({
  "location": "PatternSteps.assapplicationfirewall()"
});
formatter.result({
  "duration": 43382,
  "status": "passed"
});
formatter.match({
  "location": "PatternSteps.assinputguard()"
});
formatter.result({
  "duration": 16716,
  "status": "passed"
});
formatter.uri("CAPEC_139_Step_1_1.feature");
formatter.feature({
  "line": 2,
  "name": "CAPEC-139: Relative Path Traversal",
  "description": "",
  "id": "capec-139:-relative-path-traversal",
  "keyword": "Feature",
  "tags": [
    {
      "line": 1,
      "name": "@capec139"
    }
  ]
});
formatter.scenario({
  "comments": [
    {
      "line": 3,
      "value": "#1. Explore"
    }
  ],
  "line": 4,
  "name": "Step1.1 Survey application",
  "description": "",
  "id": "capec-139:-relative-path-traversal;step1.1-survey-application",
  "type": "scenario",
  "keyword": "Scenario"
});
formatter.step({
  "line": 5,
  "name": "prepare to Survey application",
  "keyword": "Given "
});
formatter.step({
  "line": 6,
  "name": "Try to Survey application",
  "keyword": "When "
});
formatter.step({
  "comments": [
    {
      "line": 7,
      "value": "# assertion for attack step success"
    }
  ],
  "line": 8,
  "name": "Assert the success of Survey application",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 9,
      "value": "#assertions for security pattern testing (checker whether the pattern consequences are observed)"
    }
  ],
  "line": 10,
  "name": "assert the consequences of the pattern",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 11,
      "value": "#"
    }
  ],
  "line": 12,
  "name": "assert the consequences of the pattern audit interceptor",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 13,
      "value": "# depends secure logger"
    }
  ],
  "line": 14,
  "name": "assert the consequences of the pattern secure logger",
  "keyword": "Then "
});
formatter.match({
  "location": "survey.presurvey()"
});
formatter.result({
  "duration": 0,
  "error_message": "cucumber.runtime.AmbiguousStepDefinitionsException: ✽.Given prepare to Survey application(CAPEC_139_Step_1_1.feature:5) matches more than one step definition:\n  prepare to Survey in survey.presurvey()\n  prepare to Survey application in surveyapplication.presurveyapplication()\n\n\tat cucumber.runtime.RuntimeGlue.stepDefinitionMatch(RuntimeGlue.java:71)\n\tat cucumber.runtime.Runtime.runStep(Runtime.java:265)\n\tat cucumber.runtime.model.StepContainer.runStep(StepContainer.java:44)\n\tat cucumber.runtime.model.StepContainer.runSteps(StepContainer.java:39)\n\tat cucumber.runtime.model.CucumberScenario.run(CucumberScenario.java:48)\n\tat cucumber.runtime.junit.ExecutionUnitRunner.run(ExecutionUnitRunner.java:91)\n\tat cucumber.runtime.junit.FeatureRunner.runChild(FeatureRunner.java:63)\n\tat cucumber.runtime.junit.FeatureRunner.runChild(FeatureRunner.java:18)\n\tat org.junit.runners.ParentRunner$3.run(ParentRunner.java:238)\n\tat org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:63)\n\tat org.junit.runners.ParentRunner.runChildren(ParentRunner.java:236)\n\tat org.junit.runners.ParentRunner.access$000(ParentRunner.java:53)\n\tat org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:229)\n\tat org.junit.runners.ParentRunner.run(ParentRunner.java:309)\n\tat cucumber.runtime.junit.FeatureRunner.run(FeatureRunner.java:70)\n\tat cucumber.api.junit.Cucumber.runChild(Cucumber.java:93)\n\tat cucumber.api.junit.Cucumber.runChild(Cucumber.java:37)\n\tat org.junit.runners.ParentRunner$3.run(ParentRunner.java:238)\n\tat org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:63)\n\tat org.junit.runners.ParentRunner.runChildren(ParentRunner.java:236)\n\tat org.junit.runners.ParentRunner.access$000(ParentRunner.java:53)\n\tat org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:229)\n\tat org.junit.internal.runners.statements.RunAfters.evaluate(RunAfters.java:27)\n\tat org.junit.runners.ParentRunner.run(ParentRunner.java:309)\n\tat cucumber.api.junit.Cucumber.run(Cucumber.java:98)\n\tat org.eclipse.jdt.internal.junit4.runner.JUnit4TestReference.run(JUnit4TestReference.java:86)\n\tat org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:459)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:678)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:382)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:192)\n",
  "status": "failed"
});
formatter.match({
  "location": "survey.trysurvey()"
});
formatter.result({
  "duration": 0,
  "error_message": "cucumber.runtime.AmbiguousStepDefinitionsException: ✽.When Try to Survey application(CAPEC_139_Step_1_1.feature:6) matches more than one step definition:\n  Try to Survey in survey.trysurvey()\n  Try to Survey application in surveyapplication.trysurveyapplication()\n\n\tat cucumber.runtime.RuntimeGlue.stepDefinitionMatch(RuntimeGlue.java:71)\n\tat cucumber.runtime.Runtime.runStep(Runtime.java:265)\n\tat cucumber.runtime.model.StepContainer.runStep(StepContainer.java:44)\n\tat cucumber.runtime.model.StepContainer.runSteps(StepContainer.java:39)\n\tat cucumber.runtime.model.CucumberScenario.run(CucumberScenario.java:48)\n\tat cucumber.runtime.junit.ExecutionUnitRunner.run(ExecutionUnitRunner.java:91)\n\tat cucumber.runtime.junit.FeatureRunner.runChild(FeatureRunner.java:63)\n\tat cucumber.runtime.junit.FeatureRunner.runChild(FeatureRunner.java:18)\n\tat org.junit.runners.ParentRunner$3.run(ParentRunner.java:238)\n\tat org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:63)\n\tat org.junit.runners.ParentRunner.runChildren(ParentRunner.java:236)\n\tat org.junit.runners.ParentRunner.access$000(ParentRunner.java:53)\n\tat org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:229)\n\tat org.junit.runners.ParentRunner.run(ParentRunner.java:309)\n\tat cucumber.runtime.junit.FeatureRunner.run(FeatureRunner.java:70)\n\tat cucumber.api.junit.Cucumber.runChild(Cucumber.java:93)\n\tat cucumber.api.junit.Cucumber.runChild(Cucumber.java:37)\n\tat org.junit.runners.ParentRunner$3.run(ParentRunner.java:238)\n\tat org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:63)\n\tat org.junit.runners.ParentRunner.runChildren(ParentRunner.java:236)\n\tat org.junit.runners.ParentRunner.access$000(ParentRunner.java:53)\n\tat org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:229)\n\tat org.junit.internal.runners.statements.RunAfters.evaluate(RunAfters.java:27)\n\tat org.junit.runners.ParentRunner.run(ParentRunner.java:309)\n\tat cucumber.api.junit.Cucumber.run(Cucumber.java:98)\n\tat org.eclipse.jdt.internal.junit4.runner.JUnit4TestReference.run(JUnit4TestReference.java:86)\n\tat org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:459)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:678)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:382)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:192)\n",
  "status": "failed"
});
formatter.match({
  "location": "survey.asssurvey()"
});
formatter.result({
  "duration": 0,
  "error_message": "cucumber.runtime.AmbiguousStepDefinitionsException: ✽.Then Assert the success of Survey application(CAPEC_139_Step_1_1.feature:8) matches more than one step definition:\n  Assert the success of Survey in survey.asssurvey()\n  Assert the success of Survey application in surveyapplication.asssurveyapplication()\n\n\tat cucumber.runtime.RuntimeGlue.stepDefinitionMatch(RuntimeGlue.java:71)\n\tat cucumber.runtime.Runtime.runStep(Runtime.java:265)\n\tat cucumber.runtime.model.StepContainer.runStep(StepContainer.java:44)\n\tat cucumber.runtime.model.StepContainer.runSteps(StepContainer.java:39)\n\tat cucumber.runtime.model.CucumberScenario.run(CucumberScenario.java:48)\n\tat cucumber.runtime.junit.ExecutionUnitRunner.run(ExecutionUnitRunner.java:91)\n\tat cucumber.runtime.junit.FeatureRunner.runChild(FeatureRunner.java:63)\n\tat cucumber.runtime.junit.FeatureRunner.runChild(FeatureRunner.java:18)\n\tat org.junit.runners.ParentRunner$3.run(ParentRunner.java:238)\n\tat org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:63)\n\tat org.junit.runners.ParentRunner.runChildren(ParentRunner.java:236)\n\tat org.junit.runners.ParentRunner.access$000(ParentRunner.java:53)\n\tat org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:229)\n\tat org.junit.runners.ParentRunner.run(ParentRunner.java:309)\n\tat cucumber.runtime.junit.FeatureRunner.run(FeatureRunner.java:70)\n\tat cucumber.api.junit.Cucumber.runChild(Cucumber.java:93)\n\tat cucumber.api.junit.Cucumber.runChild(Cucumber.java:37)\n\tat org.junit.runners.ParentRunner$3.run(ParentRunner.java:238)\n\tat org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:63)\n\tat org.junit.runners.ParentRunner.runChildren(ParentRunner.java:236)\n\tat org.junit.runners.ParentRunner.access$000(ParentRunner.java:53)\n\tat org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:229)\n\tat org.junit.internal.runners.statements.RunAfters.evaluate(RunAfters.java:27)\n\tat org.junit.runners.ParentRunner.run(ParentRunner.java:309)\n\tat cucumber.api.junit.Cucumber.run(Cucumber.java:98)\n\tat org.eclipse.jdt.internal.junit4.runner.JUnit4TestReference.run(JUnit4TestReference.java:86)\n\tat org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:459)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:678)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:382)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:192)\n",
  "status": "failed"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({
  "location": "PatternSteps.assauditinterceptor()"
});
formatter.result({
  "status": "skipped"
});
formatter.match({
  "location": "PatternSteps.asssecurelogger()"
});
formatter.result({
  "status": "skipped"
});
formatter.uri("CAPEC_139_Step_2_1.feature");
formatter.feature({
  "line": 2,
  "name": "CAPEC-139: Relative Path Traversal",
  "description": "",
  "id": "capec-139:-relative-path-traversal",
  "keyword": "Feature",
  "tags": [
    {
      "line": 1,
      "name": "@capec139"
    }
  ]
});
formatter.scenario({
  "comments": [
    {
      "line": 3,
      "value": "#2. Experiment"
    }
  ],
  "line": 4,
  "name": "Step2.1 Attempt variations on input parameters",
  "description": "",
  "id": "capec-139:-relative-path-traversal;step2.1-attempt-variations-on-input-parameters",
  "type": "scenario",
  "keyword": "Scenario"
});
formatter.step({
  "line": 5,
  "name": "prepare to Attempt variations on input parameters",
  "keyword": "Given "
});
formatter.step({
  "line": 6,
  "name": "Try to Attempt variations on input parameters",
  "keyword": "When "
});
formatter.step({
  "comments": [
    {
      "line": 7,
      "value": "# assertion for attack step success"
    }
  ],
  "line": 8,
  "name": "Assert the success of Attempt variations on input parameters",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 9,
      "value": "#assertions for security pattern testing (checker whether the pattern consequences are observed)"
    }
  ],
  "line": 10,
  "name": "assert the consequences of the pattern audit interceptor",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 11,
      "value": "# depends secure logger"
    }
  ],
  "line": 12,
  "name": "assert the consequences of the pattern secure logger",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 13,
      "value": "# benifits audit interceptor"
    }
  ],
  "line": 14,
  "name": "assert the consequences of the pattern application firewall",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 15,
      "value": "# alternative input guard"
    }
  ],
  "line": 16,
  "name": "assert the consequences of the pattern input guard",
  "keyword": "Then "
});
formatter.match({
  "location": "attemptvariationsoninputparameters.preattemptvariationsoninputparameters()"
});
formatter.result({
  "duration": 2641632,
  "error_message": "net.continuumsecurity.proxy.ProxyException: org.zaproxy.clientapi.core.ClientApiException: java.net.ConnectException: Connection refused\n\tat net.continuumsecurity.proxy.ZAProxyScanner.validateMinimumRequiredZapVersion(ZAProxyScanner.java:96)\n\tat net.continuumsecurity.proxy.ZAProxyScanner.\u003cinit\u003e(ZAProxyScanner.java:38)\n\tat steps.attemptvariationsoninputparameters.preattemptvariationsoninputparameters(attemptvariationsoninputparameters.java:19)\n\tat ✽.Given prepare to Attempt variations on input parameters(CAPEC_139_Step_2_1.feature:5)\nCaused by: org.zaproxy.clientapi.core.ClientApiException: java.net.ConnectException: Connection refused\n\tat org.zaproxy.clientapi.core.ClientApi.callApiDom(ClientApi.java:307)\n\tat org.zaproxy.clientapi.core.ClientApi.callApi(ClientApi.java:289)\n\tat org.zaproxy.clientapi.gen.Core.version(Core.java:158)\n\tat net.continuumsecurity.proxy.ZAProxyScanner.validateMinimumRequiredZapVersion(ZAProxyScanner.java:85)\n\tat net.continuumsecurity.proxy.ZAProxyScanner.\u003cinit\u003e(ZAProxyScanner.java:38)\n\tat steps.attemptvariationsoninputparameters.preattemptvariationsoninputparameters(attemptvariationsoninputparameters.java:19)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.lang.reflect.Method.invoke(Method.java:498)\n\tat cucumber.runtime.Utils$1.call(Utils.java:37)\n\tat cucumber.runtime.Timeout.timeout(Timeout.java:13)\n\tat cucumber.runtime.Utils.invoke(Utils.java:31)\n\tat cucumber.runtime.java.JavaStepDefinition.execute(JavaStepDefinition.java:37)\n\tat cucumber.runtime.StepDefinitionMatch.runStep(StepDefinitionMatch.java:37)\n\tat cucumber.runtime.Runtime.runStep(Runtime.java:298)\n\tat cucumber.runtime.model.StepContainer.runStep(StepContainer.java:44)\n\tat cucumber.runtime.model.StepContainer.runSteps(StepContainer.java:39)\n\tat cucumber.runtime.model.CucumberScenario.run(CucumberScenario.java:48)\n\tat cucumber.runtime.junit.ExecutionUnitRunner.run(ExecutionUnitRunner.java:91)\n\tat cucumber.runtime.junit.FeatureRunner.runChild(FeatureRunner.java:63)\n\tat cucumber.runtime.junit.FeatureRunner.runChild(FeatureRunner.java:18)\n\tat org.junit.runners.ParentRunner$3.run(ParentRunner.java:238)\n\tat org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:63)\n\tat org.junit.runners.ParentRunner.runChildren(ParentRunner.java:236)\n\tat org.junit.runners.ParentRunner.access$000(ParentRunner.java:53)\n\tat org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:229)\n\tat org.junit.runners.ParentRunner.run(ParentRunner.java:309)\n\tat cucumber.runtime.junit.FeatureRunner.run(FeatureRunner.java:70)\n\tat cucumber.api.junit.Cucumber.runChild(Cucumber.java:93)\n\tat cucumber.api.junit.Cucumber.runChild(Cucumber.java:37)\n\tat org.junit.runners.ParentRunner$3.run(ParentRunner.java:238)\n\tat org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:63)\n\tat org.junit.runners.ParentRunner.runChildren(ParentRunner.java:236)\n\tat org.junit.runners.ParentRunner.access$000(ParentRunner.java:53)\n\tat org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:229)\n\tat org.junit.internal.runners.statements.RunAfters.evaluate(RunAfters.java:27)\n\tat org.junit.runners.ParentRunner.run(ParentRunner.java:309)\n\tat cucumber.api.junit.Cucumber.run(Cucumber.java:98)\n\tat org.eclipse.jdt.internal.junit4.runner.JUnit4TestReference.run(JUnit4TestReference.java:86)\n\tat org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:459)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:678)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:382)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:192)\nCaused by: java.net.ConnectException: Connection refused\n\tat java.net.PlainSocketImpl.socketConnect(Native Method)\n\tat java.net.AbstractPlainSocketImpl.doConnect(AbstractPlainSocketImpl.java:350)\n\tat java.net.AbstractPlainSocketImpl.connectToAddress(AbstractPlainSocketImpl.java:206)\n\tat java.net.AbstractPlainSocketImpl.connect(AbstractPlainSocketImpl.java:188)\n\tat java.net.Socket.connect(Socket.java:589)\n\tat java.net.Socket.connect(Socket.java:538)\n\tat sun.net.NetworkClient.doConnect(NetworkClient.java:180)\n\tat sun.net.www.http.HttpClient.openServer(HttpClient.java:432)\n\tat sun.net.www.http.HttpClient$1.run(HttpClient.java:484)\n\tat sun.net.www.http.HttpClient$1.run(HttpClient.java:482)\n\tat java.security.AccessController.doPrivileged(Native Method)\n\tat sun.net.www.http.HttpClient.privilegedOpenServer(HttpClient.java:481)\n\tat sun.net.www.http.HttpClient.openServer(HttpClient.java:522)\n\tat sun.net.www.http.HttpClient.\u003cinit\u003e(HttpClient.java:211)\n\tat sun.net.www.http.HttpClient.New(HttpClient.java:308)\n\tat sun.net.www.http.HttpClient.New(HttpClient.java:326)\n\tat sun.net.www.protocol.http.HttpURLConnection.getNewHttpClient(HttpURLConnection.java:1169)\n\tat sun.net.www.protocol.http.HttpURLConnection.plainConnect0(HttpURLConnection.java:1148)\n\tat sun.net.www.protocol.http.HttpURLConnection.plainConnect(HttpURLConnection.java:999)\n\tat sun.net.www.protocol.http.HttpURLConnection.connect(HttpURLConnection.java:933)\n\tat org.zaproxy.clientapi.core.ClientApi.getConnectionInputStream(ClientApi.java:313)\n\tat org.zaproxy.clientapi.core.ClientApi.callApiDom(ClientApi.java:305)\n\t... 44 more\n",
  "status": "failed"
});
formatter.match({
  "location": "attemptvariationsoninputparameters.tryattemptvariationsoninputparameters()"
});
formatter.result({
  "status": "skipped"
});
formatter.match({
  "location": "attemptvariationsoninputparameters.assattemptvariationsoninputparameters()"
});
formatter.result({
  "status": "skipped"
});
formatter.match({
  "location": "PatternSteps.assauditinterceptor()"
});
formatter.result({
  "status": "skipped"
});
formatter.match({
  "location": "PatternSteps.asssecurelogger()"
});
formatter.result({
  "status": "skipped"
});
formatter.match({
  "location": "PatternSteps.assapplicationfirewall()"
});
formatter.result({
  "status": "skipped"
});
formatter.match({
  "location": "PatternSteps.assinputguard()"
});
formatter.result({
  "status": "skipped"
});
formatter.uri("CAPEC_139_Step_3_1.feature");
formatter.feature({
  "line": 2,
  "name": "CAPEC-139: Relative Path Traversal",
  "description": "",
  "id": "capec-139:-relative-path-traversal",
  "keyword": "Feature",
  "tags": [
    {
      "line": 1,
      "name": "@capec139"
    }
  ]
});
formatter.scenario({
  "comments": [
    {
      "line": 3,
      "value": "#3. Exploit"
    }
  ],
  "line": 4,
  "name": "Step3.1 Access, modify, or execute arbitrary files.",
  "description": "",
  "id": "capec-139:-relative-path-traversal;step3.1-access,-modify,-or-execute-arbitrary-files.",
  "type": "scenario",
  "keyword": "Scenario"
});
formatter.step({
  "line": 5,
  "name": "prepare to Access, modify, or execute arbitrary files.",
  "keyword": "Given "
});
formatter.step({
  "line": 6,
  "name": "Try to Access, modify, or execute arbitrary files.",
  "keyword": "When "
});
formatter.step({
  "comments": [
    {
      "line": 7,
      "value": "# assertion for attack step success"
    }
  ],
  "line": 8,
  "name": "Assert the success of Access, modify, or execute arbitrary files.",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 9,
      "value": "#assertions for security pattern testing (checker whether the pattern consequences are observed)"
    }
  ],
  "line": 10,
  "name": "assert the consequences of the pattern secure logger",
  "keyword": "Then "
});
formatter.step({
  "line": 11,
  "name": "assert the consequences of the pattern application firewall",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 12,
      "value": "# alternative input guard"
    }
  ],
  "line": 13,
  "name": "assert the consequences of the pattern input guard",
  "keyword": "Then "
});
formatter.match({
  "location": "accessmodifyorexecutearbitraryfiles.preaccessmodifyorexecutearbitraryfiles()"
});
formatter.result({
  "duration": 88013,
  "status": "passed"
});
formatter.match({
  "location": "accessmodifyorexecutearbitraryfiles.tryaccessmodifyorexecutearbitraryfiles()"
});
formatter.result({
  "duration": 21425,
  "status": "passed"
});
formatter.match({
  "location": "accessmodifyorexecutearbitraryfiles.assaccessmodifyorexecutearbitraryfiles()"
});
formatter.result({
  "duration": 32750,
  "status": "passed"
});
formatter.match({
  "location": "PatternSteps.asssecurelogger()"
});
formatter.result({
  "duration": 32704,
  "status": "passed"
});
formatter.match({
  "location": "PatternSteps.assapplicationfirewall()"
});
formatter.result({
  "duration": 14984,
  "status": "passed"
});
formatter.match({
  "location": "PatternSteps.assinputguard()"
});
formatter.result({
  "duration": 12435,
  "status": "passed"
});
formatter.uri("CAPEC_13_Step_1_1.feature");
formatter.feature({
  "line": 2,
  "name": "CAPEC-13: Subverting Environment Variable Values",
  "description": "",
  "id": "capec-13:-subverting-environment-variable-values",
  "keyword": "Feature",
  "tags": [
    {
      "line": 1,
      "name": "@capec13"
    }
  ]
});
formatter.scenario({
  "comments": [
    {
      "line": 3,
      "value": "#1. Explore"
    }
  ],
  "line": 4,
  "name": "Step1.1",
  "description": "",
  "id": "capec-13:-subverting-environment-variable-values;step1.1",
  "type": "scenario",
  "keyword": "Scenario"
});
formatter.step({
  "line": 5,
  "name": "prepare to",
  "keyword": "Given "
});
formatter.step({
  "line": 6,
  "name": "Try to",
  "keyword": "When "
});
formatter.step({
  "comments": [
    {
      "line": 7,
      "value": "# assertion for attack step success"
    }
  ],
  "line": 8,
  "name": "Assert the success of",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 9,
      "value": "#assertions for security pattern testing (checker whether the pattern consequences are observed)"
    }
  ],
  "line": 10,
  "name": "assert the consequences of the pattern",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 11,
      "value": "#"
    }
  ],
  "line": 12,
  "name": "assert the consequences of the pattern audit interceptor",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 13,
      "value": "# depends secure logger"
    }
  ],
  "line": 14,
  "name": "assert the consequences of the pattern secure logger",
  "keyword": "Then "
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({
  "location": "PatternSteps.assauditinterceptor()"
});
formatter.result({
  "status": "skipped"
});
formatter.match({
  "location": "PatternSteps.asssecurelogger()"
});
formatter.result({
  "status": "skipped"
});
formatter.uri("CAPEC_13_Step_2_1.feature");
formatter.feature({
  "line": 2,
  "name": "CAPEC-13: Subverting Environment Variable Values",
  "description": "",
  "id": "capec-13:-subverting-environment-variable-values",
  "keyword": "Feature",
  "tags": [
    {
      "line": 1,
      "name": "@capec13"
    }
  ]
});
formatter.scenario({
  "comments": [
    {
      "line": 3,
      "value": "#2. Experiment"
    }
  ],
  "line": 4,
  "name": "Step2.1",
  "description": "",
  "id": "capec-13:-subverting-environment-variable-values;step2.1",
  "type": "scenario",
  "keyword": "Scenario"
});
formatter.step({
  "line": 5,
  "name": "prepare to",
  "keyword": "Given "
});
formatter.step({
  "line": 6,
  "name": "Try to",
  "keyword": "When "
});
formatter.step({
  "comments": [
    {
      "line": 7,
      "value": "# assertion for attack step success"
    }
  ],
  "line": 8,
  "name": "Assert the success of",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 9,
      "value": "#assertions for security pattern testing (checker whether the pattern consequences are observed)"
    }
  ],
  "line": 10,
  "name": "assert the consequences of the pattern",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 11,
      "value": "#"
    }
  ],
  "line": 12,
  "name": "assert the consequences of the pattern audit interceptor",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 13,
      "value": "# depends secure logger"
    }
  ],
  "line": 14,
  "name": "assert the consequences of the pattern secure logger",
  "keyword": "Then "
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({
  "location": "PatternSteps.assauditinterceptor()"
});
formatter.result({
  "status": "skipped"
});
formatter.match({
  "location": "PatternSteps.asssecurelogger()"
});
formatter.result({
  "status": "skipped"
});
formatter.uri("CAPEC_13_Step_3_1.feature");
formatter.feature({
  "line": 2,
  "name": "CAPEC-13: Subverting Environment Variable Values",
  "description": "",
  "id": "capec-13:-subverting-environment-variable-values",
  "keyword": "Feature",
  "tags": [
    {
      "line": 1,
      "name": "@capec13"
    }
  ]
});
formatter.scenario({
  "comments": [
    {
      "line": 3,
      "value": "#3. Exploit"
    }
  ],
  "line": 4,
  "name": "Step3.1",
  "description": "",
  "id": "capec-13:-subverting-environment-variable-values;step3.1",
  "type": "scenario",
  "keyword": "Scenario"
});
formatter.step({
  "line": 5,
  "name": "prepare to",
  "keyword": "Given "
});
formatter.step({
  "line": 6,
  "name": "Try to",
  "keyword": "When "
});
formatter.step({
  "comments": [
    {
      "line": 7,
      "value": "# assertion for attack step success"
    }
  ],
  "line": 8,
  "name": "Assert the success of",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 9,
      "value": "#assertions for security pattern testing (checker whether the pattern consequences are observed)"
    }
  ],
  "line": 10,
  "name": "assert the consequences of the pattern",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 11,
      "value": "#"
    }
  ],
  "line": 12,
  "name": "assert the consequences of the pattern audit interceptor",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 13,
      "value": "# depends secure logger"
    }
  ],
  "line": 14,
  "name": "assert the consequences of the pattern secure logger",
  "keyword": "Then "
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({
  "location": "PatternSteps.assauditinterceptor()"
});
formatter.result({
  "status": "skipped"
});
formatter.match({
  "location": "PatternSteps.asssecurelogger()"
});
formatter.result({
  "status": "skipped"
});
formatter.uri("CAPEC_141_Step_1_1.feature");
formatter.feature({
  "line": 2,
  "name": "CAPEC-141: Cache Poisoning",
  "description": "",
  "id": "capec-141:-cache-poisoning",
  "keyword": "Feature",
  "tags": [
    {
      "line": 1,
      "name": "@capec141"
    }
  ]
});
formatter.scenario({
  "comments": [
    {
      "line": 3,
      "value": "#1. Explore"
    }
  ],
  "line": 4,
  "name": "Step1.1 Identify and explore caches",
  "description": "",
  "id": "capec-141:-cache-poisoning;step1.1-identify-and-explore-caches",
  "type": "scenario",
  "keyword": "Scenario"
});
formatter.step({
  "line": 5,
  "name": "prepare to Identify and explore caches",
  "keyword": "Given "
});
formatter.step({
  "line": 6,
  "name": "Try to Identify and explore caches",
  "keyword": "When "
});
formatter.step({
  "comments": [
    {
      "line": 7,
      "value": "# assertion for attack step success"
    }
  ],
  "line": 8,
  "name": "Assert the success of Identify and explore caches",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 9,
      "value": "#assertions for security pattern testing (checker whether the pattern consequences are observed)"
    }
  ],
  "line": 10,
  "name": "assert the consequences of the pattern secure logger",
  "keyword": "Then "
});
formatter.match({
  "location": "identifyandexplorecaches.preidentifyandexplorecaches()"
});
formatter.result({
  "duration": 90861,
  "status": "passed"
});
formatter.match({
  "location": "identifyandexplorecaches.tryidentifyandexplorecaches()"
});
formatter.result({
  "duration": 10144,
  "status": "passed"
});
formatter.match({
  "location": "identifyandexplorecaches.assidentifyandexplorecaches()"
});
formatter.result({
  "duration": 8817,
  "status": "passed"
});
formatter.match({
  "location": "PatternSteps.asssecurelogger()"
});
formatter.result({
  "duration": 15876,
  "status": "passed"
});
formatter.uri("CAPEC_141_Step_2_1.feature");
formatter.feature({
  "line": 2,
  "name": "CAPEC-141: Cache Poisoning",
  "description": "",
  "id": "capec-141:-cache-poisoning",
  "keyword": "Feature",
  "tags": [
    {
      "line": 1,
      "name": "@capec141"
    }
  ]
});
formatter.scenario({
  "comments": [
    {
      "line": 3,
      "value": "#2. Experiment"
    }
  ],
  "line": 4,
  "name": "Step2.1 Cause specific data to be cached",
  "description": "",
  "id": "capec-141:-cache-poisoning;step2.1-cause-specific-data-to-be-cached",
  "type": "scenario",
  "keyword": "Scenario"
});
formatter.step({
  "line": 5,
  "name": "prepare to Cause specific data to be cached",
  "keyword": "Given "
});
formatter.step({
  "line": 6,
  "name": "Try to Cause specific data to be cached",
  "keyword": "When "
});
formatter.step({
  "comments": [
    {
      "line": 7,
      "value": "# assertion for attack step success"
    }
  ],
  "line": 8,
  "name": "Assert the success of Cause specific data to be cached",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 9,
      "value": "#assertions for security pattern testing (checker whether the pattern consequences are observed)"
    }
  ],
  "line": 10,
  "name": "assert the consequences of the pattern",
  "keyword": "Then "
});
formatter.match({
  "location": "causespecificdatatobecached.precausespecificdatatobecached()"
});
formatter.result({
  "duration": 52996,
  "status": "passed"
});
formatter.match({
  "location": "causespecificdatatobecached.trycausespecificdatatobecached()"
});
formatter.result({
  "duration": 9681,
  "status": "passed"
});
formatter.match({
  "location": "causespecificdatatobecached.asscausespecificdatatobecached()"
});
formatter.result({
  "duration": 8810,
  "status": "passed"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.uri("CAPEC_141_Step_3_1.feature");
formatter.feature({
  "line": 2,
  "name": "CAPEC-141: Cache Poisoning",
  "description": "",
  "id": "capec-141:-cache-poisoning",
  "keyword": "Feature",
  "tags": [
    {
      "line": 1,
      "name": "@capec141"
    }
  ]
});
formatter.scenario({
  "comments": [
    {
      "line": 3,
      "value": "#3. Exploit"
    }
  ],
  "line": 4,
  "name": "Step3.1 Redirect users to malicious website",
  "description": "",
  "id": "capec-141:-cache-poisoning;step3.1-redirect-users-to-malicious-website",
  "type": "scenario",
  "keyword": "Scenario"
});
formatter.step({
  "line": 5,
  "name": "prepare to Redirect users to malicious website",
  "keyword": "Given "
});
formatter.step({
  "line": 6,
  "name": "Try to Redirect users to malicious website",
  "keyword": "When "
});
formatter.step({
  "comments": [
    {
      "line": 7,
      "value": "# assertion for attack step success"
    }
  ],
  "line": 8,
  "name": "Assert the success of Redirect users to malicious website",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 9,
      "value": "#assertions for security pattern testing (checker whether the pattern consequences are observed)"
    }
  ],
  "line": 10,
  "name": "assert the consequences of the pattern",
  "keyword": "Then "
});
formatter.match({
  "location": "redirectuserstomaliciouswebsite.preredirectuserstomaliciouswebsite()"
});
formatter.result({
  "duration": 80425,
  "status": "passed"
});
formatter.match({
  "location": "redirectuserstomaliciouswebsite.tryredirectuserstomaliciouswebsite()"
});
formatter.result({
  "duration": 19803,
  "status": "passed"
});
formatter.match({
  "location": "redirectuserstomaliciouswebsite.assredirectuserstomaliciouswebsite()"
});
formatter.result({
  "duration": 9064,
  "status": "passed"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.uri("CAPEC_142_Step_1_1.feature");
formatter.feature({
  "line": 2,
  "name": "CAPEC-142: DNS Cache Poisoning",
  "description": "",
  "id": "capec-142:-dns-cache-poisoning",
  "keyword": "Feature",
  "tags": [
    {
      "line": 1,
      "name": "@capec142"
    }
  ]
});
formatter.scenario({
  "comments": [
    {
      "line": 3,
      "value": "#1. Explore"
    }
  ],
  "line": 4,
  "name": "Step1.1 Explore resolver caches",
  "description": "",
  "id": "capec-142:-dns-cache-poisoning;step1.1-explore-resolver-caches",
  "type": "scenario",
  "keyword": "Scenario"
});
formatter.step({
  "line": 5,
  "name": "prepare to Explore resolver caches",
  "keyword": "Given "
});
formatter.step({
  "line": 6,
  "name": "Try to Explore resolver caches",
  "keyword": "When "
});
formatter.step({
  "comments": [
    {
      "line": 7,
      "value": "# assertion for attack step success"
    }
  ],
  "line": 8,
  "name": "Assert the success of Explore resolver caches",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 9,
      "value": "#assertions for security pattern testing (checker whether the pattern consequences are observed)"
    }
  ],
  "line": 10,
  "name": "assert the consequences of the pattern secure logger",
  "keyword": "Then "
});
formatter.match({
  "location": "exploreresolvercaches.preexploreresolvercaches()"
});
formatter.result({
  "duration": 58991,
  "status": "passed"
});
formatter.match({
  "location": "exploreresolvercaches.tryexploreresolvercaches()"
});
formatter.result({
  "duration": 14066,
  "status": "passed"
});
formatter.match({
  "location": "exploreresolvercaches.assexploreresolvercaches()"
});
formatter.result({
  "duration": 8923,
  "status": "passed"
});
formatter.match({
  "location": "PatternSteps.asssecurelogger()"
});
formatter.result({
  "duration": 334391,
  "status": "passed"
});
formatter.uri("CAPEC_142_Step_2_1.feature");
formatter.feature({
  "line": 2,
  "name": "CAPEC-142: DNS Cache Poisoning",
  "description": "",
  "id": "capec-142:-dns-cache-poisoning",
  "keyword": "Feature",
  "tags": [
    {
      "line": 1,
      "name": "@capec142"
    }
  ]
});
formatter.scenario({
  "comments": [
    {
      "line": 3,
      "value": "#2. Experiment"
    }
  ],
  "line": 4,
  "name": "Step2.1 Attempt sending crafted records to DNS cache",
  "description": "",
  "id": "capec-142:-dns-cache-poisoning;step2.1-attempt-sending-crafted-records-to-dns-cache",
  "type": "scenario",
  "keyword": "Scenario"
});
formatter.step({
  "line": 5,
  "name": "prepare to Attempt sending crafted records to DNS cache",
  "keyword": "Given "
});
formatter.step({
  "line": 6,
  "name": "Try to Attempt sending crafted records to DNS cache",
  "keyword": "When "
});
formatter.step({
  "comments": [
    {
      "line": 7,
      "value": "# assertion for attack step success"
    }
  ],
  "line": 8,
  "name": "Assert the success of Attempt sending crafted records to DNS cache",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 9,
      "value": "#assertions for security pattern testing (checker whether the pattern consequences are observed)"
    }
  ],
  "line": 10,
  "name": "assert the consequences of the pattern secure logger",
  "keyword": "Then "
});
formatter.match({
  "location": "attemptsendingcraftedrecordstodnscache.preattemptsendingcraftedrecordstodnscache()"
});
formatter.result({
  "duration": 67664,
  "status": "passed"
});
formatter.match({
  "location": "attemptsendingcraftedrecordstodnscache.tryattemptsendingcraftedrecordstodnscache()"
});
formatter.result({
  "duration": 8414,
  "status": "passed"
});
formatter.match({
  "location": "attemptsendingcraftedrecordstodnscache.assattemptsendingcraftedrecordstodnscache()"
});
formatter.result({
  "duration": 8072,
  "status": "passed"
});
formatter.match({
  "location": "PatternSteps.asssecurelogger()"
});
formatter.result({
  "duration": 21141,
  "status": "passed"
});
formatter.uri("CAPEC_142_Step_3_1.feature");
formatter.feature({
  "line": 2,
  "name": "CAPEC-142: DNS Cache Poisoning",
  "description": "",
  "id": "capec-142:-dns-cache-poisoning",
  "keyword": "Feature",
  "tags": [
    {
      "line": 1,
      "name": "@capec142"
    }
  ]
});
formatter.scenario({
  "comments": [
    {
      "line": 3,
      "value": "#3. Exploit"
    }
  ],
  "line": 4,
  "name": "Step3.1 Redirect users to malicious website",
  "description": "",
  "id": "capec-142:-dns-cache-poisoning;step3.1-redirect-users-to-malicious-website",
  "type": "scenario",
  "keyword": "Scenario"
});
formatter.step({
  "line": 5,
  "name": "prepare to Redirect users to malicious website",
  "keyword": "Given "
});
formatter.step({
  "line": 6,
  "name": "Try to Redirect users to malicious website",
  "keyword": "When "
});
formatter.step({
  "comments": [
    {
      "line": 7,
      "value": "# assertion for attack step success"
    }
  ],
  "line": 8,
  "name": "Assert the success of Redirect users to malicious website",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 9,
      "value": "#assertions for security pattern testing (checker whether the pattern consequences are observed)"
    }
  ],
  "line": 10,
  "name": "assert the consequences of the pattern secure logger",
  "keyword": "Then "
});
formatter.step({
  "line": 11,
  "name": "assert the consequences of the pattern",
  "keyword": "Then "
});
formatter.match({
  "location": "redirectuserstomaliciouswebsite.preredirectuserstomaliciouswebsite()"
});
formatter.result({
  "duration": 86024,
  "status": "passed"
});
formatter.match({
  "location": "redirectuserstomaliciouswebsite.tryredirectuserstomaliciouswebsite()"
});
formatter.result({
  "duration": 9461,
  "status": "passed"
});
formatter.match({
  "location": "redirectuserstomaliciouswebsite.assredirectuserstomaliciouswebsite()"
});
formatter.result({
  "duration": 13848,
  "status": "passed"
});
formatter.match({
  "location": "PatternSteps.asssecurelogger()"
});
formatter.result({
  "duration": 12534,
  "status": "passed"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.uri("CAPEC_147_Step_1_1.feature");
formatter.feature({
  "line": 2,
  "name": "CAPEC-147: XML Ping of the Death",
  "description": "",
  "id": "capec-147:-xml-ping-of-the-death",
  "keyword": "Feature",
  "tags": [
    {
      "line": 1,
      "name": "@capec147"
    }
  ]
});
formatter.scenario({
  "comments": [
    {
      "line": 3,
      "value": "#1. Explore"
    }
  ],
  "line": 4,
  "name": "Step1.1 Survey the target",
  "description": "",
  "id": "capec-147:-xml-ping-of-the-death;step1.1-survey-the-target",
  "type": "scenario",
  "keyword": "Scenario"
});
formatter.step({
  "line": 5,
  "name": "prepare to Survey the target",
  "keyword": "Given "
});
formatter.step({
  "line": 6,
  "name": "Try to Survey the target",
  "keyword": "When "
});
formatter.step({
  "comments": [
    {
      "line": 7,
      "value": "# assertion for attack step success"
    }
  ],
  "line": 8,
  "name": "Assert the success of Survey the target",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 9,
      "value": "#assertions for security pattern testing (checker whether the pattern consequences are observed)"
    }
  ],
  "line": 10,
  "name": "assert the consequences of the pattern",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 11,
      "value": "#"
    }
  ],
  "line": 12,
  "name": "assert the consequences of the pattern audit interceptor",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 13,
      "value": "# depends secure logger"
    }
  ],
  "line": 14,
  "name": "assert the consequences of the pattern secure logger",
  "keyword": "Then "
});
formatter.match({
  "location": "survey.presurvey()"
});
formatter.result({
  "duration": 0,
  "error_message": "cucumber.runtime.AmbiguousStepDefinitionsException: ✽.Given prepare to Survey the target(CAPEC_147_Step_1_1.feature:5) matches more than one step definition:\n  prepare to Survey in survey.presurvey()\n  prepare to Survey the target in surveythetarget.presurveythetarget()\n\n\tat cucumber.runtime.RuntimeGlue.stepDefinitionMatch(RuntimeGlue.java:71)\n\tat cucumber.runtime.Runtime.runStep(Runtime.java:265)\n\tat cucumber.runtime.model.StepContainer.runStep(StepContainer.java:44)\n\tat cucumber.runtime.model.StepContainer.runSteps(StepContainer.java:39)\n\tat cucumber.runtime.model.CucumberScenario.run(CucumberScenario.java:48)\n\tat cucumber.runtime.junit.ExecutionUnitRunner.run(ExecutionUnitRunner.java:91)\n\tat cucumber.runtime.junit.FeatureRunner.runChild(FeatureRunner.java:63)\n\tat cucumber.runtime.junit.FeatureRunner.runChild(FeatureRunner.java:18)\n\tat org.junit.runners.ParentRunner$3.run(ParentRunner.java:238)\n\tat org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:63)\n\tat org.junit.runners.ParentRunner.runChildren(ParentRunner.java:236)\n\tat org.junit.runners.ParentRunner.access$000(ParentRunner.java:53)\n\tat org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:229)\n\tat org.junit.runners.ParentRunner.run(ParentRunner.java:309)\n\tat cucumber.runtime.junit.FeatureRunner.run(FeatureRunner.java:70)\n\tat cucumber.api.junit.Cucumber.runChild(Cucumber.java:93)\n\tat cucumber.api.junit.Cucumber.runChild(Cucumber.java:37)\n\tat org.junit.runners.ParentRunner$3.run(ParentRunner.java:238)\n\tat org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:63)\n\tat org.junit.runners.ParentRunner.runChildren(ParentRunner.java:236)\n\tat org.junit.runners.ParentRunner.access$000(ParentRunner.java:53)\n\tat org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:229)\n\tat org.junit.internal.runners.statements.RunAfters.evaluate(RunAfters.java:27)\n\tat org.junit.runners.ParentRunner.run(ParentRunner.java:309)\n\tat cucumber.api.junit.Cucumber.run(Cucumber.java:98)\n\tat org.eclipse.jdt.internal.junit4.runner.JUnit4TestReference.run(JUnit4TestReference.java:86)\n\tat org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:459)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:678)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:382)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:192)\n",
  "status": "failed"
});
formatter.match({
  "location": "survey.trysurvey()"
});
formatter.result({
  "duration": 0,
  "error_message": "cucumber.runtime.AmbiguousStepDefinitionsException: ✽.When Try to Survey the target(CAPEC_147_Step_1_1.feature:6) matches more than one step definition:\n  Try to Survey in survey.trysurvey()\n  Try to Survey the target in surveythetarget.trysurveythetarget()\n\n\tat cucumber.runtime.RuntimeGlue.stepDefinitionMatch(RuntimeGlue.java:71)\n\tat cucumber.runtime.Runtime.runStep(Runtime.java:265)\n\tat cucumber.runtime.model.StepContainer.runStep(StepContainer.java:44)\n\tat cucumber.runtime.model.StepContainer.runSteps(StepContainer.java:39)\n\tat cucumber.runtime.model.CucumberScenario.run(CucumberScenario.java:48)\n\tat cucumber.runtime.junit.ExecutionUnitRunner.run(ExecutionUnitRunner.java:91)\n\tat cucumber.runtime.junit.FeatureRunner.runChild(FeatureRunner.java:63)\n\tat cucumber.runtime.junit.FeatureRunner.runChild(FeatureRunner.java:18)\n\tat org.junit.runners.ParentRunner$3.run(ParentRunner.java:238)\n\tat org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:63)\n\tat org.junit.runners.ParentRunner.runChildren(ParentRunner.java:236)\n\tat org.junit.runners.ParentRunner.access$000(ParentRunner.java:53)\n\tat org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:229)\n\tat org.junit.runners.ParentRunner.run(ParentRunner.java:309)\n\tat cucumber.runtime.junit.FeatureRunner.run(FeatureRunner.java:70)\n\tat cucumber.api.junit.Cucumber.runChild(Cucumber.java:93)\n\tat cucumber.api.junit.Cucumber.runChild(Cucumber.java:37)\n\tat org.junit.runners.ParentRunner$3.run(ParentRunner.java:238)\n\tat org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:63)\n\tat org.junit.runners.ParentRunner.runChildren(ParentRunner.java:236)\n\tat org.junit.runners.ParentRunner.access$000(ParentRunner.java:53)\n\tat org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:229)\n\tat org.junit.internal.runners.statements.RunAfters.evaluate(RunAfters.java:27)\n\tat org.junit.runners.ParentRunner.run(ParentRunner.java:309)\n\tat cucumber.api.junit.Cucumber.run(Cucumber.java:98)\n\tat org.eclipse.jdt.internal.junit4.runner.JUnit4TestReference.run(JUnit4TestReference.java:86)\n\tat org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:459)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:678)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:382)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:192)\n",
  "status": "failed"
});
formatter.match({
  "location": "survey.asssurvey()"
});
formatter.result({
  "duration": 0,
  "error_message": "cucumber.runtime.AmbiguousStepDefinitionsException: ✽.Then Assert the success of Survey the target(CAPEC_147_Step_1_1.feature:8) matches more than one step definition:\n  Assert the success of Survey in survey.asssurvey()\n  Assert the success of Survey the target in surveythetarget.asssurveythetarget()\n\n\tat cucumber.runtime.RuntimeGlue.stepDefinitionMatch(RuntimeGlue.java:71)\n\tat cucumber.runtime.Runtime.runStep(Runtime.java:265)\n\tat cucumber.runtime.model.StepContainer.runStep(StepContainer.java:44)\n\tat cucumber.runtime.model.StepContainer.runSteps(StepContainer.java:39)\n\tat cucumber.runtime.model.CucumberScenario.run(CucumberScenario.java:48)\n\tat cucumber.runtime.junit.ExecutionUnitRunner.run(ExecutionUnitRunner.java:91)\n\tat cucumber.runtime.junit.FeatureRunner.runChild(FeatureRunner.java:63)\n\tat cucumber.runtime.junit.FeatureRunner.runChild(FeatureRunner.java:18)\n\tat org.junit.runners.ParentRunner$3.run(ParentRunner.java:238)\n\tat org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:63)\n\tat org.junit.runners.ParentRunner.runChildren(ParentRunner.java:236)\n\tat org.junit.runners.ParentRunner.access$000(ParentRunner.java:53)\n\tat org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:229)\n\tat org.junit.runners.ParentRunner.run(ParentRunner.java:309)\n\tat cucumber.runtime.junit.FeatureRunner.run(FeatureRunner.java:70)\n\tat cucumber.api.junit.Cucumber.runChild(Cucumber.java:93)\n\tat cucumber.api.junit.Cucumber.runChild(Cucumber.java:37)\n\tat org.junit.runners.ParentRunner$3.run(ParentRunner.java:238)\n\tat org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:63)\n\tat org.junit.runners.ParentRunner.runChildren(ParentRunner.java:236)\n\tat org.junit.runners.ParentRunner.access$000(ParentRunner.java:53)\n\tat org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:229)\n\tat org.junit.internal.runners.statements.RunAfters.evaluate(RunAfters.java:27)\n\tat org.junit.runners.ParentRunner.run(ParentRunner.java:309)\n\tat cucumber.api.junit.Cucumber.run(Cucumber.java:98)\n\tat org.eclipse.jdt.internal.junit4.runner.JUnit4TestReference.run(JUnit4TestReference.java:86)\n\tat org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:459)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:678)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:382)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:192)\n",
  "status": "failed"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({
  "location": "PatternSteps.assauditinterceptor()"
});
formatter.result({
  "status": "skipped"
});
formatter.match({
  "location": "PatternSteps.asssecurelogger()"
});
formatter.result({
  "status": "skipped"
});
formatter.uri("CAPEC_147_Step_2_1.feature");
formatter.feature({
  "line": 2,
  "name": "CAPEC-147: XML Ping of the Death",
  "description": "",
  "id": "capec-147:-xml-ping-of-the-death",
  "keyword": "Feature",
  "tags": [
    {
      "line": 1,
      "name": "@capec147"
    }
  ]
});
formatter.scenario({
  "comments": [
    {
      "line": 3,
      "value": "#2. Exploit"
    }
  ],
  "line": 4,
  "name": "Step2.1 Launch a resource depletion attack",
  "description": "",
  "id": "capec-147:-xml-ping-of-the-death;step2.1-launch-a-resource-depletion-attack",
  "type": "scenario",
  "keyword": "Scenario"
});
formatter.step({
  "line": 5,
  "name": "prepare to Launch a resource depletion attack",
  "keyword": "Given "
});
formatter.step({
  "line": 6,
  "name": "Try to Launch a resource depletion attack",
  "keyword": "When "
});
formatter.step({
  "comments": [
    {
      "line": 7,
      "value": "# assertion for attack step success"
    }
  ],
  "line": 8,
  "name": "Assert the success of Launch a resource depletion attack",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 9,
      "value": "#assertions for security pattern testing (checker whether the pattern consequences are observed)"
    }
  ],
  "line": 10,
  "name": "assert the consequences of the pattern",
  "keyword": "Then "
});
formatter.match({
  "location": "launcharesourcedepletionattack.prelauncharesourcedepletionattack()"
});
formatter.result({
  "duration": 87446,
  "status": "passed"
});
formatter.match({
  "location": "launcharesourcedepletionattack.trylauncharesourcedepletionattack()"
});
formatter.result({
  "duration": 10098,
  "status": "passed"
});
formatter.match({
  "location": "launcharesourcedepletionattack.asslauncharesourcedepletionattack()"
});
formatter.result({
  "duration": 17686,
  "status": "passed"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.uri("CAPEC_14_Step_1_1.feature");
formatter.feature({
  "line": 2,
  "name": "CAPEC-14: Client-side Injection-induced Buffer Overflow",
  "description": "",
  "id": "capec-14:-client-side-injection-induced-buffer-overflow",
  "keyword": "Feature",
  "tags": [
    {
      "line": 1,
      "name": "@capec14"
    }
  ]
});
formatter.scenario({
  "comments": [
    {
      "line": 3,
      "value": "#1. Explore"
    }
  ],
  "line": 4,
  "name": "Step1.1",
  "description": "",
  "id": "capec-14:-client-side-injection-induced-buffer-overflow;step1.1",
  "type": "scenario",
  "keyword": "Scenario"
});
formatter.step({
  "line": 5,
  "name": "prepare to",
  "keyword": "Given "
});
formatter.step({
  "line": 6,
  "name": "Try to",
  "keyword": "When "
});
formatter.step({
  "comments": [
    {
      "line": 7,
      "value": "# assertion for attack step success"
    }
  ],
  "line": 8,
  "name": "Assert the success of",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 9,
      "value": "#assertions for security pattern testing (checker whether the pattern consequences are observed)"
    }
  ],
  "line": 10,
  "name": "assert the consequences of the pattern",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 11,
      "value": "#"
    }
  ],
  "line": 12,
  "name": "assert the consequences of the pattern audit interceptor",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 13,
      "value": "# depends secure logger"
    }
  ],
  "line": 14,
  "name": "assert the consequences of the pattern secure logger",
  "keyword": "Then "
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({
  "location": "PatternSteps.assauditinterceptor()"
});
formatter.result({
  "status": "skipped"
});
formatter.match({
  "location": "PatternSteps.asssecurelogger()"
});
formatter.result({
  "status": "skipped"
});
formatter.uri("CAPEC_14_Step_2_1.feature");
formatter.feature({
  "line": 2,
  "name": "CAPEC-14: Client-side Injection-induced Buffer Overflow",
  "description": "",
  "id": "capec-14:-client-side-injection-induced-buffer-overflow",
  "keyword": "Feature",
  "tags": [
    {
      "line": 1,
      "name": "@capec14"
    }
  ]
});
formatter.scenario({
  "comments": [
    {
      "line": 3,
      "value": "#2. Exploit"
    }
  ],
  "line": 4,
  "name": "Step2.1",
  "description": "",
  "id": "capec-14:-client-side-injection-induced-buffer-overflow;step2.1",
  "type": "scenario",
  "keyword": "Scenario"
});
formatter.step({
  "line": 5,
  "name": "prepare to",
  "keyword": "Given "
});
formatter.step({
  "line": 6,
  "name": "Try to",
  "keyword": "When "
});
formatter.step({
  "comments": [
    {
      "line": 7,
      "value": "# assertion for attack step success"
    }
  ],
  "line": 8,
  "name": "Assert the success of",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 9,
      "value": "#assertions for security pattern testing (checker whether the pattern consequences are observed)"
    }
  ],
  "line": 10,
  "name": "assert the consequences of the pattern",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 11,
      "value": "#"
    }
  ],
  "line": 12,
  "name": "assert the consequences of the pattern audit interceptor",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 13,
      "value": "# depends secure logger"
    }
  ],
  "line": 14,
  "name": "assert the consequences of the pattern secure logger",
  "keyword": "Then "
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({
  "location": "PatternSteps.assauditinterceptor()"
});
formatter.result({
  "status": "skipped"
});
formatter.match({
  "location": "PatternSteps.asssecurelogger()"
});
formatter.result({
  "status": "skipped"
});
formatter.uri("CAPEC_159_Step_1_1.feature");
formatter.feature({
  "line": 2,
  "name": "CAPEC-159: Redirect Access to Libraries",
  "description": "",
  "id": "capec-159:-redirect-access-to-libraries",
  "keyword": "Feature",
  "tags": [
    {
      "line": 1,
      "name": "@capec159"
    }
  ]
});
formatter.scenario({
  "comments": [
    {
      "line": 3,
      "value": "#1. Explore"
    }
  ],
  "line": 4,
  "name": "Step1.1 Identify target general susceptibility",
  "description": "",
  "id": "capec-159:-redirect-access-to-libraries;step1.1-identify-target-general-susceptibility",
  "type": "scenario",
  "keyword": "Scenario"
});
formatter.step({
  "line": 5,
  "name": "prepare to Identify target general susceptibility",
  "keyword": "Given "
});
formatter.step({
  "line": 6,
  "name": "Try to Identify target general susceptibility",
  "keyword": "When "
});
formatter.step({
  "comments": [
    {
      "line": 7,
      "value": "# assertion for attack step success"
    }
  ],
  "line": 8,
  "name": "Assert the success of Identify target general susceptibility",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 9,
      "value": "#assertions for security pattern testing (checker whether the pattern consequences are observed)"
    }
  ],
  "line": 10,
  "name": "assert the consequences of the pattern secure logger",
  "keyword": "Then "
});
formatter.match({
  "location": "identifytargetgeneralsusceptibility.preidentifytargetgeneralsusceptibility()"
});
formatter.result({
  "duration": 85818,
  "status": "passed"
});
formatter.match({
  "location": "identifytargetgeneralsusceptibility.tryidentifytargetgeneralsusceptibility()"
});
formatter.result({
  "duration": 11953,
  "status": "passed"
});
formatter.match({
  "location": "identifytargetgeneralsusceptibility.assidentifytargetgeneralsusceptibility()"
});
formatter.result({
  "duration": 22121,
  "status": "passed"
});
formatter.match({
  "location": "PatternSteps.asssecurelogger()"
});
formatter.result({
  "duration": 348684,
  "status": "passed"
});
formatter.uri("CAPEC_159_Step_2_1.feature");
formatter.feature({
  "line": 2,
  "name": "CAPEC-159: Redirect Access to Libraries",
  "description": "",
  "id": "capec-159:-redirect-access-to-libraries",
  "keyword": "Feature",
  "tags": [
    {
      "line": 1,
      "name": "@capec159"
    }
  ]
});
formatter.scenario({
  "comments": [
    {
      "line": 3,
      "value": "#2. Experiment"
    }
  ],
  "line": 4,
  "name": "Step2.1 Craft malicious libraries",
  "description": "",
  "id": "capec-159:-redirect-access-to-libraries;step2.1-craft-malicious-libraries",
  "type": "scenario",
  "keyword": "Scenario"
});
formatter.step({
  "line": 5,
  "name": "prepare to Craft malicious libraries",
  "keyword": "Given "
});
formatter.step({
  "line": 6,
  "name": "Try to Craft malicious libraries",
  "keyword": "When "
});
formatter.step({
  "comments": [
    {
      "line": 7,
      "value": "# assertion for attack step success"
    }
  ],
  "line": 8,
  "name": "Assert the success of Craft malicious libraries",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 9,
      "value": "#assertions for security pattern testing (checker whether the pattern consequences are observed)"
    }
  ],
  "line": 10,
  "name": "assert the consequences of the pattern secure logger",
  "keyword": "Then "
});
formatter.match({
  "location": "craftmaliciouslibraries.precraftmaliciouslibraries()"
});
formatter.result({
  "duration": 77441,
  "status": "passed"
});
formatter.match({
  "location": "craftmaliciouslibraries.trycraftmaliciouslibraries()"
});
formatter.result({
  "duration": 9333,
  "status": "passed"
});
formatter.match({
  "location": "craftmaliciouslibraries.asscraftmaliciouslibraries()"
});
formatter.result({
  "duration": 11682,
  "status": "passed"
});
formatter.match({
  "location": "PatternSteps.asssecurelogger()"
});
formatter.result({
  "duration": 23902,
  "status": "passed"
});
formatter.uri("CAPEC_159_Step_3_1.feature");
formatter.feature({
  "line": 2,
  "name": "CAPEC-159: Redirect Access to Libraries",
  "description": "",
  "id": "capec-159:-redirect-access-to-libraries",
  "keyword": "Feature",
  "tags": [
    {
      "line": 1,
      "name": "@capec159"
    }
  ]
});
formatter.scenario({
  "comments": [
    {
      "line": 3,
      "value": "#3. Exploit"
    }
  ],
  "line": 4,
  "name": "Step3.1 Redirect the access to libraries to the malicious libraries",
  "description": "",
  "id": "capec-159:-redirect-access-to-libraries;step3.1-redirect-the-access-to-libraries-to-the-malicious-libraries",
  "type": "scenario",
  "keyword": "Scenario"
});
formatter.step({
  "line": 5,
  "name": "prepare to Redirect the access to libraries to the malicious libraries",
  "keyword": "Given "
});
formatter.step({
  "line": 6,
  "name": "Try to Redirect the access to libraries to the malicious libraries",
  "keyword": "When "
});
formatter.step({
  "comments": [
    {
      "line": 7,
      "value": "# assertion for attack step success"
    }
  ],
  "line": 8,
  "name": "Assert the success of Redirect the access to libraries to the malicious libraries",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 9,
      "value": "#assertions for security pattern testing (checker whether the pattern consequences are observed)"
    }
  ],
  "line": 10,
  "name": "assert the consequences of the pattern secure logger",
  "keyword": "Then "
});
formatter.match({
  "location": "redirecttheaccesstolibrariestothemaliciouslibraries.preredirecttheaccesstolibrariestothemaliciouslibraries()"
});
formatter.result({
  "duration": 61537,
  "status": "passed"
});
formatter.match({
  "location": "redirecttheaccesstolibrariestothemaliciouslibraries.tryredirecttheaccesstolibrariestothemaliciouslibraries()"
});
formatter.result({
  "duration": 19077,
  "status": "passed"
});
formatter.match({
  "location": "redirecttheaccesstolibrariestothemaliciouslibraries.assredirecttheaccesstolibrariestothemaliciouslibraries()"
});
formatter.result({
  "duration": 12034,
  "status": "passed"
});
formatter.match({
  "location": "PatternSteps.asssecurelogger()"
});
formatter.result({
  "duration": 14942,
  "status": "passed"
});
formatter.uri("CAPEC_15_Step_1_1.feature");
formatter.feature({
  "line": 2,
  "name": "CAPEC-15: Command Delimiters",
  "description": "",
  "id": "capec-15:-command-delimiters",
  "keyword": "Feature",
  "tags": [
    {
      "line": 1,
      "name": "@capec15"
    }
  ]
});
formatter.scenario({
  "comments": [
    {
      "line": 3,
      "value": "#1. Explore"
    }
  ],
  "line": 4,
  "name": "Step1.1 Assess Target Runtime Environment",
  "description": "",
  "id": "capec-15:-command-delimiters;step1.1-assess-target-runtime-environment",
  "type": "scenario",
  "keyword": "Scenario"
});
formatter.step({
  "line": 5,
  "name": "prepare to Assess Target Runtime Environment",
  "keyword": "Given "
});
formatter.step({
  "line": 6,
  "name": "Try to Assess Target Runtime Environment",
  "keyword": "When "
});
formatter.step({
  "comments": [
    {
      "line": 7,
      "value": "# assertion for attack step success"
    }
  ],
  "line": 8,
  "name": "Assert the success of Assess Target Runtime Environment",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 9,
      "value": "#assertions for security pattern testing (checker whether the pattern consequences are observed)"
    }
  ],
  "line": 10,
  "name": "assert the consequences of the pattern",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 11,
      "value": "#"
    }
  ],
  "line": 12,
  "name": "assert the consequences of the pattern secure logger",
  "keyword": "Then "
});
formatter.match({
  "location": "assesstargetruntimeenvironment.preassesstargetruntimeenvironment()"
});
formatter.result({
  "duration": 50376,
  "status": "passed"
});
formatter.match({
  "location": "assesstargetruntimeenvironment.tryassesstargetruntimeenvironment()"
});
formatter.result({
  "duration": 26585,
  "status": "passed"
});
formatter.match({
  "location": "assesstargetruntimeenvironment.assassesstargetruntimeenvironment()"
});
formatter.result({
  "duration": 9983,
  "status": "passed"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({
  "location": "PatternSteps.asssecurelogger()"
});
formatter.result({
  "status": "skipped"
});
formatter.uri("CAPEC_15_Step_1_2.feature");
formatter.feature({
  "line": 2,
  "name": "CAPEC-15: Command Delimiters",
  "description": "",
  "id": "capec-15:-command-delimiters",
  "keyword": "Feature",
  "tags": [
    {
      "line": 1,
      "name": "@capec15"
    }
  ]
});
formatter.scenario({
  "comments": [
    {
      "line": 3,
      "value": "#1. Explore"
    }
  ],
  "line": 4,
  "name": "Step1.2 Survey the Application",
  "description": "",
  "id": "capec-15:-command-delimiters;step1.2-survey-the-application",
  "type": "scenario",
  "keyword": "Scenario"
});
formatter.step({
  "line": 5,
  "name": "prepare to Survey the Application",
  "keyword": "Given "
});
formatter.step({
  "line": 6,
  "name": "Try to Survey the Application",
  "keyword": "When "
});
formatter.step({
  "comments": [
    {
      "line": 7,
      "value": "# assertion for attack step success"
    }
  ],
  "line": 8,
  "name": "Assert the success of Survey the Application",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 9,
      "value": "#assertions for security pattern testing (checker whether the pattern consequences are observed)"
    }
  ],
  "line": 10,
  "name": "assert the consequences of the pattern",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 11,
      "value": "#"
    }
  ],
  "line": 12,
  "name": "assert the consequences of the pattern audit interceptor",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 13,
      "value": "# depends secure logger"
    }
  ],
  "line": 14,
  "name": "assert the consequences of the pattern secure logger",
  "keyword": "Then "
});
formatter.match({
  "location": "survey.presurvey()"
});
formatter.result({
  "duration": 2478400,
  "error_message": "net.continuumsecurity.proxy.ProxyException: org.zaproxy.clientapi.core.ClientApiException: java.net.ConnectException: Connection refused\n\tat net.continuumsecurity.proxy.ZAProxyScanner.validateMinimumRequiredZapVersion(ZAProxyScanner.java:96)\n\tat net.continuumsecurity.proxy.ZAProxyScanner.\u003cinit\u003e(ZAProxyScanner.java:38)\n\tat steps.survey.presurvey(survey.java:17)\n\tat ✽.Given prepare to Survey the Application(CAPEC_15_Step_1_2.feature:5)\nCaused by: org.zaproxy.clientapi.core.ClientApiException: java.net.ConnectException: Connection refused\n\tat org.zaproxy.clientapi.core.ClientApi.callApiDom(ClientApi.java:307)\n\tat org.zaproxy.clientapi.core.ClientApi.callApi(ClientApi.java:289)\n\tat org.zaproxy.clientapi.gen.Core.version(Core.java:158)\n\tat net.continuumsecurity.proxy.ZAProxyScanner.validateMinimumRequiredZapVersion(ZAProxyScanner.java:85)\n\tat net.continuumsecurity.proxy.ZAProxyScanner.\u003cinit\u003e(ZAProxyScanner.java:38)\n\tat steps.survey.presurvey(survey.java:17)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.lang.reflect.Method.invoke(Method.java:498)\n\tat cucumber.runtime.Utils$1.call(Utils.java:37)\n\tat cucumber.runtime.Timeout.timeout(Timeout.java:13)\n\tat cucumber.runtime.Utils.invoke(Utils.java:31)\n\tat cucumber.runtime.java.JavaStepDefinition.execute(JavaStepDefinition.java:37)\n\tat cucumber.runtime.StepDefinitionMatch.runStep(StepDefinitionMatch.java:37)\n\tat cucumber.runtime.Runtime.runStep(Runtime.java:298)\n\tat cucumber.runtime.model.StepContainer.runStep(StepContainer.java:44)\n\tat cucumber.runtime.model.StepContainer.runSteps(StepContainer.java:39)\n\tat cucumber.runtime.model.CucumberScenario.run(CucumberScenario.java:48)\n\tat cucumber.runtime.junit.ExecutionUnitRunner.run(ExecutionUnitRunner.java:91)\n\tat cucumber.runtime.junit.FeatureRunner.runChild(FeatureRunner.java:63)\n\tat cucumber.runtime.junit.FeatureRunner.runChild(FeatureRunner.java:18)\n\tat org.junit.runners.ParentRunner$3.run(ParentRunner.java:238)\n\tat org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:63)\n\tat org.junit.runners.ParentRunner.runChildren(ParentRunner.java:236)\n\tat org.junit.runners.ParentRunner.access$000(ParentRunner.java:53)\n\tat org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:229)\n\tat org.junit.runners.ParentRunner.run(ParentRunner.java:309)\n\tat cucumber.runtime.junit.FeatureRunner.run(FeatureRunner.java:70)\n\tat cucumber.api.junit.Cucumber.runChild(Cucumber.java:93)\n\tat cucumber.api.junit.Cucumber.runChild(Cucumber.java:37)\n\tat org.junit.runners.ParentRunner$3.run(ParentRunner.java:238)\n\tat org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:63)\n\tat org.junit.runners.ParentRunner.runChildren(ParentRunner.java:236)\n\tat org.junit.runners.ParentRunner.access$000(ParentRunner.java:53)\n\tat org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:229)\n\tat org.junit.internal.runners.statements.RunAfters.evaluate(RunAfters.java:27)\n\tat org.junit.runners.ParentRunner.run(ParentRunner.java:309)\n\tat cucumber.api.junit.Cucumber.run(Cucumber.java:98)\n\tat org.eclipse.jdt.internal.junit4.runner.JUnit4TestReference.run(JUnit4TestReference.java:86)\n\tat org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:459)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:678)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:382)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:192)\nCaused by: java.net.ConnectException: Connection refused\n\tat java.net.PlainSocketImpl.socketConnect(Native Method)\n\tat java.net.AbstractPlainSocketImpl.doConnect(AbstractPlainSocketImpl.java:350)\n\tat java.net.AbstractPlainSocketImpl.connectToAddress(AbstractPlainSocketImpl.java:206)\n\tat java.net.AbstractPlainSocketImpl.connect(AbstractPlainSocketImpl.java:188)\n\tat java.net.Socket.connect(Socket.java:589)\n\tat java.net.Socket.connect(Socket.java:538)\n\tat sun.net.NetworkClient.doConnect(NetworkClient.java:180)\n\tat sun.net.www.http.HttpClient.openServer(HttpClient.java:432)\n\tat sun.net.www.http.HttpClient$1.run(HttpClient.java:484)\n\tat sun.net.www.http.HttpClient$1.run(HttpClient.java:482)\n\tat java.security.AccessController.doPrivileged(Native Method)\n\tat sun.net.www.http.HttpClient.privilegedOpenServer(HttpClient.java:481)\n\tat sun.net.www.http.HttpClient.openServer(HttpClient.java:522)\n\tat sun.net.www.http.HttpClient.\u003cinit\u003e(HttpClient.java:211)\n\tat sun.net.www.http.HttpClient.New(HttpClient.java:308)\n\tat sun.net.www.http.HttpClient.New(HttpClient.java:326)\n\tat sun.net.www.protocol.http.HttpURLConnection.getNewHttpClient(HttpURLConnection.java:1169)\n\tat sun.net.www.protocol.http.HttpURLConnection.plainConnect0(HttpURLConnection.java:1148)\n\tat sun.net.www.protocol.http.HttpURLConnection.plainConnect(HttpURLConnection.java:999)\n\tat sun.net.www.protocol.http.HttpURLConnection.connect(HttpURLConnection.java:933)\n\tat org.zaproxy.clientapi.core.ClientApi.getConnectionInputStream(ClientApi.java:313)\n\tat org.zaproxy.clientapi.core.ClientApi.callApiDom(ClientApi.java:305)\n\t... 44 more\n",
  "status": "failed"
});
formatter.match({
  "location": "survey.trysurvey()"
});
formatter.result({
  "status": "skipped"
});
formatter.match({
  "location": "survey.asssurvey()"
});
formatter.result({
  "status": "skipped"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({
  "location": "PatternSteps.assauditinterceptor()"
});
formatter.result({
  "status": "skipped"
});
formatter.match({
  "location": "PatternSteps.asssecurelogger()"
});
formatter.result({
  "status": "skipped"
});
formatter.uri("CAPEC_15_Step_2_1.feature");
formatter.feature({
  "line": 2,
  "name": "CAPEC-15: Command Delimiters",
  "description": "",
  "id": "capec-15:-command-delimiters",
  "keyword": "Feature",
  "tags": [
    {
      "line": 1,
      "name": "@capec15"
    }
  ]
});
formatter.scenario({
  "comments": [
    {
      "line": 3,
      "value": "#2. Experiment"
    }
  ],
  "line": 4,
  "name": "Step2.1 Attempt delimiters in inputs",
  "description": "",
  "id": "capec-15:-command-delimiters;step2.1-attempt-delimiters-in-inputs",
  "type": "scenario",
  "keyword": "Scenario"
});
formatter.step({
  "line": 5,
  "name": "prepare to Attempt delimiters in inputs",
  "keyword": "Given "
});
formatter.step({
  "line": 6,
  "name": "Try to Attempt delimiters in inputs",
  "keyword": "When "
});
formatter.step({
  "comments": [
    {
      "line": 7,
      "value": "# assertion for attack step success"
    }
  ],
  "line": 8,
  "name": "Assert the success of Attempt delimiters in inputs",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 9,
      "value": "#assertions for security pattern testing (checker whether the pattern consequences are observed)"
    }
  ],
  "line": 10,
  "name": "assert the consequences of the pattern",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 11,
      "value": "#"
    }
  ],
  "line": 12,
  "name": "assert the consequences of the pattern audit interceptor",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 13,
      "value": "# depends secure logger"
    }
  ],
  "line": 14,
  "name": "assert the consequences of the pattern secure logger",
  "keyword": "Then "
});
formatter.match({
  "location": "attemptdelimitersininputs.preattemptdelimitersininputs()"
});
formatter.result({
  "duration": 2240666,
  "error_message": "net.continuumsecurity.proxy.ProxyException: org.zaproxy.clientapi.core.ClientApiException: java.net.ConnectException: Connection refused\n\tat net.continuumsecurity.proxy.ZAProxyScanner.validateMinimumRequiredZapVersion(ZAProxyScanner.java:96)\n\tat net.continuumsecurity.proxy.ZAProxyScanner.\u003cinit\u003e(ZAProxyScanner.java:38)\n\tat steps.attemptdelimitersininputs.preattemptdelimitersininputs(attemptdelimitersininputs.java:24)\n\tat ✽.Given prepare to Attempt delimiters in inputs(CAPEC_15_Step_2_1.feature:5)\nCaused by: org.zaproxy.clientapi.core.ClientApiException: java.net.ConnectException: Connection refused\n\tat org.zaproxy.clientapi.core.ClientApi.callApiDom(ClientApi.java:307)\n\tat org.zaproxy.clientapi.core.ClientApi.callApi(ClientApi.java:289)\n\tat org.zaproxy.clientapi.gen.Core.version(Core.java:158)\n\tat net.continuumsecurity.proxy.ZAProxyScanner.validateMinimumRequiredZapVersion(ZAProxyScanner.java:85)\n\tat net.continuumsecurity.proxy.ZAProxyScanner.\u003cinit\u003e(ZAProxyScanner.java:38)\n\tat steps.attemptdelimitersininputs.preattemptdelimitersininputs(attemptdelimitersininputs.java:24)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.lang.reflect.Method.invoke(Method.java:498)\n\tat cucumber.runtime.Utils$1.call(Utils.java:37)\n\tat cucumber.runtime.Timeout.timeout(Timeout.java:13)\n\tat cucumber.runtime.Utils.invoke(Utils.java:31)\n\tat cucumber.runtime.java.JavaStepDefinition.execute(JavaStepDefinition.java:37)\n\tat cucumber.runtime.StepDefinitionMatch.runStep(StepDefinitionMatch.java:37)\n\tat cucumber.runtime.Runtime.runStep(Runtime.java:298)\n\tat cucumber.runtime.model.StepContainer.runStep(StepContainer.java:44)\n\tat cucumber.runtime.model.StepContainer.runSteps(StepContainer.java:39)\n\tat cucumber.runtime.model.CucumberScenario.run(CucumberScenario.java:48)\n\tat cucumber.runtime.junit.ExecutionUnitRunner.run(ExecutionUnitRunner.java:91)\n\tat cucumber.runtime.junit.FeatureRunner.runChild(FeatureRunner.java:63)\n\tat cucumber.runtime.junit.FeatureRunner.runChild(FeatureRunner.java:18)\n\tat org.junit.runners.ParentRunner$3.run(ParentRunner.java:238)\n\tat org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:63)\n\tat org.junit.runners.ParentRunner.runChildren(ParentRunner.java:236)\n\tat org.junit.runners.ParentRunner.access$000(ParentRunner.java:53)\n\tat org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:229)\n\tat org.junit.runners.ParentRunner.run(ParentRunner.java:309)\n\tat cucumber.runtime.junit.FeatureRunner.run(FeatureRunner.java:70)\n\tat cucumber.api.junit.Cucumber.runChild(Cucumber.java:93)\n\tat cucumber.api.junit.Cucumber.runChild(Cucumber.java:37)\n\tat org.junit.runners.ParentRunner$3.run(ParentRunner.java:238)\n\tat org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:63)\n\tat org.junit.runners.ParentRunner.runChildren(ParentRunner.java:236)\n\tat org.junit.runners.ParentRunner.access$000(ParentRunner.java:53)\n\tat org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:229)\n\tat org.junit.internal.runners.statements.RunAfters.evaluate(RunAfters.java:27)\n\tat org.junit.runners.ParentRunner.run(ParentRunner.java:309)\n\tat cucumber.api.junit.Cucumber.run(Cucumber.java:98)\n\tat org.eclipse.jdt.internal.junit4.runner.JUnit4TestReference.run(JUnit4TestReference.java:86)\n\tat org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:459)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:678)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:382)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:192)\nCaused by: java.net.ConnectException: Connection refused\n\tat java.net.PlainSocketImpl.socketConnect(Native Method)\n\tat java.net.AbstractPlainSocketImpl.doConnect(AbstractPlainSocketImpl.java:350)\n\tat java.net.AbstractPlainSocketImpl.connectToAddress(AbstractPlainSocketImpl.java:206)\n\tat java.net.AbstractPlainSocketImpl.connect(AbstractPlainSocketImpl.java:188)\n\tat java.net.Socket.connect(Socket.java:589)\n\tat java.net.Socket.connect(Socket.java:538)\n\tat sun.net.NetworkClient.doConnect(NetworkClient.java:180)\n\tat sun.net.www.http.HttpClient.openServer(HttpClient.java:432)\n\tat sun.net.www.http.HttpClient$1.run(HttpClient.java:484)\n\tat sun.net.www.http.HttpClient$1.run(HttpClient.java:482)\n\tat java.security.AccessController.doPrivileged(Native Method)\n\tat sun.net.www.http.HttpClient.privilegedOpenServer(HttpClient.java:481)\n\tat sun.net.www.http.HttpClient.openServer(HttpClient.java:522)\n\tat sun.net.www.http.HttpClient.\u003cinit\u003e(HttpClient.java:211)\n\tat sun.net.www.http.HttpClient.New(HttpClient.java:308)\n\tat sun.net.www.http.HttpClient.New(HttpClient.java:326)\n\tat sun.net.www.protocol.http.HttpURLConnection.getNewHttpClient(HttpURLConnection.java:1169)\n\tat sun.net.www.protocol.http.HttpURLConnection.plainConnect0(HttpURLConnection.java:1148)\n\tat sun.net.www.protocol.http.HttpURLConnection.plainConnect(HttpURLConnection.java:999)\n\tat sun.net.www.protocol.http.HttpURLConnection.connect(HttpURLConnection.java:933)\n\tat org.zaproxy.clientapi.core.ClientApi.getConnectionInputStream(ClientApi.java:313)\n\tat org.zaproxy.clientapi.core.ClientApi.callApiDom(ClientApi.java:305)\n\t... 44 more\n",
  "status": "failed"
});
formatter.match({
  "location": "attemptdelimitersininputs.tryattemptdelimitersininputs()"
});
formatter.result({
  "status": "skipped"
});
formatter.match({
  "location": "attemptdelimitersininputs.assattemptdelimitersininputs()"
});
formatter.result({
  "status": "skipped"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({
  "location": "PatternSteps.assauditinterceptor()"
});
formatter.result({
  "status": "skipped"
});
formatter.match({
  "location": "PatternSteps.asssecurelogger()"
});
formatter.result({
  "status": "skipped"
});
formatter.uri("CAPEC_15_Step_3_1.feature");
formatter.feature({
  "line": 2,
  "name": "CAPEC-15: Command Delimiters",
  "description": "",
  "id": "capec-15:-command-delimiters",
  "keyword": "Feature",
  "tags": [
    {
      "line": 1,
      "name": "@capec15"
    }
  ]
});
formatter.scenario({
  "comments": [
    {
      "line": 3,
      "value": "#3. Exploit"
    }
  ],
  "line": 4,
  "name": "Step3.1 Use malicious command delimiters",
  "description": "",
  "id": "capec-15:-command-delimiters;step3.1-use-malicious-command-delimiters",
  "type": "scenario",
  "keyword": "Scenario"
});
formatter.step({
  "line": 5,
  "name": "prepare to Use malicious command delimiters",
  "keyword": "Given "
});
formatter.step({
  "line": 6,
  "name": "Try to Use malicious command delimiters",
  "keyword": "When "
});
formatter.step({
  "comments": [
    {
      "line": 7,
      "value": "# assertion for attack step success"
    }
  ],
  "line": 8,
  "name": "Assert the success of Use malicious command delimiters",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 9,
      "value": "#assertions for security pattern testing (checker whether the pattern consequences are observed)"
    }
  ],
  "line": 10,
  "name": "assert the consequences of the pattern secure logger",
  "keyword": "Then "
});
formatter.step({
  "line": 11,
  "name": "assert the consequences of the pattern application firewall",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 12,
      "value": "# alternative input guard"
    }
  ],
  "line": 13,
  "name": "assert the consequences of the pattern input guard",
  "keyword": "Then "
});
formatter.match({
  "location": "usemaliciouscommanddelimiters.preusemaliciouscommanddelimiters()"
});
formatter.result({
  "duration": 85736,
  "status": "passed"
});
formatter.match({
  "location": "usemaliciouscommanddelimiters.tryusemaliciouscommanddelimiters()"
});
formatter.result({
  "duration": 14973,
  "status": "passed"
});
formatter.match({
  "location": "usemaliciouscommanddelimiters.assusemaliciouscommanddelimiters()"
});
formatter.result({
  "duration": 14487,
  "status": "passed"
});
formatter.match({
  "location": "PatternSteps.asssecurelogger()"
});
formatter.result({
  "duration": 23047,
  "status": "passed"
});
formatter.match({
  "location": "PatternSteps.assapplicationfirewall()"
});
formatter.result({
  "duration": 15860,
  "status": "passed"
});
formatter.match({
  "location": "PatternSteps.assinputguard()"
});
formatter.result({
  "duration": 11206,
  "status": "passed"
});
formatter.uri("CAPEC_163_Step_1_1.feature");
formatter.feature({
  "line": 2,
  "name": "CAPEC-163: Spear Phishing",
  "description": "",
  "id": "capec-163:-spear-phishing",
  "keyword": "Feature",
  "tags": [
    {
      "line": 1,
      "name": "@capec163"
    }
  ]
});
formatter.scenario({
  "comments": [
    {
      "line": 3,
      "value": "#1. Explore"
    }
  ],
  "line": 4,
  "name": "Step1.1 Obtain useful contextual detailed information about the targeted user or organization",
  "description": "",
  "id": "capec-163:-spear-phishing;step1.1-obtain-useful-contextual-detailed-information-about-the-targeted-user-or-organization",
  "type": "scenario",
  "keyword": "Scenario"
});
formatter.step({
  "line": 5,
  "name": "prepare to Obtain useful contextual detailed information about the targeted user or organization",
  "keyword": "Given "
});
formatter.step({
  "line": 6,
  "name": "Try to Obtain useful contextual detailed information about the targeted user or organization",
  "keyword": "When "
});
formatter.step({
  "comments": [
    {
      "line": 7,
      "value": "# assertion for attack step success"
    }
  ],
  "line": 8,
  "name": "Assert the success of Obtain useful contextual detailed information about the targeted user or organization",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 9,
      "value": "#assertions for security pattern testing (checker whether the pattern consequences are observed)"
    }
  ],
  "line": 10,
  "name": "assert the consequences of the pattern",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 11,
      "value": "#"
    }
  ],
  "line": 12,
  "name": "assert the consequences of the pattern audit interceptor",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 13,
      "value": "# depends secure logger"
    }
  ],
  "line": 14,
  "name": "assert the consequences of the pattern secure logger",
  "keyword": "Then "
});
formatter.match({
  "location": "obtainusefulcontextualdetailedinformationaboutthetargeteduserororganization.preobtainusefulcontextualdetailedinformationaboutthetargeteduserororganization()"
});
formatter.result({
  "duration": 67875,
  "status": "passed"
});
formatter.match({
  "location": "obtainusefulcontextualdetailedinformationaboutthetargeteduserororganization.tryobtainusefulcontextualdetailedinformationaboutthetargeteduserororganization()"
});
formatter.result({
  "duration": 13303,
  "status": "passed"
});
formatter.match({
  "location": "obtainusefulcontextualdetailedinformationaboutthetargeteduserororganization.assobtainusefulcontextualdetailedinformationaboutthetargeteduserororganization()"
});
formatter.result({
  "duration": 12018,
  "status": "passed"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({
  "location": "PatternSteps.assauditinterceptor()"
});
formatter.result({
  "status": "skipped"
});
formatter.match({
  "location": "PatternSteps.asssecurelogger()"
});
formatter.result({
  "status": "skipped"
});
formatter.uri("CAPEC_163_Step_2_1.feature");
formatter.feature({
  "line": 2,
  "name": "CAPEC-163: Spear Phishing",
  "description": "",
  "id": "capec-163:-spear-phishing",
  "keyword": "Feature",
  "tags": [
    {
      "line": 1,
      "name": "@capec163"
    }
  ]
});
formatter.scenario({
  "comments": [
    {
      "line": 3,
      "value": "#2. Experiment"
    }
  ],
  "line": 4,
  "name": "Step2.1 Optional: Obtain domain name and certificate to spoof legitimate site",
  "description": "",
  "id": "capec-163:-spear-phishing;step2.1-optional:-obtain-domain-name-and-certificate-to-spoof-legitimate-site",
  "type": "scenario",
  "keyword": "Scenario"
});
formatter.step({
  "line": 5,
  "name": "prepare to Optional: Obtain domain name and certificate to spoof legitimate site",
  "keyword": "Given "
});
formatter.step({
  "line": 6,
  "name": "Try to Optional: Obtain domain name and certificate to spoof legitimate site",
  "keyword": "When "
});
formatter.step({
  "comments": [
    {
      "line": 7,
      "value": "# assertion for attack step success"
    }
  ],
  "line": 8,
  "name": "Assert the success of Optional: Obtain domain name and certificate to spoof legitimate site",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 9,
      "value": "#assertions for security pattern testing (checker whether the pattern consequences are observed)"
    }
  ],
  "line": 10,
  "name": "assert the consequences of the pattern",
  "keyword": "Then "
});
formatter.match({
  "location": "optionalobtaindomainnameandcertificatetospooflegitimatesite.preoptionalobtaindomainnameandcertificatetospooflegitimatesite()"
});
formatter.result({
  "duration": 68828,
  "status": "passed"
});
formatter.match({
  "location": "optionalobtaindomainnameandcertificatetospooflegitimatesite.tryoptionalobtaindomainnameandcertificatetospooflegitimatesite()"
});
formatter.result({
  "duration": 11816,
  "status": "passed"
});
formatter.match({
  "location": "optionalobtaindomainnameandcertificatetospooflegitimatesite.assoptionalobtaindomainnameandcertificatetospooflegitimatesite()"
});
formatter.result({
  "duration": 11647,
  "status": "passed"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.uri("CAPEC_163_Step_2_2.feature");
formatter.feature({
  "line": 2,
  "name": "CAPEC-163: Spear Phishing",
  "description": "",
  "id": "capec-163:-spear-phishing",
  "keyword": "Feature",
  "tags": [
    {
      "line": 1,
      "name": "@capec163"
    }
  ]
});
formatter.scenario({
  "comments": [
    {
      "line": 3,
      "value": "#2. Experiment"
    }
  ],
  "line": 4,
  "name": "Step2.2 Optional: Explore legitimate website and create duplicate",
  "description": "",
  "id": "capec-163:-spear-phishing;step2.2-optional:-explore-legitimate-website-and-create-duplicate",
  "type": "scenario",
  "keyword": "Scenario"
});
formatter.step({
  "line": 5,
  "name": "prepare to Optional: Explore legitimate website and create duplicate",
  "keyword": "Given "
});
formatter.step({
  "line": 6,
  "name": "Try to Optional: Explore legitimate website and create duplicate",
  "keyword": "When "
});
formatter.step({
  "comments": [
    {
      "line": 7,
      "value": "# assertion for attack step success"
    }
  ],
  "line": 8,
  "name": "Assert the success of Optional: Explore legitimate website and create duplicate",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 9,
      "value": "#assertions for security pattern testing (checker whether the pattern consequences are observed)"
    }
  ],
  "line": 10,
  "name": "assert the consequences of the pattern",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 11,
      "value": "#"
    }
  ],
  "line": 12,
  "name": "assert the consequences of the pattern audit interceptor",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 13,
      "value": "# depends secure logger"
    }
  ],
  "line": 14,
  "name": "assert the consequences of the pattern secure logger",
  "keyword": "Then "
});
formatter.match({
  "location": "optionalexplorelegitimatewebsiteandcreateduplicate.preoptionalexplorelegitimatewebsiteandcreateduplicate()"
});
formatter.result({
  "duration": 78603,
  "status": "passed"
});
formatter.match({
  "location": "optionalexplorelegitimatewebsiteandcreateduplicate.tryoptionalexplorelegitimatewebsiteandcreateduplicate()"
});
formatter.result({
  "duration": 12208,
  "status": "passed"
});
formatter.match({
  "location": "optionalexplorelegitimatewebsiteandcreateduplicate.assoptionalexplorelegitimatewebsiteandcreateduplicate()"
});
formatter.result({
  "duration": 11270,
  "status": "passed"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({
  "location": "PatternSteps.assauditinterceptor()"
});
formatter.result({
  "status": "skipped"
});
formatter.match({
  "location": "PatternSteps.asssecurelogger()"
});
formatter.result({
  "status": "skipped"
});
formatter.uri("CAPEC_163_Step_2_3.feature");
formatter.feature({
  "line": 2,
  "name": "CAPEC-163: Spear Phishing",
  "description": "",
  "id": "capec-163:-spear-phishing",
  "keyword": "Feature",
  "tags": [
    {
      "line": 1,
      "name": "@capec163"
    }
  ]
});
formatter.scenario({
  "comments": [
    {
      "line": 3,
      "value": "#2. Experiment"
    }
  ],
  "line": 4,
  "name": "Step2.3 Optional: Build variants of the website with very specific user information e.g., living area, etc.",
  "description": "",
  "id": "capec-163:-spear-phishing;step2.3-optional:-build-variants-of-the-website-with-very-specific-user-information-e.g.,-living-area,-etc.",
  "type": "scenario",
  "keyword": "Scenario"
});
formatter.step({
  "line": 5,
  "name": "prepare to Optional: Build variants of the website with very specific user information e.g., living area, etc.",
  "keyword": "Given "
});
formatter.step({
  "line": 6,
  "name": "Try to Optional: Build variants of the website with very specific user information e.g., living area, etc.",
  "keyword": "When "
});
formatter.step({
  "comments": [
    {
      "line": 7,
      "value": "# assertion for attack step success"
    }
  ],
  "line": 8,
  "name": "Assert the success of Optional: Build variants of the website with very specific user information e.g., living area, etc.",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 9,
      "value": "#assertions for security pattern testing (checker whether the pattern consequences are observed)"
    }
  ],
  "line": 10,
  "name": "assert the consequences of the pattern",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 11,
      "value": "#"
    }
  ],
  "line": 12,
  "name": "assert the consequences of the pattern audit interceptor",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 13,
      "value": "# depends secure logger"
    }
  ],
  "line": 14,
  "name": "assert the consequences of the pattern secure logger",
  "keyword": "Then "
});
formatter.match({
  "location": "optionalbuildvariantsofthewebsitewithveryspecificuserinformationeglivingareaetc.preoptionalbuildvariantsofthewebsitewithveryspecificuserinformationeglivingareaetc()"
});
formatter.result({
  "duration": 69723,
  "status": "passed"
});
formatter.match({
  "location": "optionalbuildvariantsofthewebsitewithveryspecificuserinformationeglivingareaetc.tryoptionalbuildvariantsofthewebsitewithveryspecificuserinformationeglivingareaetc()"
});
formatter.result({
  "duration": 11474,
  "status": "passed"
});
formatter.match({
  "location": "optionalbuildvariantsofthewebsitewithveryspecificuserinformationeglivingareaetc.assoptionalbuildvariantsofthewebsitewithveryspecificuserinformationeglivingareaetc()"
});
formatter.result({
  "duration": 9229,
  "status": "passed"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({
  "location": "PatternSteps.assauditinterceptor()"
});
formatter.result({
  "status": "skipped"
});
formatter.match({
  "location": "PatternSteps.asssecurelogger()"
});
formatter.result({
  "status": "skipped"
});
formatter.uri("CAPEC_163_Step_3_1.feature");
formatter.feature({
  "line": 2,
  "name": "CAPEC-163: Spear Phishing",
  "description": "",
  "id": "capec-163:-spear-phishing",
  "keyword": "Feature",
  "tags": [
    {
      "line": 1,
      "name": "@capec163"
    }
  ]
});
formatter.scenario({
  "comments": [
    {
      "line": 3,
      "value": "#3. Exploit"
    }
  ],
  "line": 4,
  "name": "Step3.1 Convince user to enter sensitive information on attacker\u0027s site.",
  "description": "",
  "id": "capec-163:-spear-phishing;step3.1-convince-user-to-enter-sensitive-information-on-attacker\u0027s-site.",
  "type": "scenario",
  "keyword": "Scenario"
});
formatter.step({
  "line": 5,
  "name": "prepare to Convince user to enter sensitive information on attacker\u0027s site.",
  "keyword": "Given "
});
formatter.step({
  "line": 6,
  "name": "Try to Convince user to enter sensitive information on attacker\u0027s site.",
  "keyword": "When "
});
formatter.step({
  "comments": [
    {
      "line": 7,
      "value": "# assertion for attack step success"
    }
  ],
  "line": 8,
  "name": "Assert the success of Convince user to enter sensitive information on attacker\u0027s site.",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 9,
      "value": "#assertions for security pattern testing (checker whether the pattern consequences are observed)"
    }
  ],
  "line": 10,
  "name": "assert the consequences of the pattern secure logger",
  "keyword": "Then "
});
formatter.match({
  "location": "convinceusertoentersensitiveinformationonattackerssite.preconvinceusertoentersensitiveinformationonattackerssite()"
});
formatter.result({
  "duration": 74260,
  "status": "passed"
});
formatter.match({
  "location": "convinceusertoentersensitiveinformationonattackerssite.tryconvinceusertoentersensitiveinformationonattackerssite()"
});
formatter.result({
  "duration": 18826,
  "status": "passed"
});
formatter.match({
  "location": "convinceusertoentersensitiveinformationonattackerssite.assconvinceusertoentersensitiveinformationonattackerssite()"
});
formatter.result({
  "duration": 15405,
  "status": "passed"
});
formatter.match({
  "location": "PatternSteps.asssecurelogger()"
});
formatter.result({
  "duration": 23523,
  "status": "passed"
});
formatter.uri("CAPEC_163_Step_3_2.feature");
formatter.feature({
  "line": 2,
  "name": "CAPEC-163: Spear Phishing",
  "description": "",
  "id": "capec-163:-spear-phishing",
  "keyword": "Feature",
  "tags": [
    {
      "line": 1,
      "name": "@capec163"
    }
  ]
});
formatter.scenario({
  "comments": [
    {
      "line": 3,
      "value": "#3. Exploit"
    }
  ],
  "line": 4,
  "name": "Step3.2 Use stolen credentials to log into legitimate site",
  "description": "",
  "id": "capec-163:-spear-phishing;step3.2-use-stolen-credentials-to-log-into-legitimate-site",
  "type": "scenario",
  "keyword": "Scenario"
});
formatter.step({
  "line": 5,
  "name": "prepare to Use stolen credentials to log into legitimate site",
  "keyword": "Given "
});
formatter.step({
  "line": 6,
  "name": "Try to Use stolen credentials to log into legitimate site",
  "keyword": "When "
});
formatter.step({
  "comments": [
    {
      "line": 7,
      "value": "# assertion for attack step success"
    }
  ],
  "line": 8,
  "name": "Assert the success of Use stolen credentials to log into legitimate site",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 9,
      "value": "#assertions for security pattern testing (checker whether the pattern consequences are observed)"
    }
  ],
  "line": 10,
  "name": "assert the consequences of the pattern",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 11,
      "value": "#"
    }
  ],
  "line": 12,
  "name": "assert the consequences of the pattern secure logger",
  "keyword": "Then "
});
formatter.match({
  "location": "usestolencredentialstologintolegitimatesite.preusestolencredentialstologintolegitimatesite()"
});
formatter.result({
  "duration": 70056,
  "status": "passed"
});
formatter.match({
  "location": "usestolencredentialstologintolegitimatesite.tryusestolencredentialstologintolegitimatesite()"
});
formatter.result({
  "duration": 17626,
  "status": "passed"
});
formatter.match({
  "location": "usestolencredentialstologintolegitimatesite.assusestolencredentialstologintolegitimatesite()"
});
formatter.result({
  "duration": 10349,
  "status": "passed"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({
  "location": "PatternSteps.asssecurelogger()"
});
formatter.result({
  "status": "skipped"
});
formatter.uri("CAPEC_169_Step_1_1.feature");
formatter.feature({
  "line": 2,
  "name": "CAPEC-169: Footprinting",
  "description": "",
  "id": "capec-169:-footprinting",
  "keyword": "Feature",
  "tags": [
    {
      "line": 1,
      "name": "@capec169"
    }
  ]
});
formatter.scenario({
  "comments": [
    {
      "line": 3,
      "value": "#1. Explore"
    }
  ],
  "line": 4,
  "name": "Step1.1 Request Footprinting",
  "description": "",
  "id": "capec-169:-footprinting;step1.1-request-footprinting",
  "type": "scenario",
  "keyword": "Scenario"
});
formatter.step({
  "line": 5,
  "name": "prepare to Request Footprinting",
  "keyword": "Given "
});
formatter.step({
  "line": 6,
  "name": "Try to Request Footprinting",
  "keyword": "When "
});
formatter.step({
  "comments": [
    {
      "line": 7,
      "value": "# assertion for attack step success"
    }
  ],
  "line": 8,
  "name": "Assert the success of Request Footprinting",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 9,
      "value": "#assertions for security pattern testing (checker whether the pattern consequences are observed)"
    }
  ],
  "line": 10,
  "name": "assert the consequences of the pattern",
  "keyword": "Then "
});
formatter.match({
  "location": "requestfootprinting.prerequestfootprinting()"
});
formatter.result({
  "duration": 51019,
  "status": "passed"
});
formatter.match({
  "location": "requestfootprinting.tryrequestfootprinting()"
});
formatter.result({
  "duration": 16073,
  "status": "passed"
});
formatter.match({
  "location": "requestfootprinting.assrequestfootprinting()"
});
formatter.result({
  "duration": 12261,
  "status": "passed"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.uri("CAPEC_16_Step_1_1.feature");
formatter.feature({
  "line": 2,
  "name": "CAPEC-16: Dictionary-based Password Attack",
  "description": "",
  "id": "capec-16:-dictionary-based-password-attack",
  "keyword": "Feature",
  "tags": [
    {
      "line": 1,
      "name": "@capec16"
    }
  ]
});
formatter.scenario({
  "comments": [
    {
      "line": 3,
      "value": "#1. Explore"
    }
  ],
  "line": 4,
  "name": "Step1.1 Determine application\u0027s/system\u0027s password policy",
  "description": "",
  "id": "capec-16:-dictionary-based-password-attack;step1.1-determine-application\u0027s/system\u0027s-password-policy",
  "type": "scenario",
  "keyword": "Scenario"
});
formatter.step({
  "line": 5,
  "name": "prepare to Determine application\u0027s/system\u0027s password policy",
  "keyword": "Given "
});
formatter.step({
  "line": 6,
  "name": "Try to Determine application\u0027s/system\u0027s password policy",
  "keyword": "When "
});
formatter.step({
  "comments": [
    {
      "line": 7,
      "value": "# assertion for attack step success"
    }
  ],
  "line": 8,
  "name": "Assert the success of Determine application\u0027s/system\u0027s password policy",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 9,
      "value": "#assertions for security pattern testing (checker whether the pattern consequences are observed)"
    }
  ],
  "line": 10,
  "name": "assert the consequences of the pattern",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 11,
      "value": "#"
    }
  ],
  "line": 12,
  "name": "assert the consequences of the pattern audit interceptor",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 13,
      "value": "# depends secure logger"
    }
  ],
  "line": 14,
  "name": "assert the consequences of the pattern secure logger",
  "keyword": "Then "
});
formatter.match({
  "location": "determineapplicationssystemspasswordpolicy.predetermineapplicationssystemspasswordpolicy()"
});
formatter.result({
  "duration": 100645,
  "status": "passed"
});
formatter.match({
  "location": "determineapplicationssystemspasswordpolicy.trydetermineapplicationssystemspasswordpolicy()"
});
formatter.result({
  "duration": 23899,
  "status": "passed"
});
formatter.match({
  "location": "determineapplicationssystemspasswordpolicy.assdetermineapplicationssystemspasswordpolicy()"
});
formatter.result({
  "duration": 34544,
  "status": "passed"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({
  "location": "PatternSteps.assauditinterceptor()"
});
formatter.result({
  "status": "skipped"
});
formatter.match({
  "location": "PatternSteps.asssecurelogger()"
});
formatter.result({
  "status": "skipped"
});
formatter.uri("CAPEC_16_Step_1_2.feature");
formatter.feature({
  "line": 2,
  "name": "CAPEC-16: Dictionary-based Password Attack",
  "description": "",
  "id": "capec-16:-dictionary-based-password-attack",
  "keyword": "Feature",
  "tags": [
    {
      "line": 1,
      "name": "@capec16"
    }
  ]
});
formatter.scenario({
  "comments": [
    {
      "line": 3,
      "value": "#1. Explore"
    }
  ],
  "line": 4,
  "name": "Step1.2 Select dictionaries",
  "description": "",
  "id": "capec-16:-dictionary-based-password-attack;step1.2-select-dictionaries",
  "type": "scenario",
  "keyword": "Scenario"
});
formatter.step({
  "line": 5,
  "name": "prepare to Select dictionaries",
  "keyword": "Given "
});
formatter.step({
  "line": 6,
  "name": "Try to Select dictionaries",
  "keyword": "When "
});
formatter.step({
  "comments": [
    {
      "line": 7,
      "value": "# assertion for attack step success"
    }
  ],
  "line": 8,
  "name": "Assert the success of Select dictionaries",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 9,
      "value": "#assertions for security pattern testing (checker whether the pattern consequences are observed)"
    }
  ],
  "line": 10,
  "name": "assert the consequences of the pattern",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 11,
      "value": "#"
    }
  ],
  "line": 12,
  "name": "assert the consequences of the pattern audit interceptor",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 13,
      "value": "# depends secure logger"
    }
  ],
  "line": 14,
  "name": "assert the consequences of the pattern secure logger",
  "keyword": "Then "
});
formatter.match({
  "location": "selectdictionaries.preselectdictionaries()"
});
formatter.result({
  "duration": 106812,
  "status": "passed"
});
formatter.match({
  "location": "selectdictionaries.tryselectdictionaries()"
});
formatter.result({
  "duration": 12777,
  "status": "passed"
});
formatter.match({
  "location": "selectdictionaries.assselectdictionaries()"
});
formatter.result({
  "duration": 15823,
  "status": "passed"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({
  "location": "PatternSteps.assauditinterceptor()"
});
formatter.result({
  "status": "skipped"
});
formatter.match({
  "location": "PatternSteps.asssecurelogger()"
});
formatter.result({
  "status": "skipped"
});
formatter.uri("CAPEC_16_Step_1_3.feature");
formatter.feature({
  "line": 2,
  "name": "CAPEC-16: Dictionary-based Password Attack",
  "description": "",
  "id": "capec-16:-dictionary-based-password-attack",
  "keyword": "Feature",
  "tags": [
    {
      "line": 1,
      "name": "@capec16"
    }
  ]
});
formatter.scenario({
  "comments": [
    {
      "line": 3,
      "value": "#1. Explore"
    }
  ],
  "line": 4,
  "name": "Step1.3 Determine username(s) to target",
  "description": "",
  "id": "capec-16:-dictionary-based-password-attack;step1.3-determine-username(s)-to-target",
  "type": "scenario",
  "keyword": "Scenario"
});
formatter.step({
  "line": 5,
  "name": "prepare to Determine username(s) to target",
  "keyword": "Given "
});
formatter.step({
  "line": 6,
  "name": "Try to Determine username(s) to target",
  "keyword": "When "
});
formatter.step({
  "comments": [
    {
      "line": 7,
      "value": "# assertion for attack step success"
    }
  ],
  "line": 8,
  "name": "Assert the success of Determine username(s) to target",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 9,
      "value": "#assertions for security pattern testing (checker whether the pattern consequences are observed)"
    }
  ],
  "line": 10,
  "name": "assert the consequences of the pattern secure logger",
  "keyword": "Then "
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({
  "location": "PatternSteps.asssecurelogger()"
});
formatter.result({
  "status": "skipped"
});
formatter.uri("CAPEC_16_Step_2_1.feature");
formatter.feature({
  "line": 2,
  "name": "CAPEC-16: Dictionary-based Password Attack",
  "description": "",
  "id": "capec-16:-dictionary-based-password-attack",
  "keyword": "Feature",
  "tags": [
    {
      "line": 1,
      "name": "@capec16"
    }
  ]
});
formatter.scenario({
  "comments": [
    {
      "line": 3,
      "value": "#2. Exploit"
    }
  ],
  "line": 4,
  "name": "Step2.1 Use dictionary to crack passwords.",
  "description": "",
  "id": "capec-16:-dictionary-based-password-attack;step2.1-use-dictionary-to-crack-passwords.",
  "type": "scenario",
  "keyword": "Scenario"
});
formatter.step({
  "line": 5,
  "name": "prepare to Use dictionary to crack passwords.",
  "keyword": "Given "
});
formatter.step({
  "line": 6,
  "name": "Try to Use dictionary to crack passwords.",
  "keyword": "When "
});
formatter.step({
  "comments": [
    {
      "line": 7,
      "value": "# assertion for attack step success"
    }
  ],
  "line": 8,
  "name": "Assert the success of Use dictionary to crack passwords.",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 9,
      "value": "#assertions for security pattern testing (checker whether the pattern consequences are observed)"
    }
  ],
  "line": 10,
  "name": "assert the consequences of the pattern secure logger",
  "keyword": "Then "
});
formatter.match({
  "location": "usedictionarytocrackpasswords.preusedictionarytocrackpasswords()"
});
formatter.result({
  "duration": 65495,
  "status": "passed"
});
formatter.match({
  "location": "usedictionarytocrackpasswords.tryusedictionarytocrackpasswords()"
});
formatter.result({
  "duration": 12377,
  "status": "passed"
});
formatter.match({
  "location": "usedictionarytocrackpasswords.assusedictionarytocrackpasswords()"
});
formatter.result({
  "duration": 9247,
  "status": "passed"
});
formatter.match({
  "location": "PatternSteps.asssecurelogger()"
});
formatter.result({
  "duration": 15815,
  "status": "passed"
});
formatter.uri("CAPEC_170_Step_1_1.feature");
formatter.feature({
  "line": 2,
  "name": "CAPEC-170: Web Application Fingerprinting",
  "description": "",
  "id": "capec-170:-web-application-fingerprinting",
  "keyword": "Feature",
  "tags": [
    {
      "line": 1,
      "name": "@capec170"
    }
  ]
});
formatter.scenario({
  "comments": [
    {
      "line": 3,
      "value": "#1. Explore"
    }
  ],
  "line": 4,
  "name": "Step1.1 Request fingerprinting",
  "description": "",
  "id": "capec-170:-web-application-fingerprinting;step1.1-request-fingerprinting",
  "type": "scenario",
  "keyword": "Scenario"
});
formatter.step({
  "line": 5,
  "name": "prepare to Request fingerprinting",
  "keyword": "Given "
});
formatter.step({
  "line": 6,
  "name": "Try to Request fingerprinting",
  "keyword": "When "
});
formatter.step({
  "comments": [
    {
      "line": 7,
      "value": "# assertion for attack step success"
    }
  ],
  "line": 8,
  "name": "Assert the success of Request fingerprinting",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 9,
      "value": "#assertions for security pattern testing (checker whether the pattern consequences are observed)"
    }
  ],
  "line": 10,
  "name": "assert the consequences of the pattern",
  "keyword": "Then "
});
formatter.match({
  "location": "requestfingerprinting.prerequestfingerprinting()"
});
formatter.result({
  "duration": 67996,
  "status": "passed"
});
formatter.match({
  "location": "requestfingerprinting.tryrequestfingerprinting()"
});
formatter.result({
  "duration": 10188,
  "status": "passed"
});
formatter.match({
  "location": "requestfingerprinting.assrequestfingerprinting()"
});
formatter.result({
  "duration": 9726,
  "status": "passed"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.uri("CAPEC_170_Step_2_1.feature");
formatter.feature({
  "line": 2,
  "name": "CAPEC-170: Web Application Fingerprinting",
  "description": "",
  "id": "capec-170:-web-application-fingerprinting",
  "keyword": "Feature",
  "tags": [
    {
      "line": 1,
      "name": "@capec170"
    }
  ]
});
formatter.scenario({
  "comments": [
    {
      "line": 3,
      "value": "#2. Experiment"
    }
  ],
  "line": 4,
  "name": "Step2.1 Increase the accuracy of server fingerprinting of Web servers",
  "description": "",
  "id": "capec-170:-web-application-fingerprinting;step2.1-increase-the-accuracy-of-server-fingerprinting-of-web-servers",
  "type": "scenario",
  "keyword": "Scenario"
});
formatter.step({
  "line": 5,
  "name": "prepare to Increase the accuracy of server fingerprinting of Web servers",
  "keyword": "Given "
});
formatter.step({
  "line": 6,
  "name": "Try to Increase the accuracy of server fingerprinting of Web servers",
  "keyword": "When "
});
formatter.step({
  "comments": [
    {
      "line": 7,
      "value": "# assertion for attack step success"
    }
  ],
  "line": 8,
  "name": "Assert the success of Increase the accuracy of server fingerprinting of Web servers",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 9,
      "value": "#assertions for security pattern testing (checker whether the pattern consequences are observed)"
    }
  ],
  "line": 10,
  "name": "assert the consequences of the pattern",
  "keyword": "Then "
});
formatter.match({
  "location": "increasetheaccuracyofserverfingerprintingofwebservers.preincreasetheaccuracyofserverfingerprintingofwebservers()"
});
formatter.result({
  "duration": 70531,
  "status": "passed"
});
formatter.match({
  "location": "increasetheaccuracyofserverfingerprintingofwebservers.tryincreasetheaccuracyofserverfingerprintingofwebservers()"
});
formatter.result({
  "duration": 16800,
  "status": "passed"
});
formatter.match({
  "location": "increasetheaccuracyofserverfingerprintingofwebservers.assincreasetheaccuracyofserverfingerprintingofwebservers()"
});
formatter.result({
  "duration": 12039,
  "status": "passed"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.uri("CAPEC_170_Step_2_2.feature");
formatter.feature({
  "line": 2,
  "name": "CAPEC-170: Web Application Fingerprinting",
  "description": "",
  "id": "capec-170:-web-application-fingerprinting",
  "keyword": "Feature",
  "tags": [
    {
      "line": 1,
      "name": "@capec170"
    }
  ]
});
formatter.scenario({
  "comments": [
    {
      "line": 3,
      "value": "#2. Experiment"
    }
  ],
  "line": 4,
  "name": "Step2.2 Identify Web Application Software",
  "description": "",
  "id": "capec-170:-web-application-fingerprinting;step2.2-identify-web-application-software",
  "type": "scenario",
  "keyword": "Scenario"
});
formatter.step({
  "line": 5,
  "name": "prepare to Identify Web Application Software",
  "keyword": "Given "
});
formatter.step({
  "line": 6,
  "name": "Try to Identify Web Application Software",
  "keyword": "When "
});
formatter.step({
  "comments": [
    {
      "line": 7,
      "value": "# assertion for attack step success"
    }
  ],
  "line": 8,
  "name": "Assert the success of Identify Web Application Software",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 9,
      "value": "#assertions for security pattern testing (checker whether the pattern consequences are observed)"
    }
  ],
  "line": 10,
  "name": "assert the consequences of the pattern",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 11,
      "value": "#"
    }
  ],
  "line": 12,
  "name": "assert the consequences of the pattern secure logger",
  "keyword": "Then "
});
formatter.match({
  "location": "identifywebapplicationsoftware.preidentifywebapplicationsoftware()"
});
formatter.result({
  "duration": 62981,
  "status": "passed"
});
formatter.match({
  "location": "identifywebapplicationsoftware.tryidentifywebapplicationsoftware()"
});
formatter.result({
  "duration": 14426,
  "status": "passed"
});
formatter.match({
  "location": "identifywebapplicationsoftware.assidentifywebapplicationsoftware()"
});
formatter.result({
  "duration": 10112,
  "status": "passed"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({
  "location": "PatternSteps.asssecurelogger()"
});
formatter.result({
  "status": "skipped"
});
formatter.uri("CAPEC_170_Step_2_3.feature");
formatter.feature({
  "line": 2,
  "name": "CAPEC-170: Web Application Fingerprinting",
  "description": "",
  "id": "capec-170:-web-application-fingerprinting",
  "keyword": "Feature",
  "tags": [
    {
      "line": 1,
      "name": "@capec170"
    }
  ]
});
formatter.scenario({
  "comments": [
    {
      "line": 3,
      "value": "#2. Experiment"
    }
  ],
  "line": 4,
  "name": "Step2.3 Identify Backend Database Version",
  "description": "",
  "id": "capec-170:-web-application-fingerprinting;step2.3-identify-backend-database-version",
  "type": "scenario",
  "keyword": "Scenario"
});
formatter.step({
  "line": 5,
  "name": "prepare to Identify Backend Database Version",
  "keyword": "Given "
});
formatter.step({
  "line": 6,
  "name": "Try to Identify Backend Database Version",
  "keyword": "When "
});
formatter.step({
  "comments": [
    {
      "line": 7,
      "value": "# assertion for attack step success"
    }
  ],
  "line": 8,
  "name": "Assert the success of Identify Backend Database Version",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 9,
      "value": "#assertions for security pattern testing (checker whether the pattern consequences are observed)"
    }
  ],
  "line": 10,
  "name": "assert the consequences of the pattern",
  "keyword": "Then "
});
formatter.match({
  "location": "identifybackenddatabaseversion.preidentifybackenddatabaseversion()"
});
formatter.result({
  "duration": 129893,
  "status": "passed"
});
formatter.match({
  "location": "identifybackenddatabaseversion.tryidentifybackenddatabaseversion()"
});
formatter.result({
  "duration": 21465,
  "status": "passed"
});
formatter.match({
  "location": "identifybackenddatabaseversion.assidentifybackenddatabaseversion()"
});
formatter.result({
  "duration": 15990,
  "status": "passed"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.uri("CAPEC_174_Step_1_1.feature");
formatter.feature({
  "line": 2,
  "name": "CAPEC-174: Flash Parameter Injection",
  "description": "",
  "id": "capec-174:-flash-parameter-injection",
  "keyword": "Feature",
  "tags": [
    {
      "line": 1,
      "name": "@capec174"
    }
  ]
});
formatter.scenario({
  "comments": [
    {
      "line": 3,
      "value": "#1. Explore"
    }
  ],
  "line": 4,
  "name": "Step1.1 Spider",
  "description": "",
  "id": "capec-174:-flash-parameter-injection;step1.1-spider",
  "type": "scenario",
  "keyword": "Scenario"
});
formatter.step({
  "line": 5,
  "name": "prepare to Spider",
  "keyword": "Given "
});
formatter.step({
  "line": 6,
  "name": "Try to Spider",
  "keyword": "When "
});
formatter.step({
  "comments": [
    {
      "line": 7,
      "value": "# assertion for attack step success"
    }
  ],
  "line": 8,
  "name": "Assert the success of Spider",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 9,
      "value": "#assertions for security pattern testing (checker whether the pattern consequences are observed)"
    }
  ],
  "line": 10,
  "name": "assert the consequences of the pattern",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 11,
      "value": "#"
    }
  ],
  "line": 12,
  "name": "assert the consequences of the pattern audit interceptor",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 13,
      "value": "# depends secure logger"
    }
  ],
  "line": 14,
  "name": "assert the consequences of the pattern secure logger",
  "keyword": "Then "
});
formatter.match({
  "location": "spider.prespider()"
});
formatter.result({
  "duration": 2098608,
  "error_message": "net.continuumsecurity.proxy.ProxyException: org.zaproxy.clientapi.core.ClientApiException: java.net.ConnectException: Connection refused\n\tat net.continuumsecurity.proxy.ZAProxyScanner.validateMinimumRequiredZapVersion(ZAProxyScanner.java:96)\n\tat net.continuumsecurity.proxy.ZAProxyScanner.\u003cinit\u003e(ZAProxyScanner.java:38)\n\tat steps.spider.prespider(spider.java:17)\n\tat ✽.Given prepare to Spider(CAPEC_174_Step_1_1.feature:5)\nCaused by: org.zaproxy.clientapi.core.ClientApiException: java.net.ConnectException: Connection refused\n\tat org.zaproxy.clientapi.core.ClientApi.callApiDom(ClientApi.java:307)\n\tat org.zaproxy.clientapi.core.ClientApi.callApi(ClientApi.java:289)\n\tat org.zaproxy.clientapi.gen.Core.version(Core.java:158)\n\tat net.continuumsecurity.proxy.ZAProxyScanner.validateMinimumRequiredZapVersion(ZAProxyScanner.java:85)\n\tat net.continuumsecurity.proxy.ZAProxyScanner.\u003cinit\u003e(ZAProxyScanner.java:38)\n\tat steps.spider.prespider(spider.java:17)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.lang.reflect.Method.invoke(Method.java:498)\n\tat cucumber.runtime.Utils$1.call(Utils.java:37)\n\tat cucumber.runtime.Timeout.timeout(Timeout.java:13)\n\tat cucumber.runtime.Utils.invoke(Utils.java:31)\n\tat cucumber.runtime.java.JavaStepDefinition.execute(JavaStepDefinition.java:37)\n\tat cucumber.runtime.StepDefinitionMatch.runStep(StepDefinitionMatch.java:37)\n\tat cucumber.runtime.Runtime.runStep(Runtime.java:298)\n\tat cucumber.runtime.model.StepContainer.runStep(StepContainer.java:44)\n\tat cucumber.runtime.model.StepContainer.runSteps(StepContainer.java:39)\n\tat cucumber.runtime.model.CucumberScenario.run(CucumberScenario.java:48)\n\tat cucumber.runtime.junit.ExecutionUnitRunner.run(ExecutionUnitRunner.java:91)\n\tat cucumber.runtime.junit.FeatureRunner.runChild(FeatureRunner.java:63)\n\tat cucumber.runtime.junit.FeatureRunner.runChild(FeatureRunner.java:18)\n\tat org.junit.runners.ParentRunner$3.run(ParentRunner.java:238)\n\tat org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:63)\n\tat org.junit.runners.ParentRunner.runChildren(ParentRunner.java:236)\n\tat org.junit.runners.ParentRunner.access$000(ParentRunner.java:53)\n\tat org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:229)\n\tat org.junit.runners.ParentRunner.run(ParentRunner.java:309)\n\tat cucumber.runtime.junit.FeatureRunner.run(FeatureRunner.java:70)\n\tat cucumber.api.junit.Cucumber.runChild(Cucumber.java:93)\n\tat cucumber.api.junit.Cucumber.runChild(Cucumber.java:37)\n\tat org.junit.runners.ParentRunner$3.run(ParentRunner.java:238)\n\tat org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:63)\n\tat org.junit.runners.ParentRunner.runChildren(ParentRunner.java:236)\n\tat org.junit.runners.ParentRunner.access$000(ParentRunner.java:53)\n\tat org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:229)\n\tat org.junit.internal.runners.statements.RunAfters.evaluate(RunAfters.java:27)\n\tat org.junit.runners.ParentRunner.run(ParentRunner.java:309)\n\tat cucumber.api.junit.Cucumber.run(Cucumber.java:98)\n\tat org.eclipse.jdt.internal.junit4.runner.JUnit4TestReference.run(JUnit4TestReference.java:86)\n\tat org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:459)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:678)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:382)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:192)\nCaused by: java.net.ConnectException: Connection refused\n\tat java.net.PlainSocketImpl.socketConnect(Native Method)\n\tat java.net.AbstractPlainSocketImpl.doConnect(AbstractPlainSocketImpl.java:350)\n\tat java.net.AbstractPlainSocketImpl.connectToAddress(AbstractPlainSocketImpl.java:206)\n\tat java.net.AbstractPlainSocketImpl.connect(AbstractPlainSocketImpl.java:188)\n\tat java.net.Socket.connect(Socket.java:589)\n\tat java.net.Socket.connect(Socket.java:538)\n\tat sun.net.NetworkClient.doConnect(NetworkClient.java:180)\n\tat sun.net.www.http.HttpClient.openServer(HttpClient.java:432)\n\tat sun.net.www.http.HttpClient$1.run(HttpClient.java:484)\n\tat sun.net.www.http.HttpClient$1.run(HttpClient.java:482)\n\tat java.security.AccessController.doPrivileged(Native Method)\n\tat sun.net.www.http.HttpClient.privilegedOpenServer(HttpClient.java:481)\n\tat sun.net.www.http.HttpClient.openServer(HttpClient.java:522)\n\tat sun.net.www.http.HttpClient.\u003cinit\u003e(HttpClient.java:211)\n\tat sun.net.www.http.HttpClient.New(HttpClient.java:308)\n\tat sun.net.www.http.HttpClient.New(HttpClient.java:326)\n\tat sun.net.www.protocol.http.HttpURLConnection.getNewHttpClient(HttpURLConnection.java:1169)\n\tat sun.net.www.protocol.http.HttpURLConnection.plainConnect0(HttpURLConnection.java:1148)\n\tat sun.net.www.protocol.http.HttpURLConnection.plainConnect(HttpURLConnection.java:999)\n\tat sun.net.www.protocol.http.HttpURLConnection.connect(HttpURLConnection.java:933)\n\tat org.zaproxy.clientapi.core.ClientApi.getConnectionInputStream(ClientApi.java:313)\n\tat org.zaproxy.clientapi.core.ClientApi.callApiDom(ClientApi.java:305)\n\t... 44 more\n",
  "status": "failed"
});
formatter.match({
  "location": "spider.tryspider()"
});
formatter.result({
  "status": "skipped"
});
formatter.match({
  "location": "spider.assspider()"
});
formatter.result({
  "status": "skipped"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({
  "location": "PatternSteps.assauditinterceptor()"
});
formatter.result({
  "status": "skipped"
});
formatter.match({
  "location": "PatternSteps.asssecurelogger()"
});
formatter.result({
  "status": "skipped"
});
formatter.uri("CAPEC_174_Step_2_1.feature");
formatter.feature({
  "line": 2,
  "name": "CAPEC-174: Flash Parameter Injection",
  "description": "",
  "id": "capec-174:-flash-parameter-injection",
  "keyword": "Feature",
  "tags": [
    {
      "line": 1,
      "name": "@capec174"
    }
  ]
});
formatter.scenario({
  "comments": [
    {
      "line": 3,
      "value": "#2. Experiment"
    }
  ],
  "line": 4,
  "name": "Step2.1 Determine the application susceptibility to Flash parameter injection",
  "description": "",
  "id": "capec-174:-flash-parameter-injection;step2.1-determine-the-application-susceptibility-to-flash-parameter-injection",
  "type": "scenario",
  "keyword": "Scenario"
});
formatter.step({
  "line": 5,
  "name": "prepare to Determine the application susceptibility to Flash parameter injection",
  "keyword": "Given "
});
formatter.step({
  "line": 6,
  "name": "Try to Determine the application susceptibility to Flash parameter injection",
  "keyword": "When "
});
formatter.step({
  "comments": [
    {
      "line": 7,
      "value": "# assertion for attack step success"
    }
  ],
  "line": 8,
  "name": "Assert the success of Determine the application susceptibility to Flash parameter injection",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 9,
      "value": "#assertions for security pattern testing (checker whether the pattern consequences are observed)"
    }
  ],
  "line": 10,
  "name": "assert the consequences of the pattern secure logger",
  "keyword": "Then "
});
formatter.step({
  "line": 11,
  "name": "assert the consequences of the pattern application firewall",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 12,
      "value": "# alternative output guard"
    },
    {
      "line": 13,
      "value": "# alternative input guard"
    }
  ],
  "line": 14,
  "name": "assert the consequences of the pattern input guard",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 15,
      "value": "# alternative application firewall"
    },
    {
      "line": 16,
      "value": "# benifits output guard"
    }
  ],
  "line": 17,
  "name": "assert the consequences of the pattern pathname canonicalization",
  "keyword": "Then "
});
formatter.step({
  "line": 18,
  "name": "assert the consequences of the pattern output guard",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 19,
      "value": "# alternative application firewall"
    },
    {
      "line": 20,
      "value": "# benifits input guard"
    }
  ],
  "line": 21,
  "name": "assert the consequences of the pattern comparator checked fault tolerant system",
  "keyword": "Then "
});
formatter.match({
  "location": "determinetheapplicationsusceptibilitytoflashparameterinjection.predeterminetheapplicationsusceptibilitytoflashparameterinjection()"
});
formatter.result({
  "duration": 60404,
  "status": "passed"
});
formatter.match({
  "location": "determinetheapplicationsusceptibilitytoflashparameterinjection.trydeterminetheapplicationsusceptibilitytoflashparameterinjection()"
});
formatter.result({
  "duration": 12893,
  "status": "passed"
});
formatter.match({
  "location": "determinetheapplicationsusceptibilitytoflashparameterinjection.assdeterminetheapplicationsusceptibilitytoflashparameterinjection()"
});
formatter.result({
  "duration": 9280,
  "status": "passed"
});
formatter.match({
  "location": "PatternSteps.asssecurelogger()"
});
formatter.result({
  "duration": 18891,
  "status": "passed"
});
formatter.match({
  "location": "PatternSteps.assapplicationfirewall()"
});
formatter.result({
  "duration": 9307,
  "status": "passed"
});
formatter.match({
  "location": "PatternSteps.assinputguard()"
});
formatter.result({
  "duration": 7760,
  "status": "passed"
});
formatter.match({
  "location": "PatternSteps.asspathnamecanonicalization()"
});
formatter.result({
  "duration": 6788,
  "status": "passed"
});
formatter.match({
  "location": "PatternSteps.assoutputguard()"
});
formatter.result({
  "duration": 6722,
  "status": "passed"
});
formatter.match({
  "location": "PatternSteps.asscomparatorcheckedfaulttolerantsystem()"
});
formatter.result({
  "duration": 6897,
  "status": "passed"
});
formatter.uri("CAPEC_178_Step_1_1.feature");
formatter.feature({
  "line": 2,
  "name": "CAPEC-178: Cross-Site Flashing",
  "description": "",
  "id": "capec-178:-cross-site-flashing",
  "keyword": "Feature",
  "tags": [
    {
      "line": 1,
      "name": "@capec178"
    }
  ]
});
formatter.scenario({
  "comments": [
    {
      "line": 3,
      "value": "#1. Explore"
    }
  ],
  "line": 4,
  "name": "Step1.1 Identification",
  "description": "",
  "id": "capec-178:-cross-site-flashing;step1.1-identification",
  "type": "scenario",
  "keyword": "Scenario"
});
formatter.step({
  "line": 5,
  "name": "prepare to Identification",
  "keyword": "Given "
});
formatter.step({
  "line": 6,
  "name": "Try to Identification",
  "keyword": "When "
});
formatter.step({
  "comments": [
    {
      "line": 7,
      "value": "# assertion for attack step success"
    }
  ],
  "line": 8,
  "name": "Assert the success of Identification",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 9,
      "value": "#assertions for security pattern testing (checker whether the pattern consequences are observed)"
    }
  ],
  "line": 10,
  "name": "assert the consequences of the pattern",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 11,
      "value": "#"
    }
  ],
  "line": 12,
  "name": "assert the consequences of the pattern audit interceptor",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 13,
      "value": "# depends secure logger"
    }
  ],
  "line": 14,
  "name": "assert the consequences of the pattern secure logger",
  "keyword": "Then "
});
formatter.match({
  "location": "identification.preidentification()"
});
formatter.result({
  "duration": 48408,
  "status": "passed"
});
formatter.match({
  "location": "identification.tryidentification()"
});
formatter.result({
  "duration": 8778,
  "status": "passed"
});
formatter.match({
  "location": "identification.assidentification()"
});
formatter.result({
  "duration": 9611,
  "status": "passed"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({
  "location": "PatternSteps.assauditinterceptor()"
});
formatter.result({
  "status": "skipped"
});
formatter.match({
  "location": "PatternSteps.asssecurelogger()"
});
formatter.result({
  "status": "skipped"
});
formatter.uri("CAPEC_178_Step_2_1.feature");
formatter.feature({
  "line": 2,
  "name": "CAPEC-178: Cross-Site Flashing",
  "description": "",
  "id": "capec-178:-cross-site-flashing",
  "keyword": "Feature",
  "tags": [
    {
      "line": 1,
      "name": "@capec178"
    }
  ]
});
formatter.scenario({
  "comments": [
    {
      "line": 3,
      "value": "#2. Experiment"
    }
  ],
  "line": 4,
  "name": "Step2.1 Attempt to inject a remote flash file",
  "description": "",
  "id": "capec-178:-cross-site-flashing;step2.1-attempt-to-inject-a-remote-flash-file",
  "type": "scenario",
  "keyword": "Scenario"
});
formatter.step({
  "line": 5,
  "name": "prepare to Attempt to inject a remote flash file",
  "keyword": "Given "
});
formatter.step({
  "line": 6,
  "name": "Try to Attempt to inject a remote flash file",
  "keyword": "When "
});
formatter.step({
  "comments": [
    {
      "line": 7,
      "value": "# assertion for attack step success"
    }
  ],
  "line": 8,
  "name": "Assert the success of Attempt to inject a remote flash file",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 9,
      "value": "#assertions for security pattern testing (checker whether the pattern consequences are observed)"
    }
  ],
  "line": 10,
  "name": "assert the consequences of the pattern",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 11,
      "value": "#"
    }
  ],
  "line": 12,
  "name": "assert the consequences of the pattern audit interceptor",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 13,
      "value": "# depends secure logger"
    }
  ],
  "line": 14,
  "name": "assert the consequences of the pattern secure logger",
  "keyword": "Then "
});
formatter.match({
  "location": "attempttoinjectaremoteflashfile.preattempttoinjectaremoteflashfile()"
});
formatter.result({
  "duration": 58042,
  "status": "passed"
});
formatter.match({
  "location": "attempttoinjectaremoteflashfile.tryattempttoinjectaremoteflashfile()"
});
formatter.result({
  "duration": 8925,
  "status": "passed"
});
formatter.match({
  "location": "attempttoinjectaremoteflashfile.assattempttoinjectaremoteflashfile()"
});
formatter.result({
  "duration": 8552,
  "status": "passed"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({
  "location": "PatternSteps.assauditinterceptor()"
});
formatter.result({
  "status": "skipped"
});
formatter.match({
  "location": "PatternSteps.asssecurelogger()"
});
formatter.result({
  "status": "skipped"
});
formatter.uri("CAPEC_178_Step_3_1.feature");
formatter.feature({
  "line": 2,
  "name": "CAPEC-178: Cross-Site Flashing",
  "description": "",
  "id": "capec-178:-cross-site-flashing",
  "keyword": "Feature",
  "tags": [
    {
      "line": 1,
      "name": "@capec178"
    }
  ]
});
formatter.scenario({
  "comments": [
    {
      "line": 3,
      "value": "#3. Exploit"
    }
  ],
  "line": 4,
  "name": "Step3.1 Access or Modify Flash Application Variables",
  "description": "",
  "id": "capec-178:-cross-site-flashing;step3.1-access-or-modify-flash-application-variables",
  "type": "scenario",
  "keyword": "Scenario"
});
formatter.step({
  "line": 5,
  "name": "prepare to Access or Modify Flash Application Variables",
  "keyword": "Given "
});
formatter.step({
  "line": 6,
  "name": "Try to Access or Modify Flash Application Variables",
  "keyword": "When "
});
formatter.step({
  "comments": [
    {
      "line": 7,
      "value": "# assertion for attack step success"
    }
  ],
  "line": 8,
  "name": "Assert the success of Access or Modify Flash Application Variables",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 9,
      "value": "#assertions for security pattern testing (checker whether the pattern consequences are observed)"
    }
  ],
  "line": 10,
  "name": "assert the consequences of the pattern output guard",
  "keyword": "Then "
});
formatter.step({
  "line": 11,
  "name": "assert the consequences of the pattern comparator checked fault tolerant system",
  "keyword": "Then "
});
formatter.match({
  "location": "accessormodifyflashapplicationvariables.preaccessormodifyflashapplicationvariables()"
});
formatter.result({
  "duration": 66310,
  "status": "passed"
});
formatter.match({
  "location": "accessormodifyflashapplicationvariables.tryaccessormodifyflashapplicationvariables()"
});
formatter.result({
  "duration": 23309,
  "status": "passed"
});
formatter.match({
  "location": "accessormodifyflashapplicationvariables.assaccessormodifyflashapplicationvariables()"
});
formatter.result({
  "duration": 19836,
  "status": "passed"
});
formatter.match({
  "location": "PatternSteps.assoutputguard()"
});
formatter.result({
  "duration": 23063,
  "status": "passed"
});
formatter.match({
  "location": "PatternSteps.asscomparatorcheckedfaulttolerantsystem()"
});
formatter.result({
  "duration": 9184,
  "status": "passed"
});
formatter.uri("CAPEC_178_Step_3_2.feature");
formatter.feature({
  "line": 2,
  "name": "CAPEC-178: Cross-Site Flashing",
  "description": "",
  "id": "capec-178:-cross-site-flashing",
  "keyword": "Feature",
  "tags": [
    {
      "line": 1,
      "name": "@capec178"
    }
  ]
});
formatter.scenario({
  "comments": [
    {
      "line": 3,
      "value": "#3. Exploit"
    }
  ],
  "line": 4,
  "name": "Step3.2 Execute JavaScript in victim\u0027s browser",
  "description": "",
  "id": "capec-178:-cross-site-flashing;step3.2-execute-javascript-in-victim\u0027s-browser",
  "type": "scenario",
  "keyword": "Scenario"
});
formatter.step({
  "line": 5,
  "name": "prepare to Execute JavaScript in victim\u0027s browser",
  "keyword": "Given "
});
formatter.step({
  "line": 6,
  "name": "Try to Execute JavaScript in victim\u0027s browser",
  "keyword": "When "
});
formatter.step({
  "comments": [
    {
      "line": 7,
      "value": "# assertion for attack step success"
    }
  ],
  "line": 8,
  "name": "Assert the success of Execute JavaScript in victim\u0027s browser",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 9,
      "value": "#assertions for security pattern testing (checker whether the pattern consequences are observed)"
    }
  ],
  "line": 10,
  "name": "assert the consequences of the pattern output guard",
  "keyword": "Then "
});
formatter.step({
  "line": 11,
  "name": "assert the consequences of the pattern comparator checked fault tolerant system",
  "keyword": "Then "
});
formatter.match({
  "location": "executejavascriptinvictimsbrowser.preexecutejavascriptinvictimsbrowser()"
});
formatter.result({
  "duration": 79494,
  "status": "passed"
});
formatter.match({
  "location": "executejavascriptinvictimsbrowser.tryexecutejavascriptinvictimsbrowser()"
});
formatter.result({
  "duration": 49879,
  "status": "passed"
});
formatter.match({
  "location": "executejavascriptinvictimsbrowser.assexecutejavascriptinvictimsbrowser()"
});
formatter.result({
  "duration": 16207,
  "status": "passed"
});
formatter.match({
  "location": "PatternSteps.assoutputguard()"
});
formatter.result({
  "duration": 22332,
  "status": "passed"
});
formatter.match({
  "location": "PatternSteps.asscomparatorcheckedfaulttolerantsystem()"
});
formatter.result({
  "duration": 11612,
  "status": "passed"
});
formatter.uri("CAPEC_180_Step_1_1.feature");
formatter.feature({
  "line": 2,
  "name": "CAPEC-180: Exploiting Incorrectly Configured Access Control Security Levels",
  "description": "",
  "id": "capec-180:-exploiting-incorrectly-configured-access-control-security-levels",
  "keyword": "Feature",
  "tags": [
    {
      "line": 1,
      "name": "@capec180"
    }
  ]
});
formatter.scenario({
  "comments": [
    {
      "line": 3,
      "value": "#1. Explore"
    }
  ],
  "line": 4,
  "name": "Step1.1 Survey",
  "description": "",
  "id": "capec-180:-exploiting-incorrectly-configured-access-control-security-levels;step1.1-survey",
  "type": "scenario",
  "keyword": "Scenario"
});
formatter.step({
  "line": 5,
  "name": "prepare to Survey",
  "keyword": "Given "
});
formatter.step({
  "line": 6,
  "name": "Try to Survey",
  "keyword": "When "
});
formatter.step({
  "comments": [
    {
      "line": 7,
      "value": "# assertion for attack step success"
    }
  ],
  "line": 8,
  "name": "Assert the success of Survey",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 9,
      "value": "#assertions for security pattern testing (checker whether the pattern consequences are observed)"
    }
  ],
  "line": 10,
  "name": "assert the consequences of the pattern secure logger",
  "keyword": "Then "
});
formatter.match({
  "location": "survey.presurvey()"
});
formatter.result({
  "duration": 2024402,
  "error_message": "net.continuumsecurity.proxy.ProxyException: org.zaproxy.clientapi.core.ClientApiException: java.net.ConnectException: Connection refused\n\tat net.continuumsecurity.proxy.ZAProxyScanner.validateMinimumRequiredZapVersion(ZAProxyScanner.java:96)\n\tat net.continuumsecurity.proxy.ZAProxyScanner.\u003cinit\u003e(ZAProxyScanner.java:38)\n\tat steps.survey.presurvey(survey.java:17)\n\tat ✽.Given prepare to Survey(CAPEC_180_Step_1_1.feature:5)\nCaused by: org.zaproxy.clientapi.core.ClientApiException: java.net.ConnectException: Connection refused\n\tat org.zaproxy.clientapi.core.ClientApi.callApiDom(ClientApi.java:307)\n\tat org.zaproxy.clientapi.core.ClientApi.callApi(ClientApi.java:289)\n\tat org.zaproxy.clientapi.gen.Core.version(Core.java:158)\n\tat net.continuumsecurity.proxy.ZAProxyScanner.validateMinimumRequiredZapVersion(ZAProxyScanner.java:85)\n\tat net.continuumsecurity.proxy.ZAProxyScanner.\u003cinit\u003e(ZAProxyScanner.java:38)\n\tat steps.survey.presurvey(survey.java:17)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.lang.reflect.Method.invoke(Method.java:498)\n\tat cucumber.runtime.Utils$1.call(Utils.java:37)\n\tat cucumber.runtime.Timeout.timeout(Timeout.java:13)\n\tat cucumber.runtime.Utils.invoke(Utils.java:31)\n\tat cucumber.runtime.java.JavaStepDefinition.execute(JavaStepDefinition.java:37)\n\tat cucumber.runtime.StepDefinitionMatch.runStep(StepDefinitionMatch.java:37)\n\tat cucumber.runtime.Runtime.runStep(Runtime.java:298)\n\tat cucumber.runtime.model.StepContainer.runStep(StepContainer.java:44)\n\tat cucumber.runtime.model.StepContainer.runSteps(StepContainer.java:39)\n\tat cucumber.runtime.model.CucumberScenario.run(CucumberScenario.java:48)\n\tat cucumber.runtime.junit.ExecutionUnitRunner.run(ExecutionUnitRunner.java:91)\n\tat cucumber.runtime.junit.FeatureRunner.runChild(FeatureRunner.java:63)\n\tat cucumber.runtime.junit.FeatureRunner.runChild(FeatureRunner.java:18)\n\tat org.junit.runners.ParentRunner$3.run(ParentRunner.java:238)\n\tat org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:63)\n\tat org.junit.runners.ParentRunner.runChildren(ParentRunner.java:236)\n\tat org.junit.runners.ParentRunner.access$000(ParentRunner.java:53)\n\tat org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:229)\n\tat org.junit.runners.ParentRunner.run(ParentRunner.java:309)\n\tat cucumber.runtime.junit.FeatureRunner.run(FeatureRunner.java:70)\n\tat cucumber.api.junit.Cucumber.runChild(Cucumber.java:93)\n\tat cucumber.api.junit.Cucumber.runChild(Cucumber.java:37)\n\tat org.junit.runners.ParentRunner$3.run(ParentRunner.java:238)\n\tat org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:63)\n\tat org.junit.runners.ParentRunner.runChildren(ParentRunner.java:236)\n\tat org.junit.runners.ParentRunner.access$000(ParentRunner.java:53)\n\tat org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:229)\n\tat org.junit.internal.runners.statements.RunAfters.evaluate(RunAfters.java:27)\n\tat org.junit.runners.ParentRunner.run(ParentRunner.java:309)\n\tat cucumber.api.junit.Cucumber.run(Cucumber.java:98)\n\tat org.eclipse.jdt.internal.junit4.runner.JUnit4TestReference.run(JUnit4TestReference.java:86)\n\tat org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:459)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:678)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:382)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:192)\nCaused by: java.net.ConnectException: Connection refused\n\tat java.net.PlainSocketImpl.socketConnect(Native Method)\n\tat java.net.AbstractPlainSocketImpl.doConnect(AbstractPlainSocketImpl.java:350)\n\tat java.net.AbstractPlainSocketImpl.connectToAddress(AbstractPlainSocketImpl.java:206)\n\tat java.net.AbstractPlainSocketImpl.connect(AbstractPlainSocketImpl.java:188)\n\tat java.net.Socket.connect(Socket.java:589)\n\tat java.net.Socket.connect(Socket.java:538)\n\tat sun.net.NetworkClient.doConnect(NetworkClient.java:180)\n\tat sun.net.www.http.HttpClient.openServer(HttpClient.java:432)\n\tat sun.net.www.http.HttpClient$1.run(HttpClient.java:484)\n\tat sun.net.www.http.HttpClient$1.run(HttpClient.java:482)\n\tat java.security.AccessController.doPrivileged(Native Method)\n\tat sun.net.www.http.HttpClient.privilegedOpenServer(HttpClient.java:481)\n\tat sun.net.www.http.HttpClient.openServer(HttpClient.java:522)\n\tat sun.net.www.http.HttpClient.\u003cinit\u003e(HttpClient.java:211)\n\tat sun.net.www.http.HttpClient.New(HttpClient.java:308)\n\tat sun.net.www.http.HttpClient.New(HttpClient.java:326)\n\tat sun.net.www.protocol.http.HttpURLConnection.getNewHttpClient(HttpURLConnection.java:1169)\n\tat sun.net.www.protocol.http.HttpURLConnection.plainConnect0(HttpURLConnection.java:1148)\n\tat sun.net.www.protocol.http.HttpURLConnection.plainConnect(HttpURLConnection.java:999)\n\tat sun.net.www.protocol.http.HttpURLConnection.connect(HttpURLConnection.java:933)\n\tat org.zaproxy.clientapi.core.ClientApi.getConnectionInputStream(ClientApi.java:313)\n\tat org.zaproxy.clientapi.core.ClientApi.callApiDom(ClientApi.java:305)\n\t... 44 more\n",
  "status": "failed"
});
formatter.match({
  "location": "survey.trysurvey()"
});
formatter.result({
  "status": "skipped"
});
formatter.match({
  "location": "survey.asssurvey()"
});
formatter.result({
  "status": "skipped"
});
formatter.match({
  "location": "PatternSteps.asssecurelogger()"
});
formatter.result({
  "status": "skipped"
});
formatter.uri("CAPEC_180_Step_2_1.feature");
formatter.feature({
  "line": 2,
  "name": "CAPEC-180: Exploiting Incorrectly Configured Access Control Security Levels",
  "description": "",
  "id": "capec-180:-exploiting-incorrectly-configured-access-control-security-levels",
  "keyword": "Feature",
  "tags": [
    {
      "line": 1,
      "name": "@capec180"
    }
  ]
});
formatter.scenario({
  "comments": [
    {
      "line": 3,
      "value": "#2. Experiment"
    }
  ],
  "line": 4,
  "name": "Step2.1 Identify weak points in access control configurations",
  "description": "",
  "id": "capec-180:-exploiting-incorrectly-configured-access-control-security-levels;step2.1-identify-weak-points-in-access-control-configurations",
  "type": "scenario",
  "keyword": "Scenario"
});
formatter.step({
  "line": 5,
  "name": "prepare to Identify weak points in access control configurations",
  "keyword": "Given "
});
formatter.step({
  "line": 6,
  "name": "Try to Identify weak points in access control configurations",
  "keyword": "When "
});
formatter.step({
  "comments": [
    {
      "line": 7,
      "value": "# assertion for attack step success"
    }
  ],
  "line": 8,
  "name": "Assert the success of Identify weak points in access control configurations",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 9,
      "value": "#assertions for security pattern testing (checker whether the pattern consequences are observed)"
    }
  ],
  "line": 10,
  "name": "assert the consequences of the pattern",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 11,
      "value": "#"
    }
  ],
  "line": 12,
  "name": "assert the consequences of the pattern audit interceptor",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 13,
      "value": "# depends secure logger"
    }
  ],
  "line": 14,
  "name": "assert the consequences of the pattern secure logger",
  "keyword": "Then "
});
formatter.match({
  "location": "identifyweakpointsinaccesscontrolconfigurations.preidentifyweakpointsinaccesscontrolconfigurations()"
});
formatter.result({
  "duration": 55418,
  "status": "passed"
});
formatter.match({
  "location": "identifyweakpointsinaccesscontrolconfigurations.tryidentifyweakpointsinaccesscontrolconfigurations()"
});
formatter.result({
  "duration": 38276,
  "status": "passed"
});
formatter.match({
  "location": "identifyweakpointsinaccesscontrolconfigurations.assidentifyweakpointsinaccesscontrolconfigurations()"
});
formatter.result({
  "duration": 9542,
  "status": "passed"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({
  "location": "PatternSteps.assauditinterceptor()"
});
formatter.result({
  "status": "skipped"
});
formatter.match({
  "location": "PatternSteps.asssecurelogger()"
});
formatter.result({
  "status": "skipped"
});
formatter.uri("CAPEC_180_Step_3_1.feature");
formatter.feature({
  "line": 2,
  "name": "CAPEC-180: Exploiting Incorrectly Configured Access Control Security Levels",
  "description": "",
  "id": "capec-180:-exploiting-incorrectly-configured-access-control-security-levels",
  "keyword": "Feature",
  "tags": [
    {
      "line": 1,
      "name": "@capec180"
    }
  ]
});
formatter.scenario({
  "comments": [
    {
      "line": 3,
      "value": "#3. Exploit"
    }
  ],
  "line": 4,
  "name": "Step3.1 Access the function or data bypassing the access control",
  "description": "",
  "id": "capec-180:-exploiting-incorrectly-configured-access-control-security-levels;step3.1-access-the-function-or-data-bypassing-the-access-control",
  "type": "scenario",
  "keyword": "Scenario"
});
formatter.step({
  "line": 5,
  "name": "prepare to Access the function or data bypassing the access control",
  "keyword": "Given "
});
formatter.step({
  "line": 6,
  "name": "Try to Access the function or data bypassing the access control",
  "keyword": "When "
});
formatter.step({
  "comments": [
    {
      "line": 7,
      "value": "# assertion for attack step success"
    }
  ],
  "line": 8,
  "name": "Assert the success of Access the function or data bypassing the access control",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 9,
      "value": "#assertions for security pattern testing (checker whether the pattern consequences are observed)"
    }
  ],
  "line": 10,
  "name": "assert the consequences of the pattern",
  "keyword": "Then "
});
formatter.match({
  "location": "accessthefunctionordatabypassingtheaccesscontrol.preaccessthefunctionordatabypassingtheaccesscontrol()"
});
formatter.result({
  "duration": 100762,
  "status": "passed"
});
formatter.match({
  "location": "accessthefunctionordatabypassingtheaccesscontrol.tryaccessthefunctionordatabypassingtheaccesscontrol()"
});
formatter.result({
  "duration": 46711,
  "status": "passed"
});
formatter.match({
  "location": "accessthefunctionordatabypassingtheaccesscontrol.assaccessthefunctionordatabypassingtheaccesscontrol()"
});
formatter.result({
  "duration": 17382,
  "status": "passed"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.uri("CAPEC_182_Step_1_1.feature");
formatter.feature({
  "line": 2,
  "name": "CAPEC-182: Flash Injection",
  "description": "",
  "id": "capec-182:-flash-injection",
  "keyword": "Feature",
  "tags": [
    {
      "line": 1,
      "name": "@capec182"
    }
  ]
});
formatter.scenario({
  "comments": [
    {
      "line": 3,
      "value": "#1. Explore"
    }
  ],
  "line": 4,
  "name": "Step1.1 Find Injection Entry Points",
  "description": "",
  "id": "capec-182:-flash-injection;step1.1-find-injection-entry-points",
  "type": "scenario",
  "keyword": "Scenario"
});
formatter.step({
  "line": 5,
  "name": "prepare to Find Injection Entry Points",
  "keyword": "Given "
});
formatter.step({
  "line": 6,
  "name": "Try to Find Injection Entry Points",
  "keyword": "When "
});
formatter.step({
  "comments": [
    {
      "line": 7,
      "value": "# assertion for attack step success"
    }
  ],
  "line": 8,
  "name": "Assert the success of Find Injection Entry Points",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 9,
      "value": "#assertions for security pattern testing (checker whether the pattern consequences are observed)"
    }
  ],
  "line": 10,
  "name": "assert the consequences of the pattern",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 11,
      "value": "#"
    }
  ],
  "line": 12,
  "name": "assert the consequences of the pattern audit interceptor",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 13,
      "value": "# depends secure logger"
    }
  ],
  "line": 14,
  "name": "assert the consequences of the pattern secure logger",
  "keyword": "Then "
});
formatter.match({
  "location": "findinjectionentrypoints.prefindinjectionentrypoints()"
});
formatter.result({
  "duration": 94288,
  "status": "passed"
});
formatter.match({
  "location": "findinjectionentrypoints.tryfindinjectionentrypoints()"
});
formatter.result({
  "duration": 15381,
  "status": "passed"
});
formatter.match({
  "location": "findinjectionentrypoints.assfindinjectionentrypoints()"
});
formatter.result({
  "duration": 8848,
  "status": "passed"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({
  "location": "PatternSteps.assauditinterceptor()"
});
formatter.result({
  "status": "skipped"
});
formatter.match({
  "location": "PatternSteps.asssecurelogger()"
});
formatter.result({
  "status": "skipped"
});
formatter.uri("CAPEC_182_Step_2_1.feature");
formatter.feature({
  "line": 2,
  "name": "CAPEC-182: Flash Injection",
  "description": "",
  "id": "capec-182:-flash-injection",
  "keyword": "Feature",
  "tags": [
    {
      "line": 1,
      "name": "@capec182"
    }
  ]
});
formatter.scenario({
  "comments": [
    {
      "line": 3,
      "value": "#2. Experiment"
    }
  ],
  "line": 4,
  "name": "Step2.1 Determine the application\u0027s susceptibility to Flash injection",
  "description": "",
  "id": "capec-182:-flash-injection;step2.1-determine-the-application\u0027s-susceptibility-to-flash-injection",
  "type": "scenario",
  "keyword": "Scenario"
});
formatter.step({
  "line": 5,
  "name": "prepare to Determine the application\u0027s susceptibility to Flash injection",
  "keyword": "Given "
});
formatter.step({
  "line": 6,
  "name": "Try to Determine the application\u0027s susceptibility to Flash injection",
  "keyword": "When "
});
formatter.step({
  "comments": [
    {
      "line": 7,
      "value": "# assertion for attack step success"
    }
  ],
  "line": 8,
  "name": "Assert the success of Determine the application\u0027s susceptibility to Flash injection",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 9,
      "value": "#assertions for security pattern testing (checker whether the pattern consequences are observed)"
    }
  ],
  "line": 10,
  "name": "assert the consequences of the pattern",
  "keyword": "Then "
});
formatter.match({
  "location": "determinetheapplicationssusceptibilitytoflashinjection.predeterminetheapplicationssusceptibilitytoflashinjection()"
});
formatter.result({
  "duration": 74808,
  "status": "passed"
});
formatter.match({
  "location": "determinetheapplicationssusceptibilitytoflashinjection.trydeterminetheapplicationssusceptibilitytoflashinjection()"
});
formatter.result({
  "duration": 13064,
  "status": "passed"
});
formatter.match({
  "location": "determinetheapplicationssusceptibilitytoflashinjection.assdeterminetheapplicationssusceptibilitytoflashinjection()"
});
formatter.result({
  "duration": 15829,
  "status": "passed"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.uri("CAPEC_182_Step_3_1.feature");
formatter.feature({
  "line": 2,
  "name": "CAPEC-182: Flash Injection",
  "description": "",
  "id": "capec-182:-flash-injection",
  "keyword": "Feature",
  "tags": [
    {
      "line": 1,
      "name": "@capec182"
    }
  ]
});
formatter.scenario({
  "comments": [
    {
      "line": 3,
      "value": "#3. Exploit"
    }
  ],
  "line": 4,
  "name": "Step3.1 Inject malicious content into target",
  "description": "",
  "id": "capec-182:-flash-injection;step3.1-inject-malicious-content-into-target",
  "type": "scenario",
  "keyword": "Scenario"
});
formatter.step({
  "line": 5,
  "name": "prepare to Inject malicious content into target",
  "keyword": "Given "
});
formatter.step({
  "line": 6,
  "name": "Try to Inject malicious content into target",
  "keyword": "When "
});
formatter.step({
  "comments": [
    {
      "line": 7,
      "value": "# assertion for attack step success"
    }
  ],
  "line": 8,
  "name": "Assert the success of Inject malicious content into target",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 9,
      "value": "#assertions for security pattern testing (checker whether the pattern consequences are observed)"
    }
  ],
  "line": 10,
  "name": "assert the consequences of the pattern",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 11,
      "value": "#"
    }
  ],
  "line": 12,
  "name": "assert the consequences of the pattern audit interceptor",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 13,
      "value": "# depends secure logger"
    }
  ],
  "line": 14,
  "name": "assert the consequences of the pattern secure logger",
  "keyword": "Then "
});
formatter.match({
  "location": "injectmaliciouscontentintotarget.preinjectmaliciouscontentintotarget()"
});
formatter.result({
  "duration": 84493,
  "status": "passed"
});
formatter.match({
  "location": "injectmaliciouscontentintotarget.tryinjectmaliciouscontentintotarget()"
});
formatter.result({
  "duration": 15785,
  "status": "passed"
});
formatter.match({
  "location": "injectmaliciouscontentintotarget.assinjectmaliciouscontentintotarget()"
});
formatter.result({
  "duration": 16996,
  "status": "passed"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({
  "location": "PatternSteps.assauditinterceptor()"
});
formatter.result({
  "status": "skipped"
});
formatter.match({
  "location": "PatternSteps.asssecurelogger()"
});
formatter.result({
  "status": "skipped"
});
formatter.uri("CAPEC_18_Step_1_1.feature");
formatter.feature({
  "line": 2,
  "name": "CAPEC-18: Embedding Scripts in Non-Script Elements",
  "description": "",
  "id": "capec-18:-embedding-scripts-in-non-script-elements",
  "keyword": "Feature",
  "tags": [
    {
      "line": 1,
      "name": "@capec18"
    }
  ]
});
formatter.scenario({
  "comments": [
    {
      "line": 3,
      "value": "#1. Explore"
    }
  ],
  "line": 4,
  "name": "Step1.1 Spider",
  "description": "",
  "id": "capec-18:-embedding-scripts-in-non-script-elements;step1.1-spider",
  "type": "scenario",
  "keyword": "Scenario"
});
formatter.step({
  "line": 5,
  "name": "prepare to Spider",
  "keyword": "Given "
});
formatter.step({
  "line": 6,
  "name": "Try to Spider",
  "keyword": "When "
});
formatter.step({
  "comments": [
    {
      "line": 7,
      "value": "# assertion for attack step success"
    }
  ],
  "line": 8,
  "name": "Assert the success of Spider",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 9,
      "value": "#assertions for security pattern testing (checker whether the pattern consequences are observed)"
    }
  ],
  "line": 10,
  "name": "assert the consequences of the pattern",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 11,
      "value": "#"
    }
  ],
  "line": 12,
  "name": "assert the consequences of the pattern audit interceptor",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 13,
      "value": "# depends secure logger"
    }
  ],
  "line": 14,
  "name": "assert the consequences of the pattern secure logger",
  "keyword": "Then "
});
formatter.match({
  "location": "spider.prespider()"
});
formatter.result({
  "duration": 1500413,
  "error_message": "net.continuumsecurity.proxy.ProxyException: org.zaproxy.clientapi.core.ClientApiException: java.net.ConnectException: Connection refused\n\tat net.continuumsecurity.proxy.ZAProxyScanner.validateMinimumRequiredZapVersion(ZAProxyScanner.java:96)\n\tat net.continuumsecurity.proxy.ZAProxyScanner.\u003cinit\u003e(ZAProxyScanner.java:38)\n\tat steps.spider.prespider(spider.java:17)\n\tat ✽.Given prepare to Spider(CAPEC_18_Step_1_1.feature:5)\nCaused by: org.zaproxy.clientapi.core.ClientApiException: java.net.ConnectException: Connection refused\n\tat org.zaproxy.clientapi.core.ClientApi.callApiDom(ClientApi.java:307)\n\tat org.zaproxy.clientapi.core.ClientApi.callApi(ClientApi.java:289)\n\tat org.zaproxy.clientapi.gen.Core.version(Core.java:158)\n\tat net.continuumsecurity.proxy.ZAProxyScanner.validateMinimumRequiredZapVersion(ZAProxyScanner.java:85)\n\tat net.continuumsecurity.proxy.ZAProxyScanner.\u003cinit\u003e(ZAProxyScanner.java:38)\n\tat steps.spider.prespider(spider.java:17)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.lang.reflect.Method.invoke(Method.java:498)\n\tat cucumber.runtime.Utils$1.call(Utils.java:37)\n\tat cucumber.runtime.Timeout.timeout(Timeout.java:13)\n\tat cucumber.runtime.Utils.invoke(Utils.java:31)\n\tat cucumber.runtime.java.JavaStepDefinition.execute(JavaStepDefinition.java:37)\n\tat cucumber.runtime.StepDefinitionMatch.runStep(StepDefinitionMatch.java:37)\n\tat cucumber.runtime.Runtime.runStep(Runtime.java:298)\n\tat cucumber.runtime.model.StepContainer.runStep(StepContainer.java:44)\n\tat cucumber.runtime.model.StepContainer.runSteps(StepContainer.java:39)\n\tat cucumber.runtime.model.CucumberScenario.run(CucumberScenario.java:48)\n\tat cucumber.runtime.junit.ExecutionUnitRunner.run(ExecutionUnitRunner.java:91)\n\tat cucumber.runtime.junit.FeatureRunner.runChild(FeatureRunner.java:63)\n\tat cucumber.runtime.junit.FeatureRunner.runChild(FeatureRunner.java:18)\n\tat org.junit.runners.ParentRunner$3.run(ParentRunner.java:238)\n\tat org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:63)\n\tat org.junit.runners.ParentRunner.runChildren(ParentRunner.java:236)\n\tat org.junit.runners.ParentRunner.access$000(ParentRunner.java:53)\n\tat org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:229)\n\tat org.junit.runners.ParentRunner.run(ParentRunner.java:309)\n\tat cucumber.runtime.junit.FeatureRunner.run(FeatureRunner.java:70)\n\tat cucumber.api.junit.Cucumber.runChild(Cucumber.java:93)\n\tat cucumber.api.junit.Cucumber.runChild(Cucumber.java:37)\n\tat org.junit.runners.ParentRunner$3.run(ParentRunner.java:238)\n\tat org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:63)\n\tat org.junit.runners.ParentRunner.runChildren(ParentRunner.java:236)\n\tat org.junit.runners.ParentRunner.access$000(ParentRunner.java:53)\n\tat org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:229)\n\tat org.junit.internal.runners.statements.RunAfters.evaluate(RunAfters.java:27)\n\tat org.junit.runners.ParentRunner.run(ParentRunner.java:309)\n\tat cucumber.api.junit.Cucumber.run(Cucumber.java:98)\n\tat org.eclipse.jdt.internal.junit4.runner.JUnit4TestReference.run(JUnit4TestReference.java:86)\n\tat org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:459)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:678)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:382)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:192)\nCaused by: java.net.ConnectException: Connection refused\n\tat java.net.PlainSocketImpl.socketConnect(Native Method)\n\tat java.net.AbstractPlainSocketImpl.doConnect(AbstractPlainSocketImpl.java:350)\n\tat java.net.AbstractPlainSocketImpl.connectToAddress(AbstractPlainSocketImpl.java:206)\n\tat java.net.AbstractPlainSocketImpl.connect(AbstractPlainSocketImpl.java:188)\n\tat java.net.Socket.connect(Socket.java:589)\n\tat java.net.Socket.connect(Socket.java:538)\n\tat sun.net.NetworkClient.doConnect(NetworkClient.java:180)\n\tat sun.net.www.http.HttpClient.openServer(HttpClient.java:432)\n\tat sun.net.www.http.HttpClient$1.run(HttpClient.java:484)\n\tat sun.net.www.http.HttpClient$1.run(HttpClient.java:482)\n\tat java.security.AccessController.doPrivileged(Native Method)\n\tat sun.net.www.http.HttpClient.privilegedOpenServer(HttpClient.java:481)\n\tat sun.net.www.http.HttpClient.openServer(HttpClient.java:522)\n\tat sun.net.www.http.HttpClient.\u003cinit\u003e(HttpClient.java:211)\n\tat sun.net.www.http.HttpClient.New(HttpClient.java:308)\n\tat sun.net.www.http.HttpClient.New(HttpClient.java:326)\n\tat sun.net.www.protocol.http.HttpURLConnection.getNewHttpClient(HttpURLConnection.java:1169)\n\tat sun.net.www.protocol.http.HttpURLConnection.plainConnect0(HttpURLConnection.java:1148)\n\tat sun.net.www.protocol.http.HttpURLConnection.plainConnect(HttpURLConnection.java:999)\n\tat sun.net.www.protocol.http.HttpURLConnection.connect(HttpURLConnection.java:933)\n\tat org.zaproxy.clientapi.core.ClientApi.getConnectionInputStream(ClientApi.java:313)\n\tat org.zaproxy.clientapi.core.ClientApi.callApiDom(ClientApi.java:305)\n\t... 44 more\n",
  "status": "failed"
});
formatter.match({
  "location": "spider.tryspider()"
});
formatter.result({
  "status": "skipped"
});
formatter.match({
  "location": "spider.assspider()"
});
formatter.result({
  "status": "skipped"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({
  "location": "PatternSteps.assauditinterceptor()"
});
formatter.result({
  "status": "skipped"
});
formatter.match({
  "location": "PatternSteps.asssecurelogger()"
});
formatter.result({
  "status": "skipped"
});
formatter.uri("CAPEC_18_Step_2_1.feature");
formatter.feature({
  "line": 2,
  "name": "CAPEC-18: Embedding Scripts in Non-Script Elements",
  "description": "",
  "id": "capec-18:-embedding-scripts-in-non-script-elements",
  "keyword": "Feature",
  "tags": [
    {
      "line": 1,
      "name": "@capec18"
    }
  ]
});
formatter.scenario({
  "comments": [
    {
      "line": 3,
      "value": "#2. Experiment"
    }
  ],
  "line": 4,
  "name": "Step2.1 Probe identified potential entry points for XSS vulnerability",
  "description": "",
  "id": "capec-18:-embedding-scripts-in-non-script-elements;step2.1-probe-identified-potential-entry-points-for-xss-vulnerability",
  "type": "scenario",
  "keyword": "Scenario"
});
formatter.step({
  "line": 5,
  "name": "prepare to Probe identified potential entry points for XSS vulnerability",
  "keyword": "Given "
});
formatter.step({
  "line": 6,
  "name": "Try to Probe identified potential entry points for XSS vulnerability",
  "keyword": "When "
});
formatter.step({
  "comments": [
    {
      "line": 7,
      "value": "# assertion for attack step success"
    }
  ],
  "line": 8,
  "name": "Assert the success of Probe identified potential entry points for XSS vulnerability",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 9,
      "value": "#assertions for security pattern testing (checker whether the pattern consequences are observed)"
    }
  ],
  "line": 10,
  "name": "assert the consequences of the pattern secure logger",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 11,
      "value": "# benifits audit interceptor"
    }
  ],
  "line": 12,
  "name": "assert the consequences of the pattern application firewall",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 13,
      "value": "# alternative output guard"
    },
    {
      "line": 14,
      "value": "# alternative input guard"
    }
  ],
  "line": 15,
  "name": "assert the consequences of the pattern input guard",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 16,
      "value": "# alternative application firewall"
    },
    {
      "line": 17,
      "value": "# benifits output guard"
    }
  ],
  "line": 18,
  "name": "assert the consequences of the pattern output guard",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 19,
      "value": "# alternative application firewall"
    },
    {
      "line": 20,
      "value": "# benifits input guard"
    }
  ],
  "line": 21,
  "name": "assert the consequences of the pattern comparator checked fault tolerant system",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 22,
      "value": "# alternative output guard"
    },
    {
      "line": 23,
      "value": "# impairs audit interceptor"
    }
  ],
  "line": 24,
  "name": "assert the consequences of the pattern audit interceptor",
  "keyword": "Then "
});
formatter.match({
  "location": "probeidentifiedpotentialentrypointsforxssvulnerability.preprobeidentifiedpotentialentrypointsforxssvulnerability()"
});
formatter.result({
  "duration": 1863387,
  "error_message": "net.continuumsecurity.proxy.ProxyException: org.zaproxy.clientapi.core.ClientApiException: java.net.ConnectException: Connection refused\n\tat net.continuumsecurity.proxy.ZAProxyScanner.validateMinimumRequiredZapVersion(ZAProxyScanner.java:96)\n\tat net.continuumsecurity.proxy.ZAProxyScanner.\u003cinit\u003e(ZAProxyScanner.java:38)\n\tat steps.probeidentifiedpotentialentrypointsforxssvulnerability.preprobeidentifiedpotentialentrypointsforxssvulnerability(probeidentifiedpotentialentrypointsforxssvulnerability.java:15)\n\tat ✽.Given prepare to Probe identified potential entry points for XSS vulnerability(CAPEC_18_Step_2_1.feature:5)\nCaused by: org.zaproxy.clientapi.core.ClientApiException: java.net.ConnectException: Connection refused\n\tat org.zaproxy.clientapi.core.ClientApi.callApiDom(ClientApi.java:307)\n\tat org.zaproxy.clientapi.core.ClientApi.callApi(ClientApi.java:289)\n\tat org.zaproxy.clientapi.gen.Core.version(Core.java:158)\n\tat net.continuumsecurity.proxy.ZAProxyScanner.validateMinimumRequiredZapVersion(ZAProxyScanner.java:85)\n\tat net.continuumsecurity.proxy.ZAProxyScanner.\u003cinit\u003e(ZAProxyScanner.java:38)\n\tat steps.probeidentifiedpotentialentrypointsforxssvulnerability.preprobeidentifiedpotentialentrypointsforxssvulnerability(probeidentifiedpotentialentrypointsforxssvulnerability.java:15)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.lang.reflect.Method.invoke(Method.java:498)\n\tat cucumber.runtime.Utils$1.call(Utils.java:37)\n\tat cucumber.runtime.Timeout.timeout(Timeout.java:13)\n\tat cucumber.runtime.Utils.invoke(Utils.java:31)\n\tat cucumber.runtime.java.JavaStepDefinition.execute(JavaStepDefinition.java:37)\n\tat cucumber.runtime.StepDefinitionMatch.runStep(StepDefinitionMatch.java:37)\n\tat cucumber.runtime.Runtime.runStep(Runtime.java:298)\n\tat cucumber.runtime.model.StepContainer.runStep(StepContainer.java:44)\n\tat cucumber.runtime.model.StepContainer.runSteps(StepContainer.java:39)\n\tat cucumber.runtime.model.CucumberScenario.run(CucumberScenario.java:48)\n\tat cucumber.runtime.junit.ExecutionUnitRunner.run(ExecutionUnitRunner.java:91)\n\tat cucumber.runtime.junit.FeatureRunner.runChild(FeatureRunner.java:63)\n\tat cucumber.runtime.junit.FeatureRunner.runChild(FeatureRunner.java:18)\n\tat org.junit.runners.ParentRunner$3.run(ParentRunner.java:238)\n\tat org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:63)\n\tat org.junit.runners.ParentRunner.runChildren(ParentRunner.java:236)\n\tat org.junit.runners.ParentRunner.access$000(ParentRunner.java:53)\n\tat org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:229)\n\tat org.junit.runners.ParentRunner.run(ParentRunner.java:309)\n\tat cucumber.runtime.junit.FeatureRunner.run(FeatureRunner.java:70)\n\tat cucumber.api.junit.Cucumber.runChild(Cucumber.java:93)\n\tat cucumber.api.junit.Cucumber.runChild(Cucumber.java:37)\n\tat org.junit.runners.ParentRunner$3.run(ParentRunner.java:238)\n\tat org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:63)\n\tat org.junit.runners.ParentRunner.runChildren(ParentRunner.java:236)\n\tat org.junit.runners.ParentRunner.access$000(ParentRunner.java:53)\n\tat org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:229)\n\tat org.junit.internal.runners.statements.RunAfters.evaluate(RunAfters.java:27)\n\tat org.junit.runners.ParentRunner.run(ParentRunner.java:309)\n\tat cucumber.api.junit.Cucumber.run(Cucumber.java:98)\n\tat org.eclipse.jdt.internal.junit4.runner.JUnit4TestReference.run(JUnit4TestReference.java:86)\n\tat org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:459)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:678)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:382)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:192)\nCaused by: java.net.ConnectException: Connection refused\n\tat java.net.PlainSocketImpl.socketConnect(Native Method)\n\tat java.net.AbstractPlainSocketImpl.doConnect(AbstractPlainSocketImpl.java:350)\n\tat java.net.AbstractPlainSocketImpl.connectToAddress(AbstractPlainSocketImpl.java:206)\n\tat java.net.AbstractPlainSocketImpl.connect(AbstractPlainSocketImpl.java:188)\n\tat java.net.Socket.connect(Socket.java:589)\n\tat java.net.Socket.connect(Socket.java:538)\n\tat sun.net.NetworkClient.doConnect(NetworkClient.java:180)\n\tat sun.net.www.http.HttpClient.openServer(HttpClient.java:432)\n\tat sun.net.www.http.HttpClient$1.run(HttpClient.java:484)\n\tat sun.net.www.http.HttpClient$1.run(HttpClient.java:482)\n\tat java.security.AccessController.doPrivileged(Native Method)\n\tat sun.net.www.http.HttpClient.privilegedOpenServer(HttpClient.java:481)\n\tat sun.net.www.http.HttpClient.openServer(HttpClient.java:522)\n\tat sun.net.www.http.HttpClient.\u003cinit\u003e(HttpClient.java:211)\n\tat sun.net.www.http.HttpClient.New(HttpClient.java:308)\n\tat sun.net.www.http.HttpClient.New(HttpClient.java:326)\n\tat sun.net.www.protocol.http.HttpURLConnection.getNewHttpClient(HttpURLConnection.java:1169)\n\tat sun.net.www.protocol.http.HttpURLConnection.plainConnect0(HttpURLConnection.java:1148)\n\tat sun.net.www.protocol.http.HttpURLConnection.plainConnect(HttpURLConnection.java:999)\n\tat sun.net.www.protocol.http.HttpURLConnection.connect(HttpURLConnection.java:933)\n\tat org.zaproxy.clientapi.core.ClientApi.getConnectionInputStream(ClientApi.java:313)\n\tat org.zaproxy.clientapi.core.ClientApi.callApiDom(ClientApi.java:305)\n\t... 44 more\n",
  "status": "failed"
});
formatter.match({
  "location": "probeidentifiedpotentialentrypointsforxssvulnerability.tryprobeidentifiedpotentialentrypointsforxssvulnerability()"
});
formatter.result({
  "status": "skipped"
});
formatter.match({
  "location": "probeidentifiedpotentialentrypointsforxssvulnerability.assprobeidentifiedpotentialentrypointsforxssvulnerability()"
});
formatter.result({
  "status": "skipped"
});
formatter.match({
  "location": "PatternSteps.asssecurelogger()"
});
formatter.result({
  "status": "skipped"
});
formatter.match({
  "location": "PatternSteps.assapplicationfirewall()"
});
formatter.result({
  "status": "skipped"
});
formatter.match({
  "location": "PatternSteps.assinputguard()"
});
formatter.result({
  "status": "skipped"
});
formatter.match({
  "location": "PatternSteps.assoutputguard()"
});
formatter.result({
  "status": "skipped"
});
formatter.match({
  "location": "PatternSteps.asscomparatorcheckedfaulttolerantsystem()"
});
formatter.result({
  "status": "skipped"
});
formatter.match({
  "location": "PatternSteps.assauditinterceptor()"
});
formatter.result({
  "status": "skipped"
});
formatter.uri("CAPEC_18_Step_3_1.feature");
formatter.feature({
  "line": 2,
  "name": "CAPEC-18: Embedding Scripts in Non-Script Elements",
  "description": "",
  "id": "capec-18:-embedding-scripts-in-non-script-elements",
  "keyword": "Feature",
  "tags": [
    {
      "line": 1,
      "name": "@capec18"
    }
  ]
});
formatter.scenario({
  "comments": [
    {
      "line": 3,
      "value": "#3. Exploit"
    }
  ],
  "line": 4,
  "name": "Step3.1 Steal session IDs, credentials, page content, etc.",
  "description": "",
  "id": "capec-18:-embedding-scripts-in-non-script-elements;step3.1-steal-session-ids,-credentials,-page-content,-etc.",
  "type": "scenario",
  "keyword": "Scenario"
});
formatter.step({
  "line": 5,
  "name": "prepare to Steal session IDs, credentials, page content, etc.",
  "keyword": "Given "
});
formatter.step({
  "line": 6,
  "name": "Try to Steal session IDs, credentials, page content, etc.",
  "keyword": "When "
});
formatter.step({
  "comments": [
    {
      "line": 7,
      "value": "# assertion for attack step success"
    }
  ],
  "line": 8,
  "name": "Assert the success of Steal session IDs, credentials, page content, etc.",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 9,
      "value": "#assertions for security pattern testing (checker whether the pattern consequences are observed)"
    }
  ],
  "line": 10,
  "name": "assert the consequences of the pattern audit interceptor",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 11,
      "value": "# depends secure logger"
    }
  ],
  "line": 12,
  "name": "assert the consequences of the pattern secure logger",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 13,
      "value": "# benifits audit interceptor"
    }
  ],
  "line": 14,
  "name": "assert the consequences of the pattern application firewall",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 15,
      "value": "# alternative output guard"
    },
    {
      "line": 16,
      "value": "# alternative input guard"
    }
  ],
  "line": 17,
  "name": "assert the consequences of the pattern input guard",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 18,
      "value": "# alternative application firewall"
    },
    {
      "line": 19,
      "value": "# benifits output guard"
    }
  ],
  "line": 20,
  "name": "assert the consequences of the pattern output guard",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 21,
      "value": "# alternative application firewall"
    },
    {
      "line": 22,
      "value": "# benifits input guard"
    }
  ],
  "line": 23,
  "name": "assert the consequences of the pattern comparator checked fault tolerant system",
  "keyword": "Then "
});
formatter.match({
  "location": "stealsessionidscredentialspagecontentetc.prestealsessionidscredentialspagecontentetc()"
});
formatter.result({
  "duration": 70157,
  "status": "passed"
});
formatter.match({
  "location": "stealsessionidscredentialspagecontentetc.trystealsessionidscredentialspagecontentetc()"
});
formatter.result({
  "duration": 11878,
  "status": "passed"
});
formatter.match({
  "location": "stealsessionidscredentialspagecontentetc.assstealsessionidscredentialspagecontentetc()"
});
formatter.result({
  "duration": 13151,
  "status": "passed"
});
formatter.match({
  "location": "PatternSteps.assauditinterceptor()"
});
formatter.result({
  "duration": 21570,
  "status": "passed"
});
formatter.match({
  "location": "PatternSteps.asssecurelogger()"
});
formatter.result({
  "duration": 9218,
  "status": "passed"
});
formatter.match({
  "location": "PatternSteps.assapplicationfirewall()"
});
formatter.result({
  "duration": 9619,
  "status": "passed"
});
formatter.match({
  "location": "PatternSteps.assinputguard()"
});
formatter.result({
  "duration": 9175,
  "status": "passed"
});
formatter.match({
  "location": "PatternSteps.assoutputguard()"
});
formatter.result({
  "duration": 9095,
  "status": "passed"
});
formatter.match({
  "location": "PatternSteps.asscomparatorcheckedfaulttolerantsystem()"
});
formatter.result({
  "duration": 9188,
  "status": "passed"
});
formatter.uri("CAPEC_18_Step_3_2.feature");
formatter.feature({
  "line": 2,
  "name": "CAPEC-18: Embedding Scripts in Non-Script Elements",
  "description": "",
  "id": "capec-18:-embedding-scripts-in-non-script-elements",
  "keyword": "Feature",
  "tags": [
    {
      "line": 1,
      "name": "@capec18"
    }
  ]
});
formatter.scenario({
  "comments": [
    {
      "line": 3,
      "value": "#3. Exploit"
    }
  ],
  "line": 4,
  "name": "Step3.2 Forceful browsing",
  "description": "",
  "id": "capec-18:-embedding-scripts-in-non-script-elements;step3.2-forceful-browsing",
  "type": "scenario",
  "keyword": "Scenario"
});
formatter.step({
  "line": 5,
  "name": "prepare to Forceful browsing",
  "keyword": "Given "
});
formatter.step({
  "line": 6,
  "name": "Try to Forceful browsing",
  "keyword": "When "
});
formatter.step({
  "comments": [
    {
      "line": 7,
      "value": "# assertion for attack step success"
    }
  ],
  "line": 8,
  "name": "Assert the success of Forceful browsing",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 9,
      "value": "#assertions for security pattern testing (checker whether the pattern consequences are observed)"
    }
  ],
  "line": 10,
  "name": "assert the consequences of the pattern audit interceptor",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 11,
      "value": "# depends secure logger"
    }
  ],
  "line": 12,
  "name": "assert the consequences of the pattern secure logger",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 13,
      "value": "# benifits audit interceptor"
    }
  ],
  "line": 14,
  "name": "assert the consequences of the pattern application firewall",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 15,
      "value": "# alternative output guard"
    },
    {
      "line": 16,
      "value": "# alternative input guard"
    }
  ],
  "line": 17,
  "name": "assert the consequences of the pattern input guard",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 18,
      "value": "# alternative application firewall"
    },
    {
      "line": 19,
      "value": "# benifits output guard"
    }
  ],
  "line": 20,
  "name": "assert the consequences of the pattern output guard",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 21,
      "value": "# alternative application firewall"
    },
    {
      "line": 22,
      "value": "# benifits input guard"
    }
  ],
  "line": 23,
  "name": "assert the consequences of the pattern comparator checked fault tolerant system",
  "keyword": "Then "
});
formatter.match({
  "location": "forcefulbrowsing.preforcefulbrowsing()"
});
formatter.result({
  "duration": 70424,
  "status": "passed"
});
formatter.match({
  "location": "forcefulbrowsing.tryforcefulbrowsing()"
});
formatter.result({
  "duration": 13229,
  "status": "passed"
});
formatter.match({
  "location": "forcefulbrowsing.assforcefulbrowsing()"
});
formatter.result({
  "duration": 11672,
  "status": "passed"
});
formatter.match({
  "location": "PatternSteps.assauditinterceptor()"
});
formatter.result({
  "duration": 19734,
  "status": "passed"
});
formatter.match({
  "location": "PatternSteps.asssecurelogger()"
});
formatter.result({
  "duration": 22480,
  "status": "passed"
});
formatter.match({
  "location": "PatternSteps.assapplicationfirewall()"
});
formatter.result({
  "duration": 11972,
  "status": "passed"
});
formatter.match({
  "location": "PatternSteps.assinputguard()"
});
formatter.result({
  "duration": 12492,
  "status": "passed"
});
formatter.match({
  "location": "PatternSteps.assoutputguard()"
});
formatter.result({
  "duration": 31060,
  "status": "passed"
});
formatter.match({
  "location": "PatternSteps.asscomparatorcheckedfaulttolerantsystem()"
});
formatter.result({
  "duration": 14655,
  "status": "passed"
});
formatter.uri("CAPEC_18_Step_3_3.feature");
formatter.feature({
  "line": 2,
  "name": "CAPEC-18: Embedding Scripts in Non-Script Elements",
  "description": "",
  "id": "capec-18:-embedding-scripts-in-non-script-elements",
  "keyword": "Feature",
  "tags": [
    {
      "line": 1,
      "name": "@capec18"
    }
  ]
});
formatter.scenario({
  "comments": [
    {
      "line": 3,
      "value": "#3. Exploit"
    }
  ],
  "line": 4,
  "name": "Step3.3 Content spoofing",
  "description": "",
  "id": "capec-18:-embedding-scripts-in-non-script-elements;step3.3-content-spoofing",
  "type": "scenario",
  "keyword": "Scenario"
});
formatter.step({
  "line": 5,
  "name": "prepare to Content spoofing",
  "keyword": "Given "
});
formatter.step({
  "line": 6,
  "name": "Try to Content spoofing",
  "keyword": "When "
});
formatter.step({
  "comments": [
    {
      "line": 7,
      "value": "# assertion for attack step success"
    }
  ],
  "line": 8,
  "name": "Assert the success of Content spoofing",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 9,
      "value": "#assertions for security pattern testing (checker whether the pattern consequences are observed)"
    }
  ],
  "line": 10,
  "name": "assert the consequences of the pattern audit interceptor",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 11,
      "value": "# depends secure logger"
    }
  ],
  "line": 12,
  "name": "assert the consequences of the pattern secure logger",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 13,
      "value": "# benifits audit interceptor"
    }
  ],
  "line": 14,
  "name": "assert the consequences of the pattern application firewall",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 15,
      "value": "# alternative output guard"
    },
    {
      "line": 16,
      "value": "# alternative input guard"
    }
  ],
  "line": 17,
  "name": "assert the consequences of the pattern input guard",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 18,
      "value": "# alternative application firewall"
    },
    {
      "line": 19,
      "value": "# benifits output guard"
    }
  ],
  "line": 20,
  "name": "assert the consequences of the pattern output guard",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 21,
      "value": "# alternative application firewall"
    },
    {
      "line": 22,
      "value": "# benifits input guard"
    }
  ],
  "line": 23,
  "name": "assert the consequences of the pattern comparator checked fault tolerant system",
  "keyword": "Then "
});
formatter.match({
  "location": "contentspoofing.precontentspoofing()"
});
formatter.result({
  "duration": 86572,
  "status": "passed"
});
formatter.match({
  "location": "contentspoofing.trycontentspoofing()"
});
formatter.result({
  "duration": 26128,
  "status": "passed"
});
formatter.match({
  "location": "contentspoofing.asscontentspoofing()"
});
formatter.result({
  "duration": 19655,
  "status": "passed"
});
formatter.match({
  "location": "PatternSteps.assauditinterceptor()"
});
formatter.result({
  "duration": 29070,
  "status": "passed"
});
formatter.match({
  "location": "PatternSteps.asssecurelogger()"
});
formatter.result({
  "duration": 14185,
  "status": "passed"
});
formatter.match({
  "location": "PatternSteps.assapplicationfirewall()"
});
formatter.result({
  "duration": 14332,
  "status": "passed"
});
formatter.match({
  "location": "PatternSteps.assinputguard()"
});
formatter.result({
  "duration": 19490,
  "status": "passed"
});
formatter.match({
  "location": "PatternSteps.assoutputguard()"
});
formatter.result({
  "duration": 25667,
  "status": "passed"
});
formatter.match({
  "location": "PatternSteps.asscomparatorcheckedfaulttolerantsystem()"
});
formatter.result({
  "duration": 15036,
  "status": "passed"
});
formatter.uri("CAPEC_193_Step_1_1.feature");
formatter.feature({
  "line": 2,
  "name": "CAPEC-193: PHP Remote File Inclusion",
  "description": "",
  "id": "capec-193:-php-remote-file-inclusion",
  "keyword": "Feature",
  "tags": [
    {
      "line": 1,
      "name": "@capec193"
    }
  ]
});
formatter.scenario({
  "comments": [
    {
      "line": 3,
      "value": "#1. Explore"
    }
  ],
  "line": 4,
  "name": "Step1.1 Survey application",
  "description": "",
  "id": "capec-193:-php-remote-file-inclusion;step1.1-survey-application",
  "type": "scenario",
  "keyword": "Scenario"
});
formatter.step({
  "line": 5,
  "name": "prepare to Survey application",
  "keyword": "Given "
});
formatter.step({
  "line": 6,
  "name": "Try to Survey application",
  "keyword": "When "
});
formatter.step({
  "comments": [
    {
      "line": 7,
      "value": "# assertion for attack step success"
    }
  ],
  "line": 8,
  "name": "Assert the success of Survey application",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 9,
      "value": "#assertions for security pattern testing (checker whether the pattern consequences are observed)"
    }
  ],
  "line": 10,
  "name": "assert the consequences of the pattern",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 11,
      "value": "#"
    }
  ],
  "line": 12,
  "name": "assert the consequences of the pattern audit interceptor",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 13,
      "value": "# depends secure logger"
    }
  ],
  "line": 14,
  "name": "assert the consequences of the pattern secure logger",
  "keyword": "Then "
});
formatter.match({
  "location": "survey.presurvey()"
});
formatter.result({
  "duration": 0,
  "error_message": "cucumber.runtime.AmbiguousStepDefinitionsException: ✽.Given prepare to Survey application(CAPEC_193_Step_1_1.feature:5) matches more than one step definition:\n  prepare to Survey in survey.presurvey()\n  prepare to Survey application in surveyapplication.presurveyapplication()\n\n\tat cucumber.runtime.RuntimeGlue.stepDefinitionMatch(RuntimeGlue.java:71)\n\tat cucumber.runtime.Runtime.runStep(Runtime.java:265)\n\tat cucumber.runtime.model.StepContainer.runStep(StepContainer.java:44)\n\tat cucumber.runtime.model.StepContainer.runSteps(StepContainer.java:39)\n\tat cucumber.runtime.model.CucumberScenario.run(CucumberScenario.java:48)\n\tat cucumber.runtime.junit.ExecutionUnitRunner.run(ExecutionUnitRunner.java:91)\n\tat cucumber.runtime.junit.FeatureRunner.runChild(FeatureRunner.java:63)\n\tat cucumber.runtime.junit.FeatureRunner.runChild(FeatureRunner.java:18)\n\tat org.junit.runners.ParentRunner$3.run(ParentRunner.java:238)\n\tat org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:63)\n\tat org.junit.runners.ParentRunner.runChildren(ParentRunner.java:236)\n\tat org.junit.runners.ParentRunner.access$000(ParentRunner.java:53)\n\tat org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:229)\n\tat org.junit.runners.ParentRunner.run(ParentRunner.java:309)\n\tat cucumber.runtime.junit.FeatureRunner.run(FeatureRunner.java:70)\n\tat cucumber.api.junit.Cucumber.runChild(Cucumber.java:93)\n\tat cucumber.api.junit.Cucumber.runChild(Cucumber.java:37)\n\tat org.junit.runners.ParentRunner$3.run(ParentRunner.java:238)\n\tat org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:63)\n\tat org.junit.runners.ParentRunner.runChildren(ParentRunner.java:236)\n\tat org.junit.runners.ParentRunner.access$000(ParentRunner.java:53)\n\tat org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:229)\n\tat org.junit.internal.runners.statements.RunAfters.evaluate(RunAfters.java:27)\n\tat org.junit.runners.ParentRunner.run(ParentRunner.java:309)\n\tat cucumber.api.junit.Cucumber.run(Cucumber.java:98)\n\tat org.eclipse.jdt.internal.junit4.runner.JUnit4TestReference.run(JUnit4TestReference.java:86)\n\tat org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:459)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:678)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:382)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:192)\n",
  "status": "failed"
});
formatter.match({
  "location": "survey.trysurvey()"
});
formatter.result({
  "duration": 0,
  "error_message": "cucumber.runtime.AmbiguousStepDefinitionsException: ✽.When Try to Survey application(CAPEC_193_Step_1_1.feature:6) matches more than one step definition:\n  Try to Survey in survey.trysurvey()\n  Try to Survey application in surveyapplication.trysurveyapplication()\n\n\tat cucumber.runtime.RuntimeGlue.stepDefinitionMatch(RuntimeGlue.java:71)\n\tat cucumber.runtime.Runtime.runStep(Runtime.java:265)\n\tat cucumber.runtime.model.StepContainer.runStep(StepContainer.java:44)\n\tat cucumber.runtime.model.StepContainer.runSteps(StepContainer.java:39)\n\tat cucumber.runtime.model.CucumberScenario.run(CucumberScenario.java:48)\n\tat cucumber.runtime.junit.ExecutionUnitRunner.run(ExecutionUnitRunner.java:91)\n\tat cucumber.runtime.junit.FeatureRunner.runChild(FeatureRunner.java:63)\n\tat cucumber.runtime.junit.FeatureRunner.runChild(FeatureRunner.java:18)\n\tat org.junit.runners.ParentRunner$3.run(ParentRunner.java:238)\n\tat org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:63)\n\tat org.junit.runners.ParentRunner.runChildren(ParentRunner.java:236)\n\tat org.junit.runners.ParentRunner.access$000(ParentRunner.java:53)\n\tat org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:229)\n\tat org.junit.runners.ParentRunner.run(ParentRunner.java:309)\n\tat cucumber.runtime.junit.FeatureRunner.run(FeatureRunner.java:70)\n\tat cucumber.api.junit.Cucumber.runChild(Cucumber.java:93)\n\tat cucumber.api.junit.Cucumber.runChild(Cucumber.java:37)\n\tat org.junit.runners.ParentRunner$3.run(ParentRunner.java:238)\n\tat org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:63)\n\tat org.junit.runners.ParentRunner.runChildren(ParentRunner.java:236)\n\tat org.junit.runners.ParentRunner.access$000(ParentRunner.java:53)\n\tat org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:229)\n\tat org.junit.internal.runners.statements.RunAfters.evaluate(RunAfters.java:27)\n\tat org.junit.runners.ParentRunner.run(ParentRunner.java:309)\n\tat cucumber.api.junit.Cucumber.run(Cucumber.java:98)\n\tat org.eclipse.jdt.internal.junit4.runner.JUnit4TestReference.run(JUnit4TestReference.java:86)\n\tat org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:459)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:678)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:382)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:192)\n",
  "status": "failed"
});
formatter.match({
  "location": "survey.asssurvey()"
});
formatter.result({
  "duration": 0,
  "error_message": "cucumber.runtime.AmbiguousStepDefinitionsException: ✽.Then Assert the success of Survey application(CAPEC_193_Step_1_1.feature:8) matches more than one step definition:\n  Assert the success of Survey in survey.asssurvey()\n  Assert the success of Survey application in surveyapplication.asssurveyapplication()\n\n\tat cucumber.runtime.RuntimeGlue.stepDefinitionMatch(RuntimeGlue.java:71)\n\tat cucumber.runtime.Runtime.runStep(Runtime.java:265)\n\tat cucumber.runtime.model.StepContainer.runStep(StepContainer.java:44)\n\tat cucumber.runtime.model.StepContainer.runSteps(StepContainer.java:39)\n\tat cucumber.runtime.model.CucumberScenario.run(CucumberScenario.java:48)\n\tat cucumber.runtime.junit.ExecutionUnitRunner.run(ExecutionUnitRunner.java:91)\n\tat cucumber.runtime.junit.FeatureRunner.runChild(FeatureRunner.java:63)\n\tat cucumber.runtime.junit.FeatureRunner.runChild(FeatureRunner.java:18)\n\tat org.junit.runners.ParentRunner$3.run(ParentRunner.java:238)\n\tat org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:63)\n\tat org.junit.runners.ParentRunner.runChildren(ParentRunner.java:236)\n\tat org.junit.runners.ParentRunner.access$000(ParentRunner.java:53)\n\tat org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:229)\n\tat org.junit.runners.ParentRunner.run(ParentRunner.java:309)\n\tat cucumber.runtime.junit.FeatureRunner.run(FeatureRunner.java:70)\n\tat cucumber.api.junit.Cucumber.runChild(Cucumber.java:93)\n\tat cucumber.api.junit.Cucumber.runChild(Cucumber.java:37)\n\tat org.junit.runners.ParentRunner$3.run(ParentRunner.java:238)\n\tat org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:63)\n\tat org.junit.runners.ParentRunner.runChildren(ParentRunner.java:236)\n\tat org.junit.runners.ParentRunner.access$000(ParentRunner.java:53)\n\tat org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:229)\n\tat org.junit.internal.runners.statements.RunAfters.evaluate(RunAfters.java:27)\n\tat org.junit.runners.ParentRunner.run(ParentRunner.java:309)\n\tat cucumber.api.junit.Cucumber.run(Cucumber.java:98)\n\tat org.eclipse.jdt.internal.junit4.runner.JUnit4TestReference.run(JUnit4TestReference.java:86)\n\tat org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:459)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:678)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:382)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:192)\n",
  "status": "failed"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({
  "location": "PatternSteps.assauditinterceptor()"
});
formatter.result({
  "status": "skipped"
});
formatter.match({
  "location": "PatternSteps.asssecurelogger()"
});
formatter.result({
  "status": "skipped"
});
formatter.uri("CAPEC_193_Step_2_1.feature");
formatter.feature({
  "line": 2,
  "name": "CAPEC-193: PHP Remote File Inclusion",
  "description": "",
  "id": "capec-193:-php-remote-file-inclusion",
  "keyword": "Feature",
  "tags": [
    {
      "line": 1,
      "name": "@capec193"
    }
  ]
});
formatter.scenario({
  "comments": [
    {
      "line": 3,
      "value": "#2. Experiment"
    }
  ],
  "line": 4,
  "name": "Step2.1 Attempt variations on input parameters",
  "description": "",
  "id": "capec-193:-php-remote-file-inclusion;step2.1-attempt-variations-on-input-parameters",
  "type": "scenario",
  "keyword": "Scenario"
});
formatter.step({
  "line": 5,
  "name": "prepare to Attempt variations on input parameters",
  "keyword": "Given "
});
formatter.step({
  "line": 6,
  "name": "Try to Attempt variations on input parameters",
  "keyword": "When "
});
formatter.step({
  "comments": [
    {
      "line": 7,
      "value": "# assertion for attack step success"
    }
  ],
  "line": 8,
  "name": "Assert the success of Attempt variations on input parameters",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 9,
      "value": "#assertions for security pattern testing (checker whether the pattern consequences are observed)"
    }
  ],
  "line": 10,
  "name": "assert the consequences of the pattern audit interceptor",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 11,
      "value": "# depends secure logger"
    }
  ],
  "line": 12,
  "name": "assert the consequences of the pattern secure logger",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 13,
      "value": "# benifits audit interceptor"
    }
  ],
  "line": 14,
  "name": "assert the consequences of the pattern application firewall",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 15,
      "value": "# alternative input guard"
    }
  ],
  "line": 16,
  "name": "assert the consequences of the pattern input guard",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 17,
      "value": "# alternative application firewall"
    }
  ],
  "line": 18,
  "name": "assert the consequences of the pattern",
  "keyword": "Then "
});
formatter.match({
  "location": "attemptvariationsoninputparameters.preattemptvariationsoninputparameters()"
});
formatter.result({
  "duration": 3419903,
  "error_message": "net.continuumsecurity.proxy.ProxyException: org.zaproxy.clientapi.core.ClientApiException: java.net.ConnectException: Connection refused\n\tat net.continuumsecurity.proxy.ZAProxyScanner.validateMinimumRequiredZapVersion(ZAProxyScanner.java:96)\n\tat net.continuumsecurity.proxy.ZAProxyScanner.\u003cinit\u003e(ZAProxyScanner.java:38)\n\tat steps.attemptvariationsoninputparameters.preattemptvariationsoninputparameters(attemptvariationsoninputparameters.java:19)\n\tat ✽.Given prepare to Attempt variations on input parameters(CAPEC_193_Step_2_1.feature:5)\nCaused by: org.zaproxy.clientapi.core.ClientApiException: java.net.ConnectException: Connection refused\n\tat org.zaproxy.clientapi.core.ClientApi.callApiDom(ClientApi.java:307)\n\tat org.zaproxy.clientapi.core.ClientApi.callApi(ClientApi.java:289)\n\tat org.zaproxy.clientapi.gen.Core.version(Core.java:158)\n\tat net.continuumsecurity.proxy.ZAProxyScanner.validateMinimumRequiredZapVersion(ZAProxyScanner.java:85)\n\tat net.continuumsecurity.proxy.ZAProxyScanner.\u003cinit\u003e(ZAProxyScanner.java:38)\n\tat steps.attemptvariationsoninputparameters.preattemptvariationsoninputparameters(attemptvariationsoninputparameters.java:19)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.lang.reflect.Method.invoke(Method.java:498)\n\tat cucumber.runtime.Utils$1.call(Utils.java:37)\n\tat cucumber.runtime.Timeout.timeout(Timeout.java:13)\n\tat cucumber.runtime.Utils.invoke(Utils.java:31)\n\tat cucumber.runtime.java.JavaStepDefinition.execute(JavaStepDefinition.java:37)\n\tat cucumber.runtime.StepDefinitionMatch.runStep(StepDefinitionMatch.java:37)\n\tat cucumber.runtime.Runtime.runStep(Runtime.java:298)\n\tat cucumber.runtime.model.StepContainer.runStep(StepContainer.java:44)\n\tat cucumber.runtime.model.StepContainer.runSteps(StepContainer.java:39)\n\tat cucumber.runtime.model.CucumberScenario.run(CucumberScenario.java:48)\n\tat cucumber.runtime.junit.ExecutionUnitRunner.run(ExecutionUnitRunner.java:91)\n\tat cucumber.runtime.junit.FeatureRunner.runChild(FeatureRunner.java:63)\n\tat cucumber.runtime.junit.FeatureRunner.runChild(FeatureRunner.java:18)\n\tat org.junit.runners.ParentRunner$3.run(ParentRunner.java:238)\n\tat org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:63)\n\tat org.junit.runners.ParentRunner.runChildren(ParentRunner.java:236)\n\tat org.junit.runners.ParentRunner.access$000(ParentRunner.java:53)\n\tat org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:229)\n\tat org.junit.runners.ParentRunner.run(ParentRunner.java:309)\n\tat cucumber.runtime.junit.FeatureRunner.run(FeatureRunner.java:70)\n\tat cucumber.api.junit.Cucumber.runChild(Cucumber.java:93)\n\tat cucumber.api.junit.Cucumber.runChild(Cucumber.java:37)\n\tat org.junit.runners.ParentRunner$3.run(ParentRunner.java:238)\n\tat org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:63)\n\tat org.junit.runners.ParentRunner.runChildren(ParentRunner.java:236)\n\tat org.junit.runners.ParentRunner.access$000(ParentRunner.java:53)\n\tat org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:229)\n\tat org.junit.internal.runners.statements.RunAfters.evaluate(RunAfters.java:27)\n\tat org.junit.runners.ParentRunner.run(ParentRunner.java:309)\n\tat cucumber.api.junit.Cucumber.run(Cucumber.java:98)\n\tat org.eclipse.jdt.internal.junit4.runner.JUnit4TestReference.run(JUnit4TestReference.java:86)\n\tat org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:459)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:678)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:382)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:192)\nCaused by: java.net.ConnectException: Connection refused\n\tat java.net.PlainSocketImpl.socketConnect(Native Method)\n\tat java.net.AbstractPlainSocketImpl.doConnect(AbstractPlainSocketImpl.java:350)\n\tat java.net.AbstractPlainSocketImpl.connectToAddress(AbstractPlainSocketImpl.java:206)\n\tat java.net.AbstractPlainSocketImpl.connect(AbstractPlainSocketImpl.java:188)\n\tat java.net.Socket.connect(Socket.java:589)\n\tat java.net.Socket.connect(Socket.java:538)\n\tat sun.net.NetworkClient.doConnect(NetworkClient.java:180)\n\tat sun.net.www.http.HttpClient.openServer(HttpClient.java:432)\n\tat sun.net.www.http.HttpClient$1.run(HttpClient.java:484)\n\tat sun.net.www.http.HttpClient$1.run(HttpClient.java:482)\n\tat java.security.AccessController.doPrivileged(Native Method)\n\tat sun.net.www.http.HttpClient.privilegedOpenServer(HttpClient.java:481)\n\tat sun.net.www.http.HttpClient.openServer(HttpClient.java:522)\n\tat sun.net.www.http.HttpClient.\u003cinit\u003e(HttpClient.java:211)\n\tat sun.net.www.http.HttpClient.New(HttpClient.java:308)\n\tat sun.net.www.http.HttpClient.New(HttpClient.java:326)\n\tat sun.net.www.protocol.http.HttpURLConnection.getNewHttpClient(HttpURLConnection.java:1169)\n\tat sun.net.www.protocol.http.HttpURLConnection.plainConnect0(HttpURLConnection.java:1148)\n\tat sun.net.www.protocol.http.HttpURLConnection.plainConnect(HttpURLConnection.java:999)\n\tat sun.net.www.protocol.http.HttpURLConnection.connect(HttpURLConnection.java:933)\n\tat org.zaproxy.clientapi.core.ClientApi.getConnectionInputStream(ClientApi.java:313)\n\tat org.zaproxy.clientapi.core.ClientApi.callApiDom(ClientApi.java:305)\n\t... 44 more\n",
  "status": "failed"
});
formatter.match({
  "location": "attemptvariationsoninputparameters.tryattemptvariationsoninputparameters()"
});
formatter.result({
  "status": "skipped"
});
formatter.match({
  "location": "attemptvariationsoninputparameters.assattemptvariationsoninputparameters()"
});
formatter.result({
  "status": "skipped"
});
formatter.match({
  "location": "PatternSteps.assauditinterceptor()"
});
formatter.result({
  "status": "skipped"
});
formatter.match({
  "location": "PatternSteps.asssecurelogger()"
});
formatter.result({
  "status": "skipped"
});
formatter.match({
  "location": "PatternSteps.assapplicationfirewall()"
});
formatter.result({
  "status": "skipped"
});
formatter.match({
  "location": "PatternSteps.assinputguard()"
});
formatter.result({
  "status": "skipped"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.uri("CAPEC_193_Step_3_1.feature");
formatter.feature({
  "line": 2,
  "name": "CAPEC-193: PHP Remote File Inclusion",
  "description": "",
  "id": "capec-193:-php-remote-file-inclusion",
  "keyword": "Feature",
  "tags": [
    {
      "line": 1,
      "name": "@capec193"
    }
  ]
});
formatter.scenario({
  "comments": [
    {
      "line": 3,
      "value": "#3. Exploit"
    }
  ],
  "line": 4,
  "name": "Step3.1 Run arbitrary server-side code",
  "description": "",
  "id": "capec-193:-php-remote-file-inclusion;step3.1-run-arbitrary-server-side-code",
  "type": "scenario",
  "keyword": "Scenario"
});
formatter.step({
  "line": 5,
  "name": "prepare to Run arbitrary server-side code",
  "keyword": "Given "
});
formatter.step({
  "line": 6,
  "name": "Try to Run arbitrary server-side code",
  "keyword": "When "
});
formatter.step({
  "comments": [
    {
      "line": 7,
      "value": "# assertion for attack step success"
    }
  ],
  "line": 8,
  "name": "Assert the success of Run arbitrary server-side code",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 9,
      "value": "#assertions for security pattern testing (checker whether the pattern consequences are observed)"
    }
  ],
  "line": 10,
  "name": "assert the consequences of the pattern secure logger",
  "keyword": "Then "
});
formatter.step({
  "line": 11,
  "name": "assert the consequences of the pattern application firewall",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 12,
      "value": "# alternative input guard"
    }
  ],
  "line": 13,
  "name": "assert the consequences of the pattern input guard",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 14,
      "value": "# alternative application firewall"
    }
  ],
  "line": 15,
  "name": "assert the consequences of the pattern",
  "keyword": "Then "
});
formatter.match({
  "location": "runarbitraryserversidecode.prerunarbitraryserversidecode()"
});
formatter.result({
  "duration": 88093,
  "status": "passed"
});
formatter.match({
  "location": "runarbitraryserversidecode.tryrunarbitraryserversidecode()"
});
formatter.result({
  "duration": 18928,
  "status": "passed"
});
formatter.match({
  "location": "runarbitraryserversidecode.assrunarbitraryserversidecode()"
});
formatter.result({
  "duration": 12434,
  "status": "passed"
});
formatter.match({
  "location": "PatternSteps.asssecurelogger()"
});
formatter.result({
  "duration": 21550,
  "status": "passed"
});
formatter.match({
  "location": "PatternSteps.assapplicationfirewall()"
});
formatter.result({
  "duration": 11311,
  "status": "passed"
});
formatter.match({
  "location": "PatternSteps.assinputguard()"
});
formatter.result({
  "duration": 10555,
  "status": "passed"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.uri("CAPEC_196_Step_1_1.feature");
formatter.feature({
  "line": 2,
  "name": "CAPEC-196: Session Credential Falsification through Forging",
  "description": "",
  "id": "capec-196:-session-credential-falsification-through-forging",
  "keyword": "Feature",
  "tags": [
    {
      "line": 1,
      "name": "@capec196"
    }
  ]
});
formatter.scenario({
  "comments": [
    {
      "line": 3,
      "value": "#1. Explore"
    }
  ],
  "line": 4,
  "name": "Step1.1 Analyze and Understand Session IDs",
  "description": "",
  "id": "capec-196:-session-credential-falsification-through-forging;step1.1-analyze-and-understand-session-ids",
  "type": "scenario",
  "keyword": "Scenario"
});
formatter.step({
  "line": 5,
  "name": "prepare to Analyze and Understand Session IDs",
  "keyword": "Given "
});
formatter.step({
  "line": 6,
  "name": "Try to Analyze and Understand Session IDs",
  "keyword": "When "
});
formatter.step({
  "comments": [
    {
      "line": 7,
      "value": "# assertion for attack step success"
    }
  ],
  "line": 8,
  "name": "Assert the success of Analyze and Understand Session IDs",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 9,
      "value": "#assertions for security pattern testing (checker whether the pattern consequences are observed)"
    }
  ],
  "line": 10,
  "name": "assert the consequences of the pattern",
  "keyword": "Then "
});
formatter.match({
  "location": "analyzeandunderstandsessionids.preanalyzeandunderstandsessionids()"
});
formatter.result({
  "duration": 63905,
  "status": "passed"
});
formatter.match({
  "location": "analyzeandunderstandsessionids.tryanalyzeandunderstandsessionids()"
});
formatter.result({
  "duration": 10816,
  "status": "passed"
});
formatter.match({
  "location": "analyzeandunderstandsessionids.assanalyzeandunderstandsessionids()"
});
formatter.result({
  "duration": 10977,
  "status": "passed"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.uri("CAPEC_196_Step_2_1.feature");
formatter.feature({
  "line": 2,
  "name": "CAPEC-196: Session Credential Falsification through Forging",
  "description": "",
  "id": "capec-196:-session-credential-falsification-through-forging",
  "keyword": "Feature",
  "tags": [
    {
      "line": 1,
      "name": "@capec196"
    }
  ]
});
formatter.scenario({
  "comments": [
    {
      "line": 3,
      "value": "#2. Experiment"
    }
  ],
  "line": 4,
  "name": "Step2.1 Create Session IDs.",
  "description": "",
  "id": "capec-196:-session-credential-falsification-through-forging;step2.1-create-session-ids.",
  "type": "scenario",
  "keyword": "Scenario"
});
formatter.step({
  "line": 5,
  "name": "prepare to Create Session IDs.",
  "keyword": "Given "
});
formatter.step({
  "line": 6,
  "name": "Try to Create Session IDs.",
  "keyword": "When "
});
formatter.step({
  "comments": [
    {
      "line": 7,
      "value": "# assertion for attack step success"
    }
  ],
  "line": 8,
  "name": "Assert the success of Create Session IDs.",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 9,
      "value": "#assertions for security pattern testing (checker whether the pattern consequences are observed)"
    }
  ],
  "line": 10,
  "name": "assert the consequences of the pattern secure logger",
  "keyword": "Then "
});
formatter.match({
  "location": "createsessionids.precreatesessionids()"
});
formatter.result({
  "duration": 48082,
  "status": "passed"
});
formatter.match({
  "location": "createsessionids.trycreatesessionids()"
});
formatter.result({
  "duration": 10729,
  "status": "passed"
});
formatter.match({
  "location": "createsessionids.asscreatesessionids()"
});
formatter.result({
  "duration": 10785,
  "status": "passed"
});
formatter.match({
  "location": "PatternSteps.asssecurelogger()"
});
formatter.result({
  "duration": 16093,
  "status": "passed"
});
formatter.uri("CAPEC_196_Step_3_1.feature");
formatter.feature({
  "line": 2,
  "name": "CAPEC-196: Session Credential Falsification through Forging",
  "description": "",
  "id": "capec-196:-session-credential-falsification-through-forging",
  "keyword": "Feature",
  "tags": [
    {
      "line": 1,
      "name": "@capec196"
    }
  ]
});
formatter.scenario({
  "comments": [
    {
      "line": 3,
      "value": "#3. Exploit"
    }
  ],
  "line": 4,
  "name": "Step3.1 Abuse the Victim\u0027s Session Credentials",
  "description": "",
  "id": "capec-196:-session-credential-falsification-through-forging;step3.1-abuse-the-victim\u0027s-session-credentials",
  "type": "scenario",
  "keyword": "Scenario"
});
formatter.step({
  "line": 5,
  "name": "prepare to Abuse the Victim\u0027s Session Credentials",
  "keyword": "Given "
});
formatter.step({
  "line": 6,
  "name": "Try to Abuse the Victim\u0027s Session Credentials",
  "keyword": "When "
});
formatter.step({
  "comments": [
    {
      "line": 7,
      "value": "# assertion for attack step success"
    }
  ],
  "line": 8,
  "name": "Assert the success of Abuse the Victim\u0027s Session Credentials",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 9,
      "value": "#assertions for security pattern testing (checker whether the pattern consequences are observed)"
    }
  ],
  "line": 10,
  "name": "assert the consequences of the pattern audit interceptor",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 11,
      "value": "# depends secure logger"
    }
  ],
  "line": 12,
  "name": "assert the consequences of the pattern secure logger",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 13,
      "value": "# benifits audit interceptor"
    }
  ],
  "line": 14,
  "name": "assert the consequences of the pattern application firewall",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 15,
      "value": "# alternative input guard"
    }
  ],
  "line": 16,
  "name": "assert the consequences of the pattern input guard",
  "keyword": "Then "
});
formatter.match({
  "location": "abusethevictimssession.preabusethevictimssession()"
});
formatter.result({
  "duration": 0,
  "error_message": "cucumber.runtime.AmbiguousStepDefinitionsException: ✽.Given prepare to Abuse the Victim\u0027s Session Credentials(CAPEC_196_Step_3_1.feature:5) matches more than one step definition:\n  prepare to Abuse the Victim\u0027s Session in abusethevictimssession.preabusethevictimssession()\n  prepare to Abuse the Victim\u0027s Session Credentials in abusethevictimssessioncredentials.preabusethevictimssessioncredentials()\n\n\tat cucumber.runtime.RuntimeGlue.stepDefinitionMatch(RuntimeGlue.java:71)\n\tat cucumber.runtime.Runtime.runStep(Runtime.java:265)\n\tat cucumber.runtime.model.StepContainer.runStep(StepContainer.java:44)\n\tat cucumber.runtime.model.StepContainer.runSteps(StepContainer.java:39)\n\tat cucumber.runtime.model.CucumberScenario.run(CucumberScenario.java:48)\n\tat cucumber.runtime.junit.ExecutionUnitRunner.run(ExecutionUnitRunner.java:91)\n\tat cucumber.runtime.junit.FeatureRunner.runChild(FeatureRunner.java:63)\n\tat cucumber.runtime.junit.FeatureRunner.runChild(FeatureRunner.java:18)\n\tat org.junit.runners.ParentRunner$3.run(ParentRunner.java:238)\n\tat org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:63)\n\tat org.junit.runners.ParentRunner.runChildren(ParentRunner.java:236)\n\tat org.junit.runners.ParentRunner.access$000(ParentRunner.java:53)\n\tat org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:229)\n\tat org.junit.runners.ParentRunner.run(ParentRunner.java:309)\n\tat cucumber.runtime.junit.FeatureRunner.run(FeatureRunner.java:70)\n\tat cucumber.api.junit.Cucumber.runChild(Cucumber.java:93)\n\tat cucumber.api.junit.Cucumber.runChild(Cucumber.java:37)\n\tat org.junit.runners.ParentRunner$3.run(ParentRunner.java:238)\n\tat org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:63)\n\tat org.junit.runners.ParentRunner.runChildren(ParentRunner.java:236)\n\tat org.junit.runners.ParentRunner.access$000(ParentRunner.java:53)\n\tat org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:229)\n\tat org.junit.internal.runners.statements.RunAfters.evaluate(RunAfters.java:27)\n\tat org.junit.runners.ParentRunner.run(ParentRunner.java:309)\n\tat cucumber.api.junit.Cucumber.run(Cucumber.java:98)\n\tat org.eclipse.jdt.internal.junit4.runner.JUnit4TestReference.run(JUnit4TestReference.java:86)\n\tat org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:459)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:678)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:382)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:192)\n",
  "status": "failed"
});
formatter.match({
  "location": "abusethevictimssession.tryabusethevictimssession()"
});
formatter.result({
  "duration": 0,
  "error_message": "cucumber.runtime.AmbiguousStepDefinitionsException: ✽.When Try to Abuse the Victim\u0027s Session Credentials(CAPEC_196_Step_3_1.feature:6) matches more than one step definition:\n  Try to Abuse the Victim\u0027s Session in abusethevictimssession.tryabusethevictimssession()\n  Try to Abuse the Victim\u0027s Session Credentials in abusethevictimssessioncredentials.tryabusethevictimssessioncredentials()\n\n\tat cucumber.runtime.RuntimeGlue.stepDefinitionMatch(RuntimeGlue.java:71)\n\tat cucumber.runtime.Runtime.runStep(Runtime.java:265)\n\tat cucumber.runtime.model.StepContainer.runStep(StepContainer.java:44)\n\tat cucumber.runtime.model.StepContainer.runSteps(StepContainer.java:39)\n\tat cucumber.runtime.model.CucumberScenario.run(CucumberScenario.java:48)\n\tat cucumber.runtime.junit.ExecutionUnitRunner.run(ExecutionUnitRunner.java:91)\n\tat cucumber.runtime.junit.FeatureRunner.runChild(FeatureRunner.java:63)\n\tat cucumber.runtime.junit.FeatureRunner.runChild(FeatureRunner.java:18)\n\tat org.junit.runners.ParentRunner$3.run(ParentRunner.java:238)\n\tat org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:63)\n\tat org.junit.runners.ParentRunner.runChildren(ParentRunner.java:236)\n\tat org.junit.runners.ParentRunner.access$000(ParentRunner.java:53)\n\tat org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:229)\n\tat org.junit.runners.ParentRunner.run(ParentRunner.java:309)\n\tat cucumber.runtime.junit.FeatureRunner.run(FeatureRunner.java:70)\n\tat cucumber.api.junit.Cucumber.runChild(Cucumber.java:93)\n\tat cucumber.api.junit.Cucumber.runChild(Cucumber.java:37)\n\tat org.junit.runners.ParentRunner$3.run(ParentRunner.java:238)\n\tat org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:63)\n\tat org.junit.runners.ParentRunner.runChildren(ParentRunner.java:236)\n\tat org.junit.runners.ParentRunner.access$000(ParentRunner.java:53)\n\tat org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:229)\n\tat org.junit.internal.runners.statements.RunAfters.evaluate(RunAfters.java:27)\n\tat org.junit.runners.ParentRunner.run(ParentRunner.java:309)\n\tat cucumber.api.junit.Cucumber.run(Cucumber.java:98)\n\tat org.eclipse.jdt.internal.junit4.runner.JUnit4TestReference.run(JUnit4TestReference.java:86)\n\tat org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:459)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:678)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:382)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:192)\n",
  "status": "failed"
});
formatter.match({
  "location": "abusethevictimssession.assabusethevictimssession()"
});
formatter.result({
  "duration": 0,
  "error_message": "cucumber.runtime.AmbiguousStepDefinitionsException: ✽.Then Assert the success of Abuse the Victim\u0027s Session Credentials(CAPEC_196_Step_3_1.feature:8) matches more than one step definition:\n  Assert the success of Abuse the Victim\u0027s Session in abusethevictimssession.assabusethevictimssession()\n  Assert the success of Abuse the Victim\u0027s Session Credentials in abusethevictimssessioncredentials.assabusethevictimssessioncredentials()\n\n\tat cucumber.runtime.RuntimeGlue.stepDefinitionMatch(RuntimeGlue.java:71)\n\tat cucumber.runtime.Runtime.runStep(Runtime.java:265)\n\tat cucumber.runtime.model.StepContainer.runStep(StepContainer.java:44)\n\tat cucumber.runtime.model.StepContainer.runSteps(StepContainer.java:39)\n\tat cucumber.runtime.model.CucumberScenario.run(CucumberScenario.java:48)\n\tat cucumber.runtime.junit.ExecutionUnitRunner.run(ExecutionUnitRunner.java:91)\n\tat cucumber.runtime.junit.FeatureRunner.runChild(FeatureRunner.java:63)\n\tat cucumber.runtime.junit.FeatureRunner.runChild(FeatureRunner.java:18)\n\tat org.junit.runners.ParentRunner$3.run(ParentRunner.java:238)\n\tat org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:63)\n\tat org.junit.runners.ParentRunner.runChildren(ParentRunner.java:236)\n\tat org.junit.runners.ParentRunner.access$000(ParentRunner.java:53)\n\tat org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:229)\n\tat org.junit.runners.ParentRunner.run(ParentRunner.java:309)\n\tat cucumber.runtime.junit.FeatureRunner.run(FeatureRunner.java:70)\n\tat cucumber.api.junit.Cucumber.runChild(Cucumber.java:93)\n\tat cucumber.api.junit.Cucumber.runChild(Cucumber.java:37)\n\tat org.junit.runners.ParentRunner$3.run(ParentRunner.java:238)\n\tat org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:63)\n\tat org.junit.runners.ParentRunner.runChildren(ParentRunner.java:236)\n\tat org.junit.runners.ParentRunner.access$000(ParentRunner.java:53)\n\tat org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:229)\n\tat org.junit.internal.runners.statements.RunAfters.evaluate(RunAfters.java:27)\n\tat org.junit.runners.ParentRunner.run(ParentRunner.java:309)\n\tat cucumber.api.junit.Cucumber.run(Cucumber.java:98)\n\tat org.eclipse.jdt.internal.junit4.runner.JUnit4TestReference.run(JUnit4TestReference.java:86)\n\tat org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:459)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:678)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:382)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:192)\n",
  "status": "failed"
});
formatter.match({
  "location": "PatternSteps.assauditinterceptor()"
});
formatter.result({
  "status": "skipped"
});
formatter.match({
  "location": "PatternSteps.asssecurelogger()"
});
formatter.result({
  "status": "skipped"
});
formatter.match({
  "location": "PatternSteps.assapplicationfirewall()"
});
formatter.result({
  "status": "skipped"
});
formatter.match({
  "location": "PatternSteps.assinputguard()"
});
formatter.result({
  "status": "skipped"
});
formatter.uri("CAPEC_197_Step_1_1.feature");
formatter.feature({
  "line": 2,
  "name": "CAPEC-197: XML Entity Expansion",
  "description": "",
  "id": "capec-197:-xml-entity-expansion",
  "keyword": "Feature",
  "tags": [
    {
      "line": 1,
      "name": "@capec197"
    }
  ]
});
formatter.scenario({
  "comments": [
    {
      "line": 3,
      "value": "#1. Explore"
    }
  ],
  "line": 4,
  "name": "Step1.1 Survey the target",
  "description": "",
  "id": "capec-197:-xml-entity-expansion;step1.1-survey-the-target",
  "type": "scenario",
  "keyword": "Scenario"
});
formatter.step({
  "line": 5,
  "name": "prepare to Survey the target",
  "keyword": "Given "
});
formatter.step({
  "line": 6,
  "name": "Try to Survey the target",
  "keyword": "When "
});
formatter.step({
  "comments": [
    {
      "line": 7,
      "value": "# assertion for attack step success"
    }
  ],
  "line": 8,
  "name": "Assert the success of Survey the target",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 9,
      "value": "#assertions for security pattern testing (checker whether the pattern consequences are observed)"
    }
  ],
  "line": 10,
  "name": "assert the consequences of the pattern",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 11,
      "value": "#"
    }
  ],
  "line": 12,
  "name": "assert the consequences of the pattern audit interceptor",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 13,
      "value": "# depends secure logger"
    }
  ],
  "line": 14,
  "name": "assert the consequences of the pattern secure logger",
  "keyword": "Then "
});
formatter.match({
  "location": "survey.presurvey()"
});
formatter.result({
  "duration": 0,
  "error_message": "cucumber.runtime.AmbiguousStepDefinitionsException: ✽.Given prepare to Survey the target(CAPEC_197_Step_1_1.feature:5) matches more than one step definition:\n  prepare to Survey in survey.presurvey()\n  prepare to Survey the target in surveythetarget.presurveythetarget()\n\n\tat cucumber.runtime.RuntimeGlue.stepDefinitionMatch(RuntimeGlue.java:71)\n\tat cucumber.runtime.Runtime.runStep(Runtime.java:265)\n\tat cucumber.runtime.model.StepContainer.runStep(StepContainer.java:44)\n\tat cucumber.runtime.model.StepContainer.runSteps(StepContainer.java:39)\n\tat cucumber.runtime.model.CucumberScenario.run(CucumberScenario.java:48)\n\tat cucumber.runtime.junit.ExecutionUnitRunner.run(ExecutionUnitRunner.java:91)\n\tat cucumber.runtime.junit.FeatureRunner.runChild(FeatureRunner.java:63)\n\tat cucumber.runtime.junit.FeatureRunner.runChild(FeatureRunner.java:18)\n\tat org.junit.runners.ParentRunner$3.run(ParentRunner.java:238)\n\tat org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:63)\n\tat org.junit.runners.ParentRunner.runChildren(ParentRunner.java:236)\n\tat org.junit.runners.ParentRunner.access$000(ParentRunner.java:53)\n\tat org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:229)\n\tat org.junit.runners.ParentRunner.run(ParentRunner.java:309)\n\tat cucumber.runtime.junit.FeatureRunner.run(FeatureRunner.java:70)\n\tat cucumber.api.junit.Cucumber.runChild(Cucumber.java:93)\n\tat cucumber.api.junit.Cucumber.runChild(Cucumber.java:37)\n\tat org.junit.runners.ParentRunner$3.run(ParentRunner.java:238)\n\tat org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:63)\n\tat org.junit.runners.ParentRunner.runChildren(ParentRunner.java:236)\n\tat org.junit.runners.ParentRunner.access$000(ParentRunner.java:53)\n\tat org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:229)\n\tat org.junit.internal.runners.statements.RunAfters.evaluate(RunAfters.java:27)\n\tat org.junit.runners.ParentRunner.run(ParentRunner.java:309)\n\tat cucumber.api.junit.Cucumber.run(Cucumber.java:98)\n\tat org.eclipse.jdt.internal.junit4.runner.JUnit4TestReference.run(JUnit4TestReference.java:86)\n\tat org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:459)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:678)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:382)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:192)\n",
  "status": "failed"
});
formatter.match({
  "location": "survey.trysurvey()"
});
formatter.result({
  "duration": 0,
  "error_message": "cucumber.runtime.AmbiguousStepDefinitionsException: ✽.When Try to Survey the target(CAPEC_197_Step_1_1.feature:6) matches more than one step definition:\n  Try to Survey in survey.trysurvey()\n  Try to Survey the target in surveythetarget.trysurveythetarget()\n\n\tat cucumber.runtime.RuntimeGlue.stepDefinitionMatch(RuntimeGlue.java:71)\n\tat cucumber.runtime.Runtime.runStep(Runtime.java:265)\n\tat cucumber.runtime.model.StepContainer.runStep(StepContainer.java:44)\n\tat cucumber.runtime.model.StepContainer.runSteps(StepContainer.java:39)\n\tat cucumber.runtime.model.CucumberScenario.run(CucumberScenario.java:48)\n\tat cucumber.runtime.junit.ExecutionUnitRunner.run(ExecutionUnitRunner.java:91)\n\tat cucumber.runtime.junit.FeatureRunner.runChild(FeatureRunner.java:63)\n\tat cucumber.runtime.junit.FeatureRunner.runChild(FeatureRunner.java:18)\n\tat org.junit.runners.ParentRunner$3.run(ParentRunner.java:238)\n\tat org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:63)\n\tat org.junit.runners.ParentRunner.runChildren(ParentRunner.java:236)\n\tat org.junit.runners.ParentRunner.access$000(ParentRunner.java:53)\n\tat org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:229)\n\tat org.junit.runners.ParentRunner.run(ParentRunner.java:309)\n\tat cucumber.runtime.junit.FeatureRunner.run(FeatureRunner.java:70)\n\tat cucumber.api.junit.Cucumber.runChild(Cucumber.java:93)\n\tat cucumber.api.junit.Cucumber.runChild(Cucumber.java:37)\n\tat org.junit.runners.ParentRunner$3.run(ParentRunner.java:238)\n\tat org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:63)\n\tat org.junit.runners.ParentRunner.runChildren(ParentRunner.java:236)\n\tat org.junit.runners.ParentRunner.access$000(ParentRunner.java:53)\n\tat org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:229)\n\tat org.junit.internal.runners.statements.RunAfters.evaluate(RunAfters.java:27)\n\tat org.junit.runners.ParentRunner.run(ParentRunner.java:309)\n\tat cucumber.api.junit.Cucumber.run(Cucumber.java:98)\n\tat org.eclipse.jdt.internal.junit4.runner.JUnit4TestReference.run(JUnit4TestReference.java:86)\n\tat org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:459)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:678)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:382)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:192)\n",
  "status": "failed"
});
formatter.match({
  "location": "survey.asssurvey()"
});
formatter.result({
  "duration": 0,
  "error_message": "cucumber.runtime.AmbiguousStepDefinitionsException: ✽.Then Assert the success of Survey the target(CAPEC_197_Step_1_1.feature:8) matches more than one step definition:\n  Assert the success of Survey in survey.asssurvey()\n  Assert the success of Survey the target in surveythetarget.asssurveythetarget()\n\n\tat cucumber.runtime.RuntimeGlue.stepDefinitionMatch(RuntimeGlue.java:71)\n\tat cucumber.runtime.Runtime.runStep(Runtime.java:265)\n\tat cucumber.runtime.model.StepContainer.runStep(StepContainer.java:44)\n\tat cucumber.runtime.model.StepContainer.runSteps(StepContainer.java:39)\n\tat cucumber.runtime.model.CucumberScenario.run(CucumberScenario.java:48)\n\tat cucumber.runtime.junit.ExecutionUnitRunner.run(ExecutionUnitRunner.java:91)\n\tat cucumber.runtime.junit.FeatureRunner.runChild(FeatureRunner.java:63)\n\tat cucumber.runtime.junit.FeatureRunner.runChild(FeatureRunner.java:18)\n\tat org.junit.runners.ParentRunner$3.run(ParentRunner.java:238)\n\tat org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:63)\n\tat org.junit.runners.ParentRunner.runChildren(ParentRunner.java:236)\n\tat org.junit.runners.ParentRunner.access$000(ParentRunner.java:53)\n\tat org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:229)\n\tat org.junit.runners.ParentRunner.run(ParentRunner.java:309)\n\tat cucumber.runtime.junit.FeatureRunner.run(FeatureRunner.java:70)\n\tat cucumber.api.junit.Cucumber.runChild(Cucumber.java:93)\n\tat cucumber.api.junit.Cucumber.runChild(Cucumber.java:37)\n\tat org.junit.runners.ParentRunner$3.run(ParentRunner.java:238)\n\tat org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:63)\n\tat org.junit.runners.ParentRunner.runChildren(ParentRunner.java:236)\n\tat org.junit.runners.ParentRunner.access$000(ParentRunner.java:53)\n\tat org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:229)\n\tat org.junit.internal.runners.statements.RunAfters.evaluate(RunAfters.java:27)\n\tat org.junit.runners.ParentRunner.run(ParentRunner.java:309)\n\tat cucumber.api.junit.Cucumber.run(Cucumber.java:98)\n\tat org.eclipse.jdt.internal.junit4.runner.JUnit4TestReference.run(JUnit4TestReference.java:86)\n\tat org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:459)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:678)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:382)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:192)\n",
  "status": "failed"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({
  "location": "PatternSteps.assauditinterceptor()"
});
formatter.result({
  "status": "skipped"
});
formatter.match({
  "location": "PatternSteps.asssecurelogger()"
});
formatter.result({
  "status": "skipped"
});
formatter.uri("CAPEC_197_Step_2_1.feature");
formatter.feature({
  "line": 2,
  "name": "CAPEC-197: XML Entity Expansion",
  "description": "",
  "id": "capec-197:-xml-entity-expansion",
  "keyword": "Feature",
  "tags": [
    {
      "line": 1,
      "name": "@capec197"
    }
  ]
});
formatter.scenario({
  "comments": [
    {
      "line": 3,
      "value": "#2. Exploit"
    }
  ],
  "line": 4,
  "name": "Step2.1 Launch an XML Entity Expansion attack",
  "description": "",
  "id": "capec-197:-xml-entity-expansion;step2.1-launch-an-xml-entity-expansion-attack",
  "type": "scenario",
  "keyword": "Scenario"
});
formatter.step({
  "line": 5,
  "name": "prepare to Launch an XML Entity Expansion attack",
  "keyword": "Given "
});
formatter.step({
  "line": 6,
  "name": "Try to Launch an XML Entity Expansion attack",
  "keyword": "When "
});
formatter.step({
  "comments": [
    {
      "line": 7,
      "value": "# assertion for attack step success"
    }
  ],
  "line": 8,
  "name": "Assert the success of Launch an XML Entity Expansion attack",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 9,
      "value": "#assertions for security pattern testing (checker whether the pattern consequences are observed)"
    }
  ],
  "line": 10,
  "name": "assert the consequences of the pattern",
  "keyword": "Then "
});
formatter.match({
  "location": "launchanxmlentityexpansionattack.prelaunchanxmlentityexpansionattack()"
});
formatter.result({
  "duration": 72635,
  "status": "passed"
});
formatter.match({
  "location": "launchanxmlentityexpansionattack.trylaunchanxmlentityexpansionattack()"
});
formatter.result({
  "duration": 13885,
  "status": "passed"
});
formatter.match({
  "location": "launchanxmlentityexpansionattack.asslaunchanxmlentityexpansionattack()"
});
formatter.result({
  "duration": 11385,
  "status": "passed"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.uri("CAPEC_199_Step_1_1.feature");
formatter.feature({
  "line": 2,
  "name": "CAPEC-199: Cross-Site Scripting Using Alternate Syntax",
  "description": "",
  "id": "capec-199:-cross-site-scripting-using-alternate-syntax",
  "keyword": "Feature",
  "tags": [
    {
      "line": 1,
      "name": "@capec199"
    }
  ]
});
formatter.scenario({
  "comments": [
    {
      "line": 3,
      "value": "#1. Explore"
    }
  ],
  "line": 4,
  "name": "Step1.1 Survey the application",
  "description": "",
  "id": "capec-199:-cross-site-scripting-using-alternate-syntax;step1.1-survey-the-application",
  "type": "scenario",
  "keyword": "Scenario"
});
formatter.step({
  "line": 5,
  "name": "prepare to Survey the application",
  "keyword": "Given "
});
formatter.step({
  "line": 6,
  "name": "Try to Survey the application",
  "keyword": "When "
});
formatter.step({
  "comments": [
    {
      "line": 7,
      "value": "# assertion for attack step success"
    }
  ],
  "line": 8,
  "name": "Assert the success of Survey the application",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 9,
      "value": "#assertions for security pattern testing (checker whether the pattern consequences are observed)"
    }
  ],
  "line": 10,
  "name": "assert the consequences of the pattern",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 11,
      "value": "#"
    }
  ],
  "line": 12,
  "name": "assert the consequences of the pattern audit interceptor",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 13,
      "value": "# depends secure logger"
    }
  ],
  "line": 14,
  "name": "assert the consequences of the pattern secure logger",
  "keyword": "Then "
});
formatter.match({
  "location": "survey.presurvey()"
});
formatter.result({
  "duration": 0,
  "error_message": "cucumber.runtime.AmbiguousStepDefinitionsException: ✽.Given prepare to Survey the application(CAPEC_199_Step_1_1.feature:5) matches more than one step definition:\n  prepare to Survey in survey.presurvey()\n  prepare to Survey the application in surveytheapplication.presurveytheapplication()\n\n\tat cucumber.runtime.RuntimeGlue.stepDefinitionMatch(RuntimeGlue.java:71)\n\tat cucumber.runtime.Runtime.runStep(Runtime.java:265)\n\tat cucumber.runtime.model.StepContainer.runStep(StepContainer.java:44)\n\tat cucumber.runtime.model.StepContainer.runSteps(StepContainer.java:39)\n\tat cucumber.runtime.model.CucumberScenario.run(CucumberScenario.java:48)\n\tat cucumber.runtime.junit.ExecutionUnitRunner.run(ExecutionUnitRunner.java:91)\n\tat cucumber.runtime.junit.FeatureRunner.runChild(FeatureRunner.java:63)\n\tat cucumber.runtime.junit.FeatureRunner.runChild(FeatureRunner.java:18)\n\tat org.junit.runners.ParentRunner$3.run(ParentRunner.java:238)\n\tat org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:63)\n\tat org.junit.runners.ParentRunner.runChildren(ParentRunner.java:236)\n\tat org.junit.runners.ParentRunner.access$000(ParentRunner.java:53)\n\tat org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:229)\n\tat org.junit.runners.ParentRunner.run(ParentRunner.java:309)\n\tat cucumber.runtime.junit.FeatureRunner.run(FeatureRunner.java:70)\n\tat cucumber.api.junit.Cucumber.runChild(Cucumber.java:93)\n\tat cucumber.api.junit.Cucumber.runChild(Cucumber.java:37)\n\tat org.junit.runners.ParentRunner$3.run(ParentRunner.java:238)\n\tat org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:63)\n\tat org.junit.runners.ParentRunner.runChildren(ParentRunner.java:236)\n\tat org.junit.runners.ParentRunner.access$000(ParentRunner.java:53)\n\tat org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:229)\n\tat org.junit.internal.runners.statements.RunAfters.evaluate(RunAfters.java:27)\n\tat org.junit.runners.ParentRunner.run(ParentRunner.java:309)\n\tat cucumber.api.junit.Cucumber.run(Cucumber.java:98)\n\tat org.eclipse.jdt.internal.junit4.runner.JUnit4TestReference.run(JUnit4TestReference.java:86)\n\tat org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:459)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:678)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:382)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:192)\n",
  "status": "failed"
});
formatter.match({
  "location": "survey.trysurvey()"
});
formatter.result({
  "duration": 0,
  "error_message": "cucumber.runtime.AmbiguousStepDefinitionsException: ✽.When Try to Survey the application(CAPEC_199_Step_1_1.feature:6) matches more than one step definition:\n  Try to Survey in survey.trysurvey()\n  Try to Survey the application in surveytheapplication.trysurveytheapplication()\n\n\tat cucumber.runtime.RuntimeGlue.stepDefinitionMatch(RuntimeGlue.java:71)\n\tat cucumber.runtime.Runtime.runStep(Runtime.java:265)\n\tat cucumber.runtime.model.StepContainer.runStep(StepContainer.java:44)\n\tat cucumber.runtime.model.StepContainer.runSteps(StepContainer.java:39)\n\tat cucumber.runtime.model.CucumberScenario.run(CucumberScenario.java:48)\n\tat cucumber.runtime.junit.ExecutionUnitRunner.run(ExecutionUnitRunner.java:91)\n\tat cucumber.runtime.junit.FeatureRunner.runChild(FeatureRunner.java:63)\n\tat cucumber.runtime.junit.FeatureRunner.runChild(FeatureRunner.java:18)\n\tat org.junit.runners.ParentRunner$3.run(ParentRunner.java:238)\n\tat org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:63)\n\tat org.junit.runners.ParentRunner.runChildren(ParentRunner.java:236)\n\tat org.junit.runners.ParentRunner.access$000(ParentRunner.java:53)\n\tat org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:229)\n\tat org.junit.runners.ParentRunner.run(ParentRunner.java:309)\n\tat cucumber.runtime.junit.FeatureRunner.run(FeatureRunner.java:70)\n\tat cucumber.api.junit.Cucumber.runChild(Cucumber.java:93)\n\tat cucumber.api.junit.Cucumber.runChild(Cucumber.java:37)\n\tat org.junit.runners.ParentRunner$3.run(ParentRunner.java:238)\n\tat org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:63)\n\tat org.junit.runners.ParentRunner.runChildren(ParentRunner.java:236)\n\tat org.junit.runners.ParentRunner.access$000(ParentRunner.java:53)\n\tat org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:229)\n\tat org.junit.internal.runners.statements.RunAfters.evaluate(RunAfters.java:27)\n\tat org.junit.runners.ParentRunner.run(ParentRunner.java:309)\n\tat cucumber.api.junit.Cucumber.run(Cucumber.java:98)\n\tat org.eclipse.jdt.internal.junit4.runner.JUnit4TestReference.run(JUnit4TestReference.java:86)\n\tat org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:459)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:678)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:382)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:192)\n",
  "status": "failed"
});
formatter.match({
  "location": "survey.asssurvey()"
});
formatter.result({
  "duration": 0,
  "error_message": "cucumber.runtime.AmbiguousStepDefinitionsException: ✽.Then Assert the success of Survey the application(CAPEC_199_Step_1_1.feature:8) matches more than one step definition:\n  Assert the success of Survey in survey.asssurvey()\n  Assert the success of Survey the application in surveytheapplication.asssurveytheapplication()\n\n\tat cucumber.runtime.RuntimeGlue.stepDefinitionMatch(RuntimeGlue.java:71)\n\tat cucumber.runtime.Runtime.runStep(Runtime.java:265)\n\tat cucumber.runtime.model.StepContainer.runStep(StepContainer.java:44)\n\tat cucumber.runtime.model.StepContainer.runSteps(StepContainer.java:39)\n\tat cucumber.runtime.model.CucumberScenario.run(CucumberScenario.java:48)\n\tat cucumber.runtime.junit.ExecutionUnitRunner.run(ExecutionUnitRunner.java:91)\n\tat cucumber.runtime.junit.FeatureRunner.runChild(FeatureRunner.java:63)\n\tat cucumber.runtime.junit.FeatureRunner.runChild(FeatureRunner.java:18)\n\tat org.junit.runners.ParentRunner$3.run(ParentRunner.java:238)\n\tat org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:63)\n\tat org.junit.runners.ParentRunner.runChildren(ParentRunner.java:236)\n\tat org.junit.runners.ParentRunner.access$000(ParentRunner.java:53)\n\tat org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:229)\n\tat org.junit.runners.ParentRunner.run(ParentRunner.java:309)\n\tat cucumber.runtime.junit.FeatureRunner.run(FeatureRunner.java:70)\n\tat cucumber.api.junit.Cucumber.runChild(Cucumber.java:93)\n\tat cucumber.api.junit.Cucumber.runChild(Cucumber.java:37)\n\tat org.junit.runners.ParentRunner$3.run(ParentRunner.java:238)\n\tat org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:63)\n\tat org.junit.runners.ParentRunner.runChildren(ParentRunner.java:236)\n\tat org.junit.runners.ParentRunner.access$000(ParentRunner.java:53)\n\tat org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:229)\n\tat org.junit.internal.runners.statements.RunAfters.evaluate(RunAfters.java:27)\n\tat org.junit.runners.ParentRunner.run(ParentRunner.java:309)\n\tat cucumber.api.junit.Cucumber.run(Cucumber.java:98)\n\tat org.eclipse.jdt.internal.junit4.runner.JUnit4TestReference.run(JUnit4TestReference.java:86)\n\tat org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:459)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:678)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:382)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:192)\n",
  "status": "failed"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({
  "location": "PatternSteps.assauditinterceptor()"
});
formatter.result({
  "status": "skipped"
});
formatter.match({
  "location": "PatternSteps.asssecurelogger()"
});
formatter.result({
  "status": "skipped"
});
formatter.uri("CAPEC_199_Step_2_1.feature");
formatter.feature({
  "line": 2,
  "name": "CAPEC-199: Cross-Site Scripting Using Alternate Syntax",
  "description": "",
  "id": "capec-199:-cross-site-scripting-using-alternate-syntax",
  "keyword": "Feature",
  "tags": [
    {
      "line": 1,
      "name": "@capec199"
    }
  ]
});
formatter.scenario({
  "comments": [
    {
      "line": 3,
      "value": "#2. Experiment"
    }
  ],
  "line": 4,
  "name": "Step2.1 Attempt injection payload variations on input parameters",
  "description": "",
  "id": "capec-199:-cross-site-scripting-using-alternate-syntax;step2.1-attempt-injection-payload-variations-on-input-parameters",
  "type": "scenario",
  "keyword": "Scenario"
});
formatter.step({
  "line": 5,
  "name": "prepare to Attempt injection payload variations on input parameters",
  "keyword": "Given "
});
formatter.step({
  "line": 6,
  "name": "Try to Attempt injection payload variations on input parameters",
  "keyword": "When "
});
formatter.step({
  "comments": [
    {
      "line": 7,
      "value": "# assertion for attack step success"
    }
  ],
  "line": 8,
  "name": "Assert the success of Attempt injection payload variations on input parameters",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 9,
      "value": "#assertions for security pattern testing (checker whether the pattern consequences are observed)"
    }
  ],
  "line": 10,
  "name": "assert the consequences of the pattern audit interceptor",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 11,
      "value": "# depends secure logger"
    }
  ],
  "line": 12,
  "name": "assert the consequences of the pattern secure logger",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 13,
      "value": "# benifits audit interceptor"
    }
  ],
  "line": 14,
  "name": "assert the consequences of the pattern application firewall",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 15,
      "value": "# alternative input guard"
    }
  ],
  "line": 16,
  "name": "assert the consequences of the pattern input guard",
  "keyword": "Then "
});
formatter.match({
  "location": "attemptinjectionpayloadvariationsoninputparameters.preattemptinjectionpayloadvariationsoninputparameters()"
});
formatter.result({
  "duration": 1850986,
  "error_message": "net.continuumsecurity.proxy.ProxyException: org.zaproxy.clientapi.core.ClientApiException: java.net.ConnectException: Connection refused\n\tat net.continuumsecurity.proxy.ZAProxyScanner.validateMinimumRequiredZapVersion(ZAProxyScanner.java:96)\n\tat net.continuumsecurity.proxy.ZAProxyScanner.\u003cinit\u003e(ZAProxyScanner.java:38)\n\tat steps.attemptinjectionpayloadvariationsoninputparameters.preattemptinjectionpayloadvariationsoninputparameters(attemptinjectionpayloadvariationsoninputparameters.java:16)\n\tat ✽.Given prepare to Attempt injection payload variations on input parameters(CAPEC_199_Step_2_1.feature:5)\nCaused by: org.zaproxy.clientapi.core.ClientApiException: java.net.ConnectException: Connection refused\n\tat org.zaproxy.clientapi.core.ClientApi.callApiDom(ClientApi.java:307)\n\tat org.zaproxy.clientapi.core.ClientApi.callApi(ClientApi.java:289)\n\tat org.zaproxy.clientapi.gen.Core.version(Core.java:158)\n\tat net.continuumsecurity.proxy.ZAProxyScanner.validateMinimumRequiredZapVersion(ZAProxyScanner.java:85)\n\tat net.continuumsecurity.proxy.ZAProxyScanner.\u003cinit\u003e(ZAProxyScanner.java:38)\n\tat steps.attemptinjectionpayloadvariationsoninputparameters.preattemptinjectionpayloadvariationsoninputparameters(attemptinjectionpayloadvariationsoninputparameters.java:16)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.lang.reflect.Method.invoke(Method.java:498)\n\tat cucumber.runtime.Utils$1.call(Utils.java:37)\n\tat cucumber.runtime.Timeout.timeout(Timeout.java:13)\n\tat cucumber.runtime.Utils.invoke(Utils.java:31)\n\tat cucumber.runtime.java.JavaStepDefinition.execute(JavaStepDefinition.java:37)\n\tat cucumber.runtime.StepDefinitionMatch.runStep(StepDefinitionMatch.java:37)\n\tat cucumber.runtime.Runtime.runStep(Runtime.java:298)\n\tat cucumber.runtime.model.StepContainer.runStep(StepContainer.java:44)\n\tat cucumber.runtime.model.StepContainer.runSteps(StepContainer.java:39)\n\tat cucumber.runtime.model.CucumberScenario.run(CucumberScenario.java:48)\n\tat cucumber.runtime.junit.ExecutionUnitRunner.run(ExecutionUnitRunner.java:91)\n\tat cucumber.runtime.junit.FeatureRunner.runChild(FeatureRunner.java:63)\n\tat cucumber.runtime.junit.FeatureRunner.runChild(FeatureRunner.java:18)\n\tat org.junit.runners.ParentRunner$3.run(ParentRunner.java:238)\n\tat org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:63)\n\tat org.junit.runners.ParentRunner.runChildren(ParentRunner.java:236)\n\tat org.junit.runners.ParentRunner.access$000(ParentRunner.java:53)\n\tat org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:229)\n\tat org.junit.runners.ParentRunner.run(ParentRunner.java:309)\n\tat cucumber.runtime.junit.FeatureRunner.run(FeatureRunner.java:70)\n\tat cucumber.api.junit.Cucumber.runChild(Cucumber.java:93)\n\tat cucumber.api.junit.Cucumber.runChild(Cucumber.java:37)\n\tat org.junit.runners.ParentRunner$3.run(ParentRunner.java:238)\n\tat org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:63)\n\tat org.junit.runners.ParentRunner.runChildren(ParentRunner.java:236)\n\tat org.junit.runners.ParentRunner.access$000(ParentRunner.java:53)\n\tat org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:229)\n\tat org.junit.internal.runners.statements.RunAfters.evaluate(RunAfters.java:27)\n\tat org.junit.runners.ParentRunner.run(ParentRunner.java:309)\n\tat cucumber.api.junit.Cucumber.run(Cucumber.java:98)\n\tat org.eclipse.jdt.internal.junit4.runner.JUnit4TestReference.run(JUnit4TestReference.java:86)\n\tat org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:459)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:678)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:382)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:192)\nCaused by: java.net.ConnectException: Connection refused\n\tat java.net.PlainSocketImpl.socketConnect(Native Method)\n\tat java.net.AbstractPlainSocketImpl.doConnect(AbstractPlainSocketImpl.java:350)\n\tat java.net.AbstractPlainSocketImpl.connectToAddress(AbstractPlainSocketImpl.java:206)\n\tat java.net.AbstractPlainSocketImpl.connect(AbstractPlainSocketImpl.java:188)\n\tat java.net.Socket.connect(Socket.java:589)\n\tat java.net.Socket.connect(Socket.java:538)\n\tat sun.net.NetworkClient.doConnect(NetworkClient.java:180)\n\tat sun.net.www.http.HttpClient.openServer(HttpClient.java:432)\n\tat sun.net.www.http.HttpClient$1.run(HttpClient.java:484)\n\tat sun.net.www.http.HttpClient$1.run(HttpClient.java:482)\n\tat java.security.AccessController.doPrivileged(Native Method)\n\tat sun.net.www.http.HttpClient.privilegedOpenServer(HttpClient.java:481)\n\tat sun.net.www.http.HttpClient.openServer(HttpClient.java:522)\n\tat sun.net.www.http.HttpClient.\u003cinit\u003e(HttpClient.java:211)\n\tat sun.net.www.http.HttpClient.New(HttpClient.java:308)\n\tat sun.net.www.http.HttpClient.New(HttpClient.java:326)\n\tat sun.net.www.protocol.http.HttpURLConnection.getNewHttpClient(HttpURLConnection.java:1169)\n\tat sun.net.www.protocol.http.HttpURLConnection.plainConnect0(HttpURLConnection.java:1148)\n\tat sun.net.www.protocol.http.HttpURLConnection.plainConnect(HttpURLConnection.java:999)\n\tat sun.net.www.protocol.http.HttpURLConnection.connect(HttpURLConnection.java:933)\n\tat org.zaproxy.clientapi.core.ClientApi.getConnectionInputStream(ClientApi.java:313)\n\tat org.zaproxy.clientapi.core.ClientApi.callApiDom(ClientApi.java:305)\n\t... 44 more\n",
  "status": "failed"
});
formatter.match({
  "location": "attemptinjectionpayloadvariationsoninputparameters.tryattemptinjectionpayloadvariationsoninputparameters()"
});
formatter.result({
  "status": "skipped"
});
formatter.match({
  "location": "attemptinjectionpayloadvariationsoninputparameters.assattemptinjectionpayloadvariationsoninputparameters()"
});
formatter.result({
  "status": "skipped"
});
formatter.match({
  "location": "PatternSteps.assauditinterceptor()"
});
formatter.result({
  "status": "skipped"
});
formatter.match({
  "location": "PatternSteps.asssecurelogger()"
});
formatter.result({
  "status": "skipped"
});
formatter.match({
  "location": "PatternSteps.assapplicationfirewall()"
});
formatter.result({
  "status": "skipped"
});
formatter.match({
  "location": "PatternSteps.assinputguard()"
});
formatter.result({
  "status": "skipped"
});
formatter.uri("CAPEC_199_Step_3_1.feature");
formatter.feature({
  "line": 2,
  "name": "CAPEC-199: Cross-Site Scripting Using Alternate Syntax",
  "description": "",
  "id": "capec-199:-cross-site-scripting-using-alternate-syntax",
  "keyword": "Feature",
  "tags": [
    {
      "line": 1,
      "name": "@capec199"
    }
  ]
});
formatter.scenario({
  "comments": [
    {
      "line": 3,
      "value": "#3. Exploit"
    }
  ],
  "line": 4,
  "name": "Step3.1 Steal session IDs, credentials, page content, etc.",
  "description": "",
  "id": "capec-199:-cross-site-scripting-using-alternate-syntax;step3.1-steal-session-ids,-credentials,-page-content,-etc.",
  "type": "scenario",
  "keyword": "Scenario"
});
formatter.step({
  "line": 5,
  "name": "prepare to Steal session IDs, credentials, page content, etc.",
  "keyword": "Given "
});
formatter.step({
  "line": 6,
  "name": "Try to Steal session IDs, credentials, page content, etc.",
  "keyword": "When "
});
formatter.step({
  "comments": [
    {
      "line": 7,
      "value": "# assertion for attack step success"
    }
  ],
  "line": 8,
  "name": "Assert the success of Steal session IDs, credentials, page content, etc.",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 9,
      "value": "#assertions for security pattern testing (checker whether the pattern consequences are observed)"
    }
  ],
  "line": 10,
  "name": "assert the consequences of the pattern audit interceptor",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 11,
      "value": "# depends secure logger"
    }
  ],
  "line": 12,
  "name": "assert the consequences of the pattern secure logger",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 13,
      "value": "# benifits audit interceptor"
    }
  ],
  "line": 14,
  "name": "assert the consequences of the pattern application firewall",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 15,
      "value": "# alternative output guard"
    },
    {
      "line": 16,
      "value": "# alternative input guard"
    }
  ],
  "line": 17,
  "name": "assert the consequences of the pattern input guard",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 18,
      "value": "# alternative application firewall"
    },
    {
      "line": 19,
      "value": "# benifits output guard"
    }
  ],
  "line": 20,
  "name": "assert the consequences of the pattern output guard",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 21,
      "value": "# alternative application firewall"
    },
    {
      "line": 22,
      "value": "# benifits input guard"
    }
  ],
  "line": 23,
  "name": "assert the consequences of the pattern comparator checked fault tolerant system",
  "keyword": "Then "
});
formatter.match({
  "location": "stealsessionidscredentialspagecontentetc.prestealsessionidscredentialspagecontentetc()"
});
formatter.result({
  "duration": 29801,
  "status": "passed"
});
formatter.match({
  "location": "stealsessionidscredentialspagecontentetc.trystealsessionidscredentialspagecontentetc()"
});
formatter.result({
  "duration": 10198,
  "status": "passed"
});
formatter.match({
  "location": "stealsessionidscredentialspagecontentetc.assstealsessionidscredentialspagecontentetc()"
});
formatter.result({
  "duration": 7819,
  "status": "passed"
});
formatter.match({
  "location": "PatternSteps.assauditinterceptor()"
});
formatter.result({
  "duration": 17274,
  "status": "passed"
});
formatter.match({
  "location": "PatternSteps.asssecurelogger()"
});
formatter.result({
  "duration": 10219,
  "status": "passed"
});
formatter.match({
  "location": "PatternSteps.assapplicationfirewall()"
});
formatter.result({
  "duration": 10720,
  "status": "passed"
});
formatter.match({
  "location": "PatternSteps.assinputguard()"
});
formatter.result({
  "duration": 10405,
  "status": "passed"
});
formatter.match({
  "location": "PatternSteps.assoutputguard()"
});
formatter.result({
  "duration": 8599,
  "status": "passed"
});
formatter.match({
  "location": "PatternSteps.asscomparatorcheckedfaulttolerantsystem()"
});
formatter.result({
  "duration": 7464,
  "status": "passed"
});
formatter.uri("CAPEC_199_Step_3_2.feature");
formatter.feature({
  "line": 2,
  "name": "CAPEC-199: Cross-Site Scripting Using Alternate Syntax",
  "description": "",
  "id": "capec-199:-cross-site-scripting-using-alternate-syntax",
  "keyword": "Feature",
  "tags": [
    {
      "line": 1,
      "name": "@capec199"
    }
  ]
});
formatter.scenario({
  "comments": [
    {
      "line": 3,
      "value": "#3. Exploit"
    }
  ],
  "line": 4,
  "name": "Step3.2 Forceful browsing",
  "description": "",
  "id": "capec-199:-cross-site-scripting-using-alternate-syntax;step3.2-forceful-browsing",
  "type": "scenario",
  "keyword": "Scenario"
});
formatter.step({
  "line": 5,
  "name": "prepare to Forceful browsing",
  "keyword": "Given "
});
formatter.step({
  "line": 6,
  "name": "Try to Forceful browsing",
  "keyword": "When "
});
formatter.step({
  "comments": [
    {
      "line": 7,
      "value": "# assertion for attack step success"
    }
  ],
  "line": 8,
  "name": "Assert the success of Forceful browsing",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 9,
      "value": "#assertions for security pattern testing (checker whether the pattern consequences are observed)"
    }
  ],
  "line": 10,
  "name": "assert the consequences of the pattern audit interceptor",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 11,
      "value": "# depends secure logger"
    }
  ],
  "line": 12,
  "name": "assert the consequences of the pattern secure logger",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 13,
      "value": "# benifits audit interceptor"
    }
  ],
  "line": 14,
  "name": "assert the consequences of the pattern application firewall",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 15,
      "value": "# alternative output guard"
    },
    {
      "line": 16,
      "value": "# alternative input guard"
    }
  ],
  "line": 17,
  "name": "assert the consequences of the pattern input guard",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 18,
      "value": "# alternative application firewall"
    },
    {
      "line": 19,
      "value": "# benifits output guard"
    }
  ],
  "line": 20,
  "name": "assert the consequences of the pattern output guard",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 21,
      "value": "# alternative application firewall"
    },
    {
      "line": 22,
      "value": "# benifits input guard"
    }
  ],
  "line": 23,
  "name": "assert the consequences of the pattern comparator checked fault tolerant system",
  "keyword": "Then "
});
formatter.match({
  "location": "forcefulbrowsing.preforcefulbrowsing()"
});
formatter.result({
  "duration": 39202,
  "status": "passed"
});
formatter.match({
  "location": "forcefulbrowsing.tryforcefulbrowsing()"
});
formatter.result({
  "duration": 10479,
  "status": "passed"
});
formatter.match({
  "location": "forcefulbrowsing.assforcefulbrowsing()"
});
formatter.result({
  "duration": 9986,
  "status": "passed"
});
formatter.match({
  "location": "PatternSteps.assauditinterceptor()"
});
formatter.result({
  "duration": 19001,
  "status": "passed"
});
formatter.match({
  "location": "PatternSteps.asssecurelogger()"
});
formatter.result({
  "duration": 10825,
  "status": "passed"
});
formatter.match({
  "location": "PatternSteps.assapplicationfirewall()"
});
formatter.result({
  "duration": 282989,
  "status": "passed"
});
formatter.match({
  "location": "PatternSteps.assinputguard()"
});
formatter.result({
  "duration": 267165,
  "status": "passed"
});
formatter.match({
  "location": "PatternSteps.assoutputguard()"
});
formatter.result({
  "duration": 25934,
  "status": "passed"
});
formatter.match({
  "location": "PatternSteps.asscomparatorcheckedfaulttolerantsystem()"
});
formatter.result({
  "duration": 9549,
  "status": "passed"
});
formatter.uri("CAPEC_199_Step_3_3.feature");
formatter.feature({
  "line": 2,
  "name": "CAPEC-199: Cross-Site Scripting Using Alternate Syntax",
  "description": "",
  "id": "capec-199:-cross-site-scripting-using-alternate-syntax",
  "keyword": "Feature",
  "tags": [
    {
      "line": 1,
      "name": "@capec199"
    }
  ]
});
formatter.scenario({
  "comments": [
    {
      "line": 3,
      "value": "#3. Exploit"
    }
  ],
  "line": 4,
  "name": "Step3.3 Content spoofing",
  "description": "",
  "id": "capec-199:-cross-site-scripting-using-alternate-syntax;step3.3-content-spoofing",
  "type": "scenario",
  "keyword": "Scenario"
});
formatter.step({
  "line": 5,
  "name": "prepare to Content spoofing",
  "keyword": "Given "
});
formatter.step({
  "line": 6,
  "name": "Try to Content spoofing",
  "keyword": "When "
});
formatter.step({
  "comments": [
    {
      "line": 7,
      "value": "# assertion for attack step success"
    }
  ],
  "line": 8,
  "name": "Assert the success of Content spoofing",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 9,
      "value": "#assertions for security pattern testing (checker whether the pattern consequences are observed)"
    }
  ],
  "line": 10,
  "name": "assert the consequences of the pattern audit interceptor",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 11,
      "value": "# depends secure logger"
    }
  ],
  "line": 12,
  "name": "assert the consequences of the pattern secure logger",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 13,
      "value": "# benifits audit interceptor"
    }
  ],
  "line": 14,
  "name": "assert the consequences of the pattern application firewall",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 15,
      "value": "# alternative output guard"
    },
    {
      "line": 16,
      "value": "# alternative input guard"
    }
  ],
  "line": 17,
  "name": "assert the consequences of the pattern input guard",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 18,
      "value": "# alternative application firewall"
    },
    {
      "line": 19,
      "value": "# benifits output guard"
    }
  ],
  "line": 20,
  "name": "assert the consequences of the pattern output guard",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 21,
      "value": "# alternative application firewall"
    },
    {
      "line": 22,
      "value": "# benifits input guard"
    }
  ],
  "line": 23,
  "name": "assert the consequences of the pattern comparator checked fault tolerant system",
  "keyword": "Then "
});
formatter.match({
  "location": "contentspoofing.precontentspoofing()"
});
formatter.result({
  "duration": 54623,
  "status": "passed"
});
formatter.match({
  "location": "contentspoofing.trycontentspoofing()"
});
formatter.result({
  "duration": 16191,
  "status": "passed"
});
formatter.match({
  "location": "contentspoofing.asscontentspoofing()"
});
formatter.result({
  "duration": 6604,
  "status": "passed"
});
formatter.match({
  "location": "PatternSteps.assauditinterceptor()"
});
formatter.result({
  "duration": 15316,
  "status": "passed"
});
formatter.match({
  "location": "PatternSteps.asssecurelogger()"
});
formatter.result({
  "duration": 7001,
  "status": "passed"
});
formatter.match({
  "location": "PatternSteps.assapplicationfirewall()"
});
formatter.result({
  "duration": 17696,
  "status": "passed"
});
formatter.match({
  "location": "PatternSteps.assinputguard()"
});
formatter.result({
  "duration": 14565,
  "status": "passed"
});
formatter.match({
  "location": "PatternSteps.assoutputguard()"
});
formatter.result({
  "duration": 7528,
  "status": "passed"
});
formatter.match({
  "location": "PatternSteps.asscomparatorcheckedfaulttolerantsystem()"
});
formatter.result({
  "duration": 5872,
  "status": "passed"
});
formatter.uri("CAPEC_19_Step_1_1.feature");
formatter.feature({
  "line": 2,
  "name": "CAPEC-19: Embedding Scripts within Scripts",
  "description": "",
  "id": "capec-19:-embedding-scripts-within-scripts",
  "keyword": "Feature",
  "tags": [
    {
      "line": 1,
      "name": "@capec19"
    }
  ]
});
formatter.scenario({
  "comments": [
    {
      "line": 3,
      "value": "#1. Explore"
    }
  ],
  "line": 4,
  "name": "Step1.1 Spider",
  "description": "",
  "id": "capec-19:-embedding-scripts-within-scripts;step1.1-spider",
  "type": "scenario",
  "keyword": "Scenario"
});
formatter.step({
  "line": 5,
  "name": "prepare to Spider",
  "keyword": "Given "
});
formatter.step({
  "line": 6,
  "name": "Try to Spider",
  "keyword": "When "
});
formatter.step({
  "comments": [
    {
      "line": 7,
      "value": "# assertion for attack step success"
    }
  ],
  "line": 8,
  "name": "Assert the success of Spider",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 9,
      "value": "#assertions for security pattern testing (checker whether the pattern consequences are observed)"
    }
  ],
  "line": 10,
  "name": "assert the consequences of the pattern",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 11,
      "value": "#"
    }
  ],
  "line": 12,
  "name": "assert the consequences of the pattern audit interceptor",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 13,
      "value": "# depends secure logger"
    }
  ],
  "line": 14,
  "name": "assert the consequences of the pattern secure logger",
  "keyword": "Then "
});
formatter.match({
  "location": "spider.prespider()"
});
formatter.result({
  "duration": 2200289,
  "error_message": "net.continuumsecurity.proxy.ProxyException: org.zaproxy.clientapi.core.ClientApiException: java.net.ConnectException: Connection refused\n\tat net.continuumsecurity.proxy.ZAProxyScanner.validateMinimumRequiredZapVersion(ZAProxyScanner.java:96)\n\tat net.continuumsecurity.proxy.ZAProxyScanner.\u003cinit\u003e(ZAProxyScanner.java:38)\n\tat steps.spider.prespider(spider.java:17)\n\tat ✽.Given prepare to Spider(CAPEC_19_Step_1_1.feature:5)\nCaused by: org.zaproxy.clientapi.core.ClientApiException: java.net.ConnectException: Connection refused\n\tat org.zaproxy.clientapi.core.ClientApi.callApiDom(ClientApi.java:307)\n\tat org.zaproxy.clientapi.core.ClientApi.callApi(ClientApi.java:289)\n\tat org.zaproxy.clientapi.gen.Core.version(Core.java:158)\n\tat net.continuumsecurity.proxy.ZAProxyScanner.validateMinimumRequiredZapVersion(ZAProxyScanner.java:85)\n\tat net.continuumsecurity.proxy.ZAProxyScanner.\u003cinit\u003e(ZAProxyScanner.java:38)\n\tat steps.spider.prespider(spider.java:17)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.lang.reflect.Method.invoke(Method.java:498)\n\tat cucumber.runtime.Utils$1.call(Utils.java:37)\n\tat cucumber.runtime.Timeout.timeout(Timeout.java:13)\n\tat cucumber.runtime.Utils.invoke(Utils.java:31)\n\tat cucumber.runtime.java.JavaStepDefinition.execute(JavaStepDefinition.java:37)\n\tat cucumber.runtime.StepDefinitionMatch.runStep(StepDefinitionMatch.java:37)\n\tat cucumber.runtime.Runtime.runStep(Runtime.java:298)\n\tat cucumber.runtime.model.StepContainer.runStep(StepContainer.java:44)\n\tat cucumber.runtime.model.StepContainer.runSteps(StepContainer.java:39)\n\tat cucumber.runtime.model.CucumberScenario.run(CucumberScenario.java:48)\n\tat cucumber.runtime.junit.ExecutionUnitRunner.run(ExecutionUnitRunner.java:91)\n\tat cucumber.runtime.junit.FeatureRunner.runChild(FeatureRunner.java:63)\n\tat cucumber.runtime.junit.FeatureRunner.runChild(FeatureRunner.java:18)\n\tat org.junit.runners.ParentRunner$3.run(ParentRunner.java:238)\n\tat org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:63)\n\tat org.junit.runners.ParentRunner.runChildren(ParentRunner.java:236)\n\tat org.junit.runners.ParentRunner.access$000(ParentRunner.java:53)\n\tat org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:229)\n\tat org.junit.runners.ParentRunner.run(ParentRunner.java:309)\n\tat cucumber.runtime.junit.FeatureRunner.run(FeatureRunner.java:70)\n\tat cucumber.api.junit.Cucumber.runChild(Cucumber.java:93)\n\tat cucumber.api.junit.Cucumber.runChild(Cucumber.java:37)\n\tat org.junit.runners.ParentRunner$3.run(ParentRunner.java:238)\n\tat org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:63)\n\tat org.junit.runners.ParentRunner.runChildren(ParentRunner.java:236)\n\tat org.junit.runners.ParentRunner.access$000(ParentRunner.java:53)\n\tat org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:229)\n\tat org.junit.internal.runners.statements.RunAfters.evaluate(RunAfters.java:27)\n\tat org.junit.runners.ParentRunner.run(ParentRunner.java:309)\n\tat cucumber.api.junit.Cucumber.run(Cucumber.java:98)\n\tat org.eclipse.jdt.internal.junit4.runner.JUnit4TestReference.run(JUnit4TestReference.java:86)\n\tat org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:459)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:678)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:382)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:192)\nCaused by: java.net.ConnectException: Connection refused\n\tat java.net.PlainSocketImpl.socketConnect(Native Method)\n\tat java.net.AbstractPlainSocketImpl.doConnect(AbstractPlainSocketImpl.java:350)\n\tat java.net.AbstractPlainSocketImpl.connectToAddress(AbstractPlainSocketImpl.java:206)\n\tat java.net.AbstractPlainSocketImpl.connect(AbstractPlainSocketImpl.java:188)\n\tat java.net.Socket.connect(Socket.java:589)\n\tat java.net.Socket.connect(Socket.java:538)\n\tat sun.net.NetworkClient.doConnect(NetworkClient.java:180)\n\tat sun.net.www.http.HttpClient.openServer(HttpClient.java:432)\n\tat sun.net.www.http.HttpClient$1.run(HttpClient.java:484)\n\tat sun.net.www.http.HttpClient$1.run(HttpClient.java:482)\n\tat java.security.AccessController.doPrivileged(Native Method)\n\tat sun.net.www.http.HttpClient.privilegedOpenServer(HttpClient.java:481)\n\tat sun.net.www.http.HttpClient.openServer(HttpClient.java:522)\n\tat sun.net.www.http.HttpClient.\u003cinit\u003e(HttpClient.java:211)\n\tat sun.net.www.http.HttpClient.New(HttpClient.java:308)\n\tat sun.net.www.http.HttpClient.New(HttpClient.java:326)\n\tat sun.net.www.protocol.http.HttpURLConnection.getNewHttpClient(HttpURLConnection.java:1169)\n\tat sun.net.www.protocol.http.HttpURLConnection.plainConnect0(HttpURLConnection.java:1148)\n\tat sun.net.www.protocol.http.HttpURLConnection.plainConnect(HttpURLConnection.java:999)\n\tat sun.net.www.protocol.http.HttpURLConnection.connect(HttpURLConnection.java:933)\n\tat org.zaproxy.clientapi.core.ClientApi.getConnectionInputStream(ClientApi.java:313)\n\tat org.zaproxy.clientapi.core.ClientApi.callApiDom(ClientApi.java:305)\n\t... 44 more\n",
  "status": "failed"
});
formatter.match({
  "location": "spider.tryspider()"
});
formatter.result({
  "status": "skipped"
});
formatter.match({
  "location": "spider.assspider()"
});
formatter.result({
  "status": "skipped"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({
  "location": "PatternSteps.assauditinterceptor()"
});
formatter.result({
  "status": "skipped"
});
formatter.match({
  "location": "PatternSteps.asssecurelogger()"
});
formatter.result({
  "status": "skipped"
});
formatter.uri("CAPEC_19_Step_2_1.feature");
formatter.feature({
  "line": 2,
  "name": "CAPEC-19: Embedding Scripts within Scripts",
  "description": "",
  "id": "capec-19:-embedding-scripts-within-scripts",
  "keyword": "Feature",
  "tags": [
    {
      "line": 1,
      "name": "@capec19"
    }
  ]
});
formatter.scenario({
  "comments": [
    {
      "line": 3,
      "value": "#2. Experiment"
    }
  ],
  "line": 4,
  "name": "Step2.1 Probe identified potential entry points for XSS vulnerability",
  "description": "",
  "id": "capec-19:-embedding-scripts-within-scripts;step2.1-probe-identified-potential-entry-points-for-xss-vulnerability",
  "type": "scenario",
  "keyword": "Scenario"
});
formatter.step({
  "line": 5,
  "name": "prepare to Probe identified potential entry points for XSS vulnerability",
  "keyword": "Given "
});
formatter.step({
  "line": 6,
  "name": "Try to Probe identified potential entry points for XSS vulnerability",
  "keyword": "When "
});
formatter.step({
  "comments": [
    {
      "line": 7,
      "value": "# assertion for attack step success"
    }
  ],
  "line": 8,
  "name": "Assert the success of Probe identified potential entry points for XSS vulnerability",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 9,
      "value": "#assertions for security pattern testing (checker whether the pattern consequences are observed)"
    }
  ],
  "line": 10,
  "name": "assert the consequences of the pattern secure logger",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 11,
      "value": "# benifits audit interceptor"
    }
  ],
  "line": 12,
  "name": "assert the consequences of the pattern application firewall",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 13,
      "value": "# alternative input guard"
    }
  ],
  "line": 14,
  "name": "assert the consequences of the pattern input guard",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 15,
      "value": "# alternative application firewall"
    }
  ],
  "line": 16,
  "name": "assert the consequences of the pattern audit interceptor",
  "keyword": "Then "
});
formatter.match({
  "location": "probeidentifiedpotentialentrypointsforxssvulnerability.preprobeidentifiedpotentialentrypointsforxssvulnerability()"
});
formatter.result({
  "duration": 2090855,
  "error_message": "net.continuumsecurity.proxy.ProxyException: org.zaproxy.clientapi.core.ClientApiException: java.net.ConnectException: Connection refused\n\tat net.continuumsecurity.proxy.ZAProxyScanner.validateMinimumRequiredZapVersion(ZAProxyScanner.java:96)\n\tat net.continuumsecurity.proxy.ZAProxyScanner.\u003cinit\u003e(ZAProxyScanner.java:38)\n\tat steps.probeidentifiedpotentialentrypointsforxssvulnerability.preprobeidentifiedpotentialentrypointsforxssvulnerability(probeidentifiedpotentialentrypointsforxssvulnerability.java:15)\n\tat ✽.Given prepare to Probe identified potential entry points for XSS vulnerability(CAPEC_19_Step_2_1.feature:5)\nCaused by: org.zaproxy.clientapi.core.ClientApiException: java.net.ConnectException: Connection refused\n\tat org.zaproxy.clientapi.core.ClientApi.callApiDom(ClientApi.java:307)\n\tat org.zaproxy.clientapi.core.ClientApi.callApi(ClientApi.java:289)\n\tat org.zaproxy.clientapi.gen.Core.version(Core.java:158)\n\tat net.continuumsecurity.proxy.ZAProxyScanner.validateMinimumRequiredZapVersion(ZAProxyScanner.java:85)\n\tat net.continuumsecurity.proxy.ZAProxyScanner.\u003cinit\u003e(ZAProxyScanner.java:38)\n\tat steps.probeidentifiedpotentialentrypointsforxssvulnerability.preprobeidentifiedpotentialentrypointsforxssvulnerability(probeidentifiedpotentialentrypointsforxssvulnerability.java:15)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.lang.reflect.Method.invoke(Method.java:498)\n\tat cucumber.runtime.Utils$1.call(Utils.java:37)\n\tat cucumber.runtime.Timeout.timeout(Timeout.java:13)\n\tat cucumber.runtime.Utils.invoke(Utils.java:31)\n\tat cucumber.runtime.java.JavaStepDefinition.execute(JavaStepDefinition.java:37)\n\tat cucumber.runtime.StepDefinitionMatch.runStep(StepDefinitionMatch.java:37)\n\tat cucumber.runtime.Runtime.runStep(Runtime.java:298)\n\tat cucumber.runtime.model.StepContainer.runStep(StepContainer.java:44)\n\tat cucumber.runtime.model.StepContainer.runSteps(StepContainer.java:39)\n\tat cucumber.runtime.model.CucumberScenario.run(CucumberScenario.java:48)\n\tat cucumber.runtime.junit.ExecutionUnitRunner.run(ExecutionUnitRunner.java:91)\n\tat cucumber.runtime.junit.FeatureRunner.runChild(FeatureRunner.java:63)\n\tat cucumber.runtime.junit.FeatureRunner.runChild(FeatureRunner.java:18)\n\tat org.junit.runners.ParentRunner$3.run(ParentRunner.java:238)\n\tat org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:63)\n\tat org.junit.runners.ParentRunner.runChildren(ParentRunner.java:236)\n\tat org.junit.runners.ParentRunner.access$000(ParentRunner.java:53)\n\tat org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:229)\n\tat org.junit.runners.ParentRunner.run(ParentRunner.java:309)\n\tat cucumber.runtime.junit.FeatureRunner.run(FeatureRunner.java:70)\n\tat cucumber.api.junit.Cucumber.runChild(Cucumber.java:93)\n\tat cucumber.api.junit.Cucumber.runChild(Cucumber.java:37)\n\tat org.junit.runners.ParentRunner$3.run(ParentRunner.java:238)\n\tat org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:63)\n\tat org.junit.runners.ParentRunner.runChildren(ParentRunner.java:236)\n\tat org.junit.runners.ParentRunner.access$000(ParentRunner.java:53)\n\tat org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:229)\n\tat org.junit.internal.runners.statements.RunAfters.evaluate(RunAfters.java:27)\n\tat org.junit.runners.ParentRunner.run(ParentRunner.java:309)\n\tat cucumber.api.junit.Cucumber.run(Cucumber.java:98)\n\tat org.eclipse.jdt.internal.junit4.runner.JUnit4TestReference.run(JUnit4TestReference.java:86)\n\tat org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:459)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:678)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:382)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:192)\nCaused by: java.net.ConnectException: Connection refused\n\tat java.net.PlainSocketImpl.socketConnect(Native Method)\n\tat java.net.AbstractPlainSocketImpl.doConnect(AbstractPlainSocketImpl.java:350)\n\tat java.net.AbstractPlainSocketImpl.connectToAddress(AbstractPlainSocketImpl.java:206)\n\tat java.net.AbstractPlainSocketImpl.connect(AbstractPlainSocketImpl.java:188)\n\tat java.net.Socket.connect(Socket.java:589)\n\tat java.net.Socket.connect(Socket.java:538)\n\tat sun.net.NetworkClient.doConnect(NetworkClient.java:180)\n\tat sun.net.www.http.HttpClient.openServer(HttpClient.java:432)\n\tat sun.net.www.http.HttpClient$1.run(HttpClient.java:484)\n\tat sun.net.www.http.HttpClient$1.run(HttpClient.java:482)\n\tat java.security.AccessController.doPrivileged(Native Method)\n\tat sun.net.www.http.HttpClient.privilegedOpenServer(HttpClient.java:481)\n\tat sun.net.www.http.HttpClient.openServer(HttpClient.java:522)\n\tat sun.net.www.http.HttpClient.\u003cinit\u003e(HttpClient.java:211)\n\tat sun.net.www.http.HttpClient.New(HttpClient.java:308)\n\tat sun.net.www.http.HttpClient.New(HttpClient.java:326)\n\tat sun.net.www.protocol.http.HttpURLConnection.getNewHttpClient(HttpURLConnection.java:1169)\n\tat sun.net.www.protocol.http.HttpURLConnection.plainConnect0(HttpURLConnection.java:1148)\n\tat sun.net.www.protocol.http.HttpURLConnection.plainConnect(HttpURLConnection.java:999)\n\tat sun.net.www.protocol.http.HttpURLConnection.connect(HttpURLConnection.java:933)\n\tat org.zaproxy.clientapi.core.ClientApi.getConnectionInputStream(ClientApi.java:313)\n\tat org.zaproxy.clientapi.core.ClientApi.callApiDom(ClientApi.java:305)\n\t... 44 more\n",
  "status": "failed"
});
formatter.match({
  "location": "probeidentifiedpotentialentrypointsforxssvulnerability.tryprobeidentifiedpotentialentrypointsforxssvulnerability()"
});
formatter.result({
  "status": "skipped"
});
formatter.match({
  "location": "probeidentifiedpotentialentrypointsforxssvulnerability.assprobeidentifiedpotentialentrypointsforxssvulnerability()"
});
formatter.result({
  "status": "skipped"
});
formatter.match({
  "location": "PatternSteps.asssecurelogger()"
});
formatter.result({
  "status": "skipped"
});
formatter.match({
  "location": "PatternSteps.assapplicationfirewall()"
});
formatter.result({
  "status": "skipped"
});
formatter.match({
  "location": "PatternSteps.assinputguard()"
});
formatter.result({
  "status": "skipped"
});
formatter.match({
  "location": "PatternSteps.assauditinterceptor()"
});
formatter.result({
  "status": "skipped"
});
formatter.uri("CAPEC_19_Step_3_1.feature");
formatter.feature({
  "line": 2,
  "name": "CAPEC-19: Embedding Scripts within Scripts",
  "description": "",
  "id": "capec-19:-embedding-scripts-within-scripts",
  "keyword": "Feature",
  "tags": [
    {
      "line": 1,
      "name": "@capec19"
    }
  ]
});
formatter.scenario({
  "comments": [
    {
      "line": 3,
      "value": "#3. Exploit"
    }
  ],
  "line": 4,
  "name": "Step3.1 Steal session IDs, credentials, page content, etc.",
  "description": "",
  "id": "capec-19:-embedding-scripts-within-scripts;step3.1-steal-session-ids,-credentials,-page-content,-etc.",
  "type": "scenario",
  "keyword": "Scenario"
});
formatter.step({
  "line": 5,
  "name": "prepare to Steal session IDs, credentials, page content, etc.",
  "keyword": "Given "
});
formatter.step({
  "line": 6,
  "name": "Try to Steal session IDs, credentials, page content, etc.",
  "keyword": "When "
});
formatter.step({
  "comments": [
    {
      "line": 7,
      "value": "# assertion for attack step success"
    }
  ],
  "line": 8,
  "name": "Assert the success of Steal session IDs, credentials, page content, etc.",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 9,
      "value": "#assertions for security pattern testing (checker whether the pattern consequences are observed)"
    }
  ],
  "line": 10,
  "name": "assert the consequences of the pattern audit interceptor",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 11,
      "value": "# depends secure logger"
    }
  ],
  "line": 12,
  "name": "assert the consequences of the pattern secure logger",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 13,
      "value": "# benifits audit interceptor"
    }
  ],
  "line": 14,
  "name": "assert the consequences of the pattern application firewall",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 15,
      "value": "# alternative output guard"
    },
    {
      "line": 16,
      "value": "# alternative input guard"
    }
  ],
  "line": 17,
  "name": "assert the consequences of the pattern input guard",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 18,
      "value": "# alternative application firewall"
    },
    {
      "line": 19,
      "value": "# benifits output guard"
    }
  ],
  "line": 20,
  "name": "assert the consequences of the pattern output guard",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 21,
      "value": "# alternative application firewall"
    },
    {
      "line": 22,
      "value": "# benifits input guard"
    }
  ],
  "line": 23,
  "name": "assert the consequences of the pattern comparator checked fault tolerant system",
  "keyword": "Then "
});
formatter.match({
  "location": "stealsessionidscredentialspagecontentetc.prestealsessionidscredentialspagecontentetc()"
});
formatter.result({
  "duration": 26652,
  "status": "passed"
});
formatter.match({
  "location": "stealsessionidscredentialspagecontentetc.trystealsessionidscredentialspagecontentetc()"
});
formatter.result({
  "duration": 6920,
  "status": "passed"
});
formatter.match({
  "location": "stealsessionidscredentialspagecontentetc.assstealsessionidscredentialspagecontentetc()"
});
formatter.result({
  "duration": 6346,
  "status": "passed"
});
formatter.match({
  "location": "PatternSteps.assauditinterceptor()"
});
formatter.result({
  "duration": 17518,
  "status": "passed"
});
formatter.match({
  "location": "PatternSteps.asssecurelogger()"
});
formatter.result({
  "duration": 6419,
  "status": "passed"
});
formatter.match({
  "location": "PatternSteps.assapplicationfirewall()"
});
formatter.result({
  "duration": 6476,
  "status": "passed"
});
formatter.match({
  "location": "PatternSteps.assinputguard()"
});
formatter.result({
  "duration": 6049,
  "status": "passed"
});
formatter.match({
  "location": "PatternSteps.assoutputguard()"
});
formatter.result({
  "duration": 6918,
  "status": "passed"
});
formatter.match({
  "location": "PatternSteps.asscomparatorcheckedfaulttolerantsystem()"
});
formatter.result({
  "duration": 16079,
  "status": "passed"
});
formatter.uri("CAPEC_19_Step_3_2.feature");
formatter.feature({
  "line": 2,
  "name": "CAPEC-19: Embedding Scripts within Scripts",
  "description": "",
  "id": "capec-19:-embedding-scripts-within-scripts",
  "keyword": "Feature",
  "tags": [
    {
      "line": 1,
      "name": "@capec19"
    }
  ]
});
formatter.scenario({
  "comments": [
    {
      "line": 3,
      "value": "#3. Exploit"
    }
  ],
  "line": 4,
  "name": "Step3.2 Forceful browsing",
  "description": "",
  "id": "capec-19:-embedding-scripts-within-scripts;step3.2-forceful-browsing",
  "type": "scenario",
  "keyword": "Scenario"
});
formatter.step({
  "line": 5,
  "name": "prepare to Forceful browsing",
  "keyword": "Given "
});
formatter.step({
  "line": 6,
  "name": "Try to Forceful browsing",
  "keyword": "When "
});
formatter.step({
  "comments": [
    {
      "line": 7,
      "value": "# assertion for attack step success"
    }
  ],
  "line": 8,
  "name": "Assert the success of Forceful browsing",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 9,
      "value": "#assertions for security pattern testing (checker whether the pattern consequences are observed)"
    }
  ],
  "line": 10,
  "name": "assert the consequences of the pattern audit interceptor",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 11,
      "value": "# depends secure logger"
    }
  ],
  "line": 12,
  "name": "assert the consequences of the pattern secure logger",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 13,
      "value": "# benifits audit interceptor"
    }
  ],
  "line": 14,
  "name": "assert the consequences of the pattern application firewall",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 15,
      "value": "# alternative output guard"
    },
    {
      "line": 16,
      "value": "# alternative input guard"
    }
  ],
  "line": 17,
  "name": "assert the consequences of the pattern input guard",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 18,
      "value": "# alternative application firewall"
    },
    {
      "line": 19,
      "value": "# benifits output guard"
    }
  ],
  "line": 20,
  "name": "assert the consequences of the pattern output guard",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 21,
      "value": "# alternative application firewall"
    },
    {
      "line": 22,
      "value": "# benifits input guard"
    }
  ],
  "line": 23,
  "name": "assert the consequences of the pattern comparator checked fault tolerant system",
  "keyword": "Then "
});
formatter.match({
  "location": "forcefulbrowsing.preforcefulbrowsing()"
});
formatter.result({
  "duration": 36880,
  "status": "passed"
});
formatter.match({
  "location": "forcefulbrowsing.tryforcefulbrowsing()"
});
formatter.result({
  "duration": 8936,
  "status": "passed"
});
formatter.match({
  "location": "forcefulbrowsing.assforcefulbrowsing()"
});
formatter.result({
  "duration": 7443,
  "status": "passed"
});
formatter.match({
  "location": "PatternSteps.assauditinterceptor()"
});
formatter.result({
  "duration": 16661,
  "status": "passed"
});
formatter.match({
  "location": "PatternSteps.asssecurelogger()"
});
formatter.result({
  "duration": 6283,
  "status": "passed"
});
formatter.match({
  "location": "PatternSteps.assapplicationfirewall()"
});
formatter.result({
  "duration": 6135,
  "status": "passed"
});
formatter.match({
  "location": "PatternSteps.assinputguard()"
});
formatter.result({
  "duration": 5526,
  "status": "passed"
});
formatter.match({
  "location": "PatternSteps.assoutputguard()"
});
formatter.result({
  "duration": 6140,
  "status": "passed"
});
formatter.match({
  "location": "PatternSteps.asscomparatorcheckedfaulttolerantsystem()"
});
formatter.result({
  "duration": 5497,
  "status": "passed"
});
formatter.uri("CAPEC_19_Step_3_3.feature");
formatter.feature({
  "line": 2,
  "name": "CAPEC-19: Embedding Scripts within Scripts",
  "description": "",
  "id": "capec-19:-embedding-scripts-within-scripts",
  "keyword": "Feature",
  "tags": [
    {
      "line": 1,
      "name": "@capec19"
    }
  ]
});
formatter.scenario({
  "comments": [
    {
      "line": 3,
      "value": "#3. Exploit"
    }
  ],
  "line": 4,
  "name": "Step3.3 Content spoofing",
  "description": "",
  "id": "capec-19:-embedding-scripts-within-scripts;step3.3-content-spoofing",
  "type": "scenario",
  "keyword": "Scenario"
});
formatter.step({
  "line": 5,
  "name": "prepare to Content spoofing",
  "keyword": "Given "
});
formatter.step({
  "line": 6,
  "name": "Try to Content spoofing",
  "keyword": "When "
});
formatter.step({
  "comments": [
    {
      "line": 7,
      "value": "# assertion for attack step success"
    }
  ],
  "line": 8,
  "name": "Assert the success of Content spoofing",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 9,
      "value": "#assertions for security pattern testing (checker whether the pattern consequences are observed)"
    }
  ],
  "line": 10,
  "name": "assert the consequences of the pattern audit interceptor",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 11,
      "value": "# depends secure logger"
    }
  ],
  "line": 12,
  "name": "assert the consequences of the pattern secure logger",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 13,
      "value": "# benifits audit interceptor"
    }
  ],
  "line": 14,
  "name": "assert the consequences of the pattern application firewall",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 15,
      "value": "# alternative output guard"
    },
    {
      "line": 16,
      "value": "# alternative input guard"
    }
  ],
  "line": 17,
  "name": "assert the consequences of the pattern input guard",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 18,
      "value": "# alternative application firewall"
    },
    {
      "line": 19,
      "value": "# benifits output guard"
    }
  ],
  "line": 20,
  "name": "assert the consequences of the pattern output guard",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 21,
      "value": "# alternative application firewall"
    },
    {
      "line": 22,
      "value": "# benifits input guard"
    }
  ],
  "line": 23,
  "name": "assert the consequences of the pattern comparator checked fault tolerant system",
  "keyword": "Then "
});
formatter.match({
  "location": "contentspoofing.precontentspoofing()"
});
formatter.result({
  "duration": 35289,
  "status": "passed"
});
formatter.match({
  "location": "contentspoofing.trycontentspoofing()"
});
formatter.result({
  "duration": 8277,
  "status": "passed"
});
formatter.match({
  "location": "contentspoofing.asscontentspoofing()"
});
formatter.result({
  "duration": 8334,
  "status": "passed"
});
formatter.match({
  "location": "PatternSteps.assauditinterceptor()"
});
formatter.result({
  "duration": 19873,
  "status": "passed"
});
formatter.match({
  "location": "PatternSteps.asssecurelogger()"
});
formatter.result({
  "duration": 8172,
  "status": "passed"
});
formatter.match({
  "location": "PatternSteps.assapplicationfirewall()"
});
formatter.result({
  "duration": 7682,
  "status": "passed"
});
formatter.match({
  "location": "PatternSteps.assinputguard()"
});
formatter.result({
  "duration": 7528,
  "status": "passed"
});
formatter.match({
  "location": "PatternSteps.assoutputguard()"
});
formatter.result({
  "duration": 9269,
  "status": "passed"
});
formatter.match({
  "location": "PatternSteps.asscomparatorcheckedfaulttolerantsystem()"
});
formatter.result({
  "duration": 8276,
  "status": "passed"
});
formatter.uri("CAPEC_1_Step_1_1.feature");
formatter.feature({
  "line": 2,
  "name": "CAPEC-1: Accessing Functionality Not Properly Constrained by ACLs",
  "description": "",
  "id": "capec-1:-accessing-functionality-not-properly-constrained-by-acls",
  "keyword": "Feature",
  "tags": [
    {
      "line": 1,
      "name": "@capec1"
    }
  ]
});
formatter.scenario({
  "comments": [
    {
      "line": 3,
      "value": "#1. Explore"
    }
  ],
  "line": 4,
  "name": "Step1.1 Survey",
  "description": "",
  "id": "capec-1:-accessing-functionality-not-properly-constrained-by-acls;step1.1-survey",
  "type": "scenario",
  "keyword": "Scenario"
});
formatter.step({
  "line": 5,
  "name": "prepare to Survey",
  "keyword": "Given "
});
formatter.step({
  "line": 6,
  "name": "Try to Survey",
  "keyword": "When "
});
formatter.step({
  "comments": [
    {
      "line": 7,
      "value": "# assertion for attack step success"
    }
  ],
  "line": 8,
  "name": "Assert the success of Survey",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 9,
      "value": "#assertions for security pattern testing (checker whether the pattern consequences are observed)"
    }
  ],
  "line": 10,
  "name": "assert the consequences of the pattern",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 11,
      "value": "#"
    }
  ],
  "line": 12,
  "name": "assert the consequences of the pattern audit interceptor",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 13,
      "value": "# depends secure logger"
    }
  ],
  "line": 14,
  "name": "assert the consequences of the pattern secure logger",
  "keyword": "Then "
});
formatter.match({
  "location": "survey.presurvey()"
});
formatter.result({
  "duration": 2215467,
  "error_message": "net.continuumsecurity.proxy.ProxyException: org.zaproxy.clientapi.core.ClientApiException: java.net.ConnectException: Connection refused\n\tat net.continuumsecurity.proxy.ZAProxyScanner.validateMinimumRequiredZapVersion(ZAProxyScanner.java:96)\n\tat net.continuumsecurity.proxy.ZAProxyScanner.\u003cinit\u003e(ZAProxyScanner.java:38)\n\tat steps.survey.presurvey(survey.java:17)\n\tat ✽.Given prepare to Survey(CAPEC_1_Step_1_1.feature:5)\nCaused by: org.zaproxy.clientapi.core.ClientApiException: java.net.ConnectException: Connection refused\n\tat org.zaproxy.clientapi.core.ClientApi.callApiDom(ClientApi.java:307)\n\tat org.zaproxy.clientapi.core.ClientApi.callApi(ClientApi.java:289)\n\tat org.zaproxy.clientapi.gen.Core.version(Core.java:158)\n\tat net.continuumsecurity.proxy.ZAProxyScanner.validateMinimumRequiredZapVersion(ZAProxyScanner.java:85)\n\tat net.continuumsecurity.proxy.ZAProxyScanner.\u003cinit\u003e(ZAProxyScanner.java:38)\n\tat steps.survey.presurvey(survey.java:17)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.lang.reflect.Method.invoke(Method.java:498)\n\tat cucumber.runtime.Utils$1.call(Utils.java:37)\n\tat cucumber.runtime.Timeout.timeout(Timeout.java:13)\n\tat cucumber.runtime.Utils.invoke(Utils.java:31)\n\tat cucumber.runtime.java.JavaStepDefinition.execute(JavaStepDefinition.java:37)\n\tat cucumber.runtime.StepDefinitionMatch.runStep(StepDefinitionMatch.java:37)\n\tat cucumber.runtime.Runtime.runStep(Runtime.java:298)\n\tat cucumber.runtime.model.StepContainer.runStep(StepContainer.java:44)\n\tat cucumber.runtime.model.StepContainer.runSteps(StepContainer.java:39)\n\tat cucumber.runtime.model.CucumberScenario.run(CucumberScenario.java:48)\n\tat cucumber.runtime.junit.ExecutionUnitRunner.run(ExecutionUnitRunner.java:91)\n\tat cucumber.runtime.junit.FeatureRunner.runChild(FeatureRunner.java:63)\n\tat cucumber.runtime.junit.FeatureRunner.runChild(FeatureRunner.java:18)\n\tat org.junit.runners.ParentRunner$3.run(ParentRunner.java:238)\n\tat org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:63)\n\tat org.junit.runners.ParentRunner.runChildren(ParentRunner.java:236)\n\tat org.junit.runners.ParentRunner.access$000(ParentRunner.java:53)\n\tat org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:229)\n\tat org.junit.runners.ParentRunner.run(ParentRunner.java:309)\n\tat cucumber.runtime.junit.FeatureRunner.run(FeatureRunner.java:70)\n\tat cucumber.api.junit.Cucumber.runChild(Cucumber.java:93)\n\tat cucumber.api.junit.Cucumber.runChild(Cucumber.java:37)\n\tat org.junit.runners.ParentRunner$3.run(ParentRunner.java:238)\n\tat org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:63)\n\tat org.junit.runners.ParentRunner.runChildren(ParentRunner.java:236)\n\tat org.junit.runners.ParentRunner.access$000(ParentRunner.java:53)\n\tat org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:229)\n\tat org.junit.internal.runners.statements.RunAfters.evaluate(RunAfters.java:27)\n\tat org.junit.runners.ParentRunner.run(ParentRunner.java:309)\n\tat cucumber.api.junit.Cucumber.run(Cucumber.java:98)\n\tat org.eclipse.jdt.internal.junit4.runner.JUnit4TestReference.run(JUnit4TestReference.java:86)\n\tat org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:459)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:678)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:382)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:192)\nCaused by: java.net.ConnectException: Connection refused\n\tat java.net.PlainSocketImpl.socketConnect(Native Method)\n\tat java.net.AbstractPlainSocketImpl.doConnect(AbstractPlainSocketImpl.java:350)\n\tat java.net.AbstractPlainSocketImpl.connectToAddress(AbstractPlainSocketImpl.java:206)\n\tat java.net.AbstractPlainSocketImpl.connect(AbstractPlainSocketImpl.java:188)\n\tat java.net.Socket.connect(Socket.java:589)\n\tat java.net.Socket.connect(Socket.java:538)\n\tat sun.net.NetworkClient.doConnect(NetworkClient.java:180)\n\tat sun.net.www.http.HttpClient.openServer(HttpClient.java:432)\n\tat sun.net.www.http.HttpClient$1.run(HttpClient.java:484)\n\tat sun.net.www.http.HttpClient$1.run(HttpClient.java:482)\n\tat java.security.AccessController.doPrivileged(Native Method)\n\tat sun.net.www.http.HttpClient.privilegedOpenServer(HttpClient.java:481)\n\tat sun.net.www.http.HttpClient.openServer(HttpClient.java:522)\n\tat sun.net.www.http.HttpClient.\u003cinit\u003e(HttpClient.java:211)\n\tat sun.net.www.http.HttpClient.New(HttpClient.java:308)\n\tat sun.net.www.http.HttpClient.New(HttpClient.java:326)\n\tat sun.net.www.protocol.http.HttpURLConnection.getNewHttpClient(HttpURLConnection.java:1169)\n\tat sun.net.www.protocol.http.HttpURLConnection.plainConnect0(HttpURLConnection.java:1148)\n\tat sun.net.www.protocol.http.HttpURLConnection.plainConnect(HttpURLConnection.java:999)\n\tat sun.net.www.protocol.http.HttpURLConnection.connect(HttpURLConnection.java:933)\n\tat org.zaproxy.clientapi.core.ClientApi.getConnectionInputStream(ClientApi.java:313)\n\tat org.zaproxy.clientapi.core.ClientApi.callApiDom(ClientApi.java:305)\n\t... 44 more\n",
  "status": "failed"
});
formatter.match({
  "location": "survey.trysurvey()"
});
formatter.result({
  "status": "skipped"
});
formatter.match({
  "location": "survey.asssurvey()"
});
formatter.result({
  "status": "skipped"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({
  "location": "PatternSteps.assauditinterceptor()"
});
formatter.result({
  "status": "skipped"
});
formatter.match({
  "location": "PatternSteps.asssecurelogger()"
});
formatter.result({
  "status": "skipped"
});
formatter.uri("CAPEC_1_Step_1_2.feature");
formatter.feature({
  "line": 2,
  "name": "CAPEC-1: Accessing Functionality Not Properly Constrained by ACLs",
  "description": "",
  "id": "capec-1:-accessing-functionality-not-properly-constrained-by-acls",
  "keyword": "Feature",
  "tags": [
    {
      "line": 1,
      "name": "@capec1"
    }
  ]
});
formatter.scenario({
  "comments": [
    {
      "line": 3,
      "value": "#1. Explore"
    }
  ],
  "line": 4,
  "name": "Step1.2 Identify Functionality",
  "description": "",
  "id": "capec-1:-accessing-functionality-not-properly-constrained-by-acls;step1.2-identify-functionality",
  "type": "scenario",
  "keyword": "Scenario"
});
formatter.step({
  "line": 5,
  "name": "prepare to Identify Functionality",
  "keyword": "Given "
});
formatter.step({
  "line": 6,
  "name": "Try to Identify Functionality",
  "keyword": "When "
});
formatter.step({
  "comments": [
    {
      "line": 7,
      "value": "# assertion for attack step success"
    }
  ],
  "line": 8,
  "name": "Assert the success of Identify Functionality",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 9,
      "value": "#assertions for security pattern testing (checker whether the pattern consequences are observed)"
    }
  ],
  "line": 10,
  "name": "assert the consequences of the pattern",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 11,
      "value": "#"
    }
  ],
  "line": 12,
  "name": "assert the consequences of the pattern audit interceptor",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 13,
      "value": "# depends secure logger"
    }
  ],
  "line": 14,
  "name": "assert the consequences of the pattern secure logger",
  "keyword": "Then "
});
formatter.match({
  "location": "identifyfunctionality.preidentifyfunctionality()"
});
formatter.result({
  "duration": 73888,
  "status": "passed"
});
formatter.match({
  "location": "identifyfunctionality.tryidentifyfunctionality()"
});
formatter.result({
  "duration": 18257,
  "status": "passed"
});
formatter.match({
  "location": "identifyfunctionality.assidentifyfunctionality()"
});
formatter.result({
  "duration": 16183,
  "status": "passed"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({
  "location": "PatternSteps.assauditinterceptor()"
});
formatter.result({
  "status": "skipped"
});
formatter.match({
  "location": "PatternSteps.asssecurelogger()"
});
formatter.result({
  "status": "skipped"
});
formatter.uri("CAPEC_1_Step_2_1.feature");
formatter.feature({
  "line": 2,
  "name": "CAPEC-1: Accessing Functionality Not Properly Constrained by ACLs",
  "description": "",
  "id": "capec-1:-accessing-functionality-not-properly-constrained-by-acls",
  "keyword": "Feature",
  "tags": [
    {
      "line": 1,
      "name": "@capec1"
    }
  ]
});
formatter.scenario({
  "comments": [
    {
      "line": 3,
      "value": "#2. Experiment"
    }
  ],
  "line": 4,
  "name": "Step2.1 Iterate over access capabilities",
  "description": "",
  "id": "capec-1:-accessing-functionality-not-properly-constrained-by-acls;step2.1-iterate-over-access-capabilities",
  "type": "scenario",
  "keyword": "Scenario"
});
formatter.step({
  "line": 5,
  "name": "prepare to Iterate over access capabilities",
  "keyword": "Given "
});
formatter.step({
  "line": 6,
  "name": "Try to Iterate over access capabilities",
  "keyword": "When "
});
formatter.step({
  "comments": [
    {
      "line": 7,
      "value": "# assertion for attack step success"
    }
  ],
  "line": 8,
  "name": "Assert the success of Iterate over access capabilities",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 9,
      "value": "#assertions for security pattern testing (checker whether the pattern consequences are observed)"
    }
  ],
  "line": 10,
  "name": "assert the consequences of the pattern",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 11,
      "value": "#"
    }
  ],
  "line": 12,
  "name": "assert the consequences of the pattern audit interceptor",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 13,
      "value": "# depends secure logger"
    }
  ],
  "line": 14,
  "name": "assert the consequences of the pattern secure logger",
  "keyword": "Then "
});
formatter.match({
  "location": "iterateoveraccesscapabilities.preiterateoveraccesscapabilities()"
});
formatter.result({
  "duration": 71208,
  "status": "passed"
});
formatter.match({
  "location": "iterateoveraccesscapabilities.tryiterateoveraccesscapabilities()"
});
formatter.result({
  "duration": 12538,
  "status": "passed"
});
formatter.match({
  "location": "iterateoveraccesscapabilities.assiterateoveraccesscapabilities()"
});
formatter.result({
  "duration": 21689,
  "status": "passed"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({
  "location": "PatternSteps.assauditinterceptor()"
});
formatter.result({
  "status": "skipped"
});
formatter.match({
  "location": "PatternSteps.asssecurelogger()"
});
formatter.result({
  "status": "skipped"
});
formatter.uri("CAPEC_205_Step_1_1.feature");
formatter.feature({
  "line": 2,
  "name": "CAPEC-205: Lifting credential(s)/key material embedded in client distributions (thick or thin)",
  "description": "",
  "id": "capec-205:-lifting-credential(s)/key-material-embedded-in-client-distributions-(thick-or-thin)",
  "keyword": "Feature",
  "tags": [
    {
      "line": 1,
      "name": "@capec205"
    }
  ]
});
formatter.scenario({
  "comments": [
    {
      "line": 3,
      "value": "#1. Explore"
    }
  ],
  "line": 4,
  "name": "Step1.1 Identify Target",
  "description": "",
  "id": "capec-205:-lifting-credential(s)/key-material-embedded-in-client-distributions-(thick-or-thin);step1.1-identify-target",
  "type": "scenario",
  "keyword": "Scenario"
});
formatter.step({
  "line": 5,
  "name": "prepare to Identify Target",
  "keyword": "Given "
});
formatter.step({
  "line": 6,
  "name": "Try to Identify Target",
  "keyword": "When "
});
formatter.step({
  "comments": [
    {
      "line": 7,
      "value": "# assertion for attack step success"
    }
  ],
  "line": 8,
  "name": "Assert the success of Identify Target",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 9,
      "value": "#assertions for security pattern testing (checker whether the pattern consequences are observed)"
    }
  ],
  "line": 10,
  "name": "assert the consequences of the pattern secure logger",
  "keyword": "Then "
});
formatter.match({
  "location": "identifytarget.preidentifytarget()"
});
formatter.result({
  "duration": 44165,
  "status": "passed"
});
formatter.match({
  "location": "identifytarget.tryidentifytarget()"
});
formatter.result({
  "duration": 11925,
  "status": "passed"
});
formatter.match({
  "location": "identifytarget.assidentifytarget()"
});
formatter.result({
  "duration": 13519,
  "status": "passed"
});
formatter.match({
  "location": "PatternSteps.asssecurelogger()"
});
formatter.result({
  "duration": 24392,
  "status": "passed"
});
formatter.uri("CAPEC_205_Step_2_1.feature");
formatter.feature({
  "line": 2,
  "name": "CAPEC-205: Lifting credential(s)/key material embedded in client distributions (thick or thin)",
  "description": "",
  "id": "capec-205:-lifting-credential(s)/key-material-embedded-in-client-distributions-(thick-or-thin)",
  "keyword": "Feature",
  "tags": [
    {
      "line": 1,
      "name": "@capec205"
    }
  ]
});
formatter.scenario({
  "comments": [
    {
      "line": 3,
      "value": "#2. Experiment"
    }
  ],
  "line": 4,
  "name": "Step2.1 Apply mining techniques",
  "description": "",
  "id": "capec-205:-lifting-credential(s)/key-material-embedded-in-client-distributions-(thick-or-thin);step2.1-apply-mining-techniques",
  "type": "scenario",
  "keyword": "Scenario"
});
formatter.step({
  "line": 5,
  "name": "prepare to Apply mining techniques",
  "keyword": "Given "
});
formatter.step({
  "line": 6,
  "name": "Try to Apply mining techniques",
  "keyword": "When "
});
formatter.step({
  "comments": [
    {
      "line": 7,
      "value": "# assertion for attack step success"
    }
  ],
  "line": 8,
  "name": "Assert the success of Apply mining techniques",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 9,
      "value": "#assertions for security pattern testing (checker whether the pattern consequences are observed)"
    }
  ],
  "line": 10,
  "name": "assert the consequences of the pattern",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 11,
      "value": "#"
    }
  ],
  "line": 12,
  "name": "assert the consequences of the pattern audit interceptor",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 13,
      "value": "# depends secure logger"
    }
  ],
  "line": 14,
  "name": "assert the consequences of the pattern secure logger",
  "keyword": "Then "
});
formatter.match({
  "location": "applyminingtechniques.preapplyminingtechniques()"
});
formatter.result({
  "duration": 97676,
  "status": "passed"
});
formatter.match({
  "location": "applyminingtechniques.tryapplyminingtechniques()"
});
formatter.result({
  "duration": 9702,
  "status": "passed"
});
formatter.match({
  "location": "applyminingtechniques.assapplyminingtechniques()"
});
formatter.result({
  "duration": 9055,
  "status": "passed"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({
  "location": "PatternSteps.assauditinterceptor()"
});
formatter.result({
  "status": "skipped"
});
formatter.match({
  "location": "PatternSteps.asssecurelogger()"
});
formatter.result({
  "status": "skipped"
});
formatter.uri("CAPEC_207_Step_1_1.feature");
formatter.feature({
  "line": 2,
  "name": "CAPEC-207: Removing Important Client Functionality",
  "description": "",
  "id": "capec-207:-removing-important-client-functionality",
  "keyword": "Feature",
  "tags": [
    {
      "line": 1,
      "name": "@capec207"
    }
  ]
});
formatter.scenario({
  "comments": [
    {
      "line": 3,
      "value": "#1. Explore"
    }
  ],
  "line": 4,
  "name": "Step1.1 Probing",
  "description": "",
  "id": "capec-207:-removing-important-client-functionality;step1.1-probing",
  "type": "scenario",
  "keyword": "Scenario"
});
formatter.step({
  "line": 5,
  "name": "prepare to Probing",
  "keyword": "Given "
});
formatter.step({
  "line": 6,
  "name": "Try to Probing",
  "keyword": "When "
});
formatter.step({
  "comments": [
    {
      "line": 7,
      "value": "# assertion for attack step success"
    }
  ],
  "line": 8,
  "name": "Assert the success of Probing",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 9,
      "value": "#assertions for security pattern testing (checker whether the pattern consequences are observed)"
    }
  ],
  "line": 10,
  "name": "assert the consequences of the pattern",
  "keyword": "Then "
});
formatter.match({
  "location": "probing.preprobing()"
});
formatter.result({
  "duration": 65691,
  "status": "passed"
});
formatter.match({
  "location": "probing.tryprobing()"
});
formatter.result({
  "duration": 12900,
  "status": "passed"
});
formatter.match({
  "location": "probing.assprobing()"
});
formatter.result({
  "duration": 59703,
  "status": "passed"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.uri("CAPEC_207_Step_2_1.feature");
formatter.feature({
  "line": 2,
  "name": "CAPEC-207: Removing Important Client Functionality",
  "description": "",
  "id": "capec-207:-removing-important-client-functionality",
  "keyword": "Feature",
  "tags": [
    {
      "line": 1,
      "name": "@capec207"
    }
  ]
});
formatter.scenario({
  "comments": [
    {
      "line": 3,
      "value": "#2. Experiment"
    }
  ],
  "line": 4,
  "name": "Step2.1 Determine which functionality to disable or remove",
  "description": "",
  "id": "capec-207:-removing-important-client-functionality;step2.1-determine-which-functionality-to-disable-or-remove",
  "type": "scenario",
  "keyword": "Scenario"
});
formatter.step({
  "line": 5,
  "name": "prepare to Determine which functionality to disable or remove",
  "keyword": "Given "
});
formatter.step({
  "line": 6,
  "name": "Try to Determine which functionality to disable or remove",
  "keyword": "When "
});
formatter.step({
  "comments": [
    {
      "line": 7,
      "value": "# assertion for attack step success"
    }
  ],
  "line": 8,
  "name": "Assert the success of Determine which functionality to disable or remove",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 9,
      "value": "#assertions for security pattern testing (checker whether the pattern consequences are observed)"
    }
  ],
  "line": 10,
  "name": "assert the consequences of the pattern",
  "keyword": "Then "
});
formatter.match({
  "location": "determinewhichfunctionalitytodisableorremove.predeterminewhichfunctionalitytodisableorremove()"
});
formatter.result({
  "duration": 68730,
  "status": "passed"
});
formatter.match({
  "location": "determinewhichfunctionalitytodisableorremove.trydeterminewhichfunctionalitytodisableorremove()"
});
formatter.result({
  "duration": 9462,
  "status": "passed"
});
formatter.match({
  "location": "determinewhichfunctionalitytodisableorremove.assdeterminewhichfunctionalitytodisableorremove()"
});
formatter.result({
  "duration": 8096,
  "status": "passed"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.uri("CAPEC_207_Step_3_1.feature");
formatter.feature({
  "line": 2,
  "name": "CAPEC-207: Removing Important Client Functionality",
  "description": "",
  "id": "capec-207:-removing-important-client-functionality",
  "keyword": "Feature",
  "tags": [
    {
      "line": 1,
      "name": "@capec207"
    }
  ]
});
formatter.scenario({
  "comments": [
    {
      "line": 3,
      "value": "#3. Exploit"
    }
  ],
  "line": 4,
  "name": "Step3.1 Disable or remove the critical functionality from the client code",
  "description": "",
  "id": "capec-207:-removing-important-client-functionality;step3.1-disable-or-remove-the-critical-functionality-from-the-client-code",
  "type": "scenario",
  "keyword": "Scenario"
});
formatter.step({
  "line": 5,
  "name": "prepare to Disable or remove the critical functionality from the client code",
  "keyword": "Given "
});
formatter.step({
  "line": 6,
  "name": "Try to Disable or remove the critical functionality from the client code",
  "keyword": "When "
});
formatter.step({
  "comments": [
    {
      "line": 7,
      "value": "# assertion for attack step success"
    }
  ],
  "line": 8,
  "name": "Assert the success of Disable or remove the critical functionality from the client code",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 9,
      "value": "#assertions for security pattern testing (checker whether the pattern consequences are observed)"
    }
  ],
  "line": 10,
  "name": "assert the consequences of the pattern",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 11,
      "value": "#"
    }
  ],
  "line": 12,
  "name": "assert the consequences of the pattern secure logger",
  "keyword": "Then "
});
formatter.match({
  "location": "disableorremovethecriticalfunctionalityfromtheclientcode.predisableorremovethecriticalfunctionalityfromtheclientcode()"
});
formatter.result({
  "duration": 47907,
  "status": "passed"
});
formatter.match({
  "location": "disableorremovethecriticalfunctionalityfromtheclientcode.trydisableorremovethecriticalfunctionalityfromtheclientcode()"
});
formatter.result({
  "duration": 6800,
  "status": "passed"
});
formatter.match({
  "location": "disableorremovethecriticalfunctionalityfromtheclientcode.assdisableorremovethecriticalfunctionalityfromtheclientcode()"
});
formatter.result({
  "duration": 6102,
  "status": "passed"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({
  "location": "PatternSteps.asssecurelogger()"
});
formatter.result({
  "status": "skipped"
});
formatter.uri("CAPEC_20_Step_1_1.feature");
formatter.feature({
  "line": 2,
  "name": "CAPEC-20: Encryption Brute Forcing",
  "description": "",
  "id": "capec-20:-encryption-brute-forcing",
  "keyword": "Feature",
  "tags": [
    {
      "line": 1,
      "name": "@capec20"
    }
  ]
});
formatter.scenario({
  "comments": [
    {
      "line": 3,
      "value": "#1. Explore"
    }
  ],
  "line": 4,
  "name": "Step1.1",
  "description": "",
  "id": "capec-20:-encryption-brute-forcing;step1.1",
  "type": "scenario",
  "keyword": "Scenario"
});
formatter.step({
  "line": 5,
  "name": "prepare to",
  "keyword": "Given "
});
formatter.step({
  "line": 6,
  "name": "Try to",
  "keyword": "When "
});
formatter.step({
  "comments": [
    {
      "line": 7,
      "value": "# assertion for attack step success"
    }
  ],
  "line": 8,
  "name": "Assert the success of",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 9,
      "value": "#assertions for security pattern testing (checker whether the pattern consequences are observed)"
    }
  ],
  "line": 10,
  "name": "assert the consequences of the pattern",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 11,
      "value": "#"
    }
  ],
  "line": 12,
  "name": "assert the consequences of the pattern audit interceptor",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 13,
      "value": "# depends secure logger"
    }
  ],
  "line": 14,
  "name": "assert the consequences of the pattern secure logger",
  "keyword": "Then "
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({
  "location": "PatternSteps.assauditinterceptor()"
});
formatter.result({
  "status": "skipped"
});
formatter.match({
  "location": "PatternSteps.asssecurelogger()"
});
formatter.result({
  "status": "skipped"
});
formatter.uri("CAPEC_20_Step_2_1.feature");
formatter.feature({
  "line": 2,
  "name": "CAPEC-20: Encryption Brute Forcing",
  "description": "",
  "id": "capec-20:-encryption-brute-forcing",
  "keyword": "Feature",
  "tags": [
    {
      "line": 1,
      "name": "@capec20"
    }
  ]
});
formatter.scenario({
  "comments": [
    {
      "line": 3,
      "value": "#2. Experiment"
    }
  ],
  "line": 4,
  "name": "Step2.1",
  "description": "",
  "id": "capec-20:-encryption-brute-forcing;step2.1",
  "type": "scenario",
  "keyword": "Scenario"
});
formatter.step({
  "line": 5,
  "name": "prepare to",
  "keyword": "Given "
});
formatter.step({
  "line": 6,
  "name": "Try to",
  "keyword": "When "
});
formatter.step({
  "comments": [
    {
      "line": 7,
      "value": "# assertion for attack step success"
    }
  ],
  "line": 8,
  "name": "Assert the success of",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 9,
      "value": "#assertions for security pattern testing (checker whether the pattern consequences are observed)"
    }
  ],
  "line": 10,
  "name": "assert the consequences of the pattern",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 11,
      "value": "#"
    }
  ],
  "line": 12,
  "name": "assert the consequences of the pattern audit interceptor",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 13,
      "value": "# depends secure logger"
    }
  ],
  "line": 14,
  "name": "assert the consequences of the pattern secure logger",
  "keyword": "Then "
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({
  "location": "PatternSteps.assauditinterceptor()"
});
formatter.result({
  "status": "skipped"
});
formatter.match({
  "location": "PatternSteps.asssecurelogger()"
});
formatter.result({
  "status": "skipped"
});
formatter.uri("CAPEC_215_Step_1_1.feature");
formatter.feature({
  "line": 2,
  "name": "CAPEC-215: Fuzzing and observing application log data/errors for application mapping",
  "description": "",
  "id": "capec-215:-fuzzing-and-observing-application-log-data/errors-for-application-mapping",
  "keyword": "Feature",
  "tags": [
    {
      "line": 1,
      "name": "@capec215"
    }
  ]
});
formatter.scenario({
  "comments": [
    {
      "line": 3,
      "value": "#1. Explore"
    }
  ],
  "line": 4,
  "name": "Step1.1 Probing",
  "description": "",
  "id": "capec-215:-fuzzing-and-observing-application-log-data/errors-for-application-mapping;step1.1-probing",
  "type": "scenario",
  "keyword": "Scenario"
});
formatter.step({
  "line": 5,
  "name": "prepare to Probing",
  "keyword": "Given "
});
formatter.step({
  "line": 6,
  "name": "Try to Probing",
  "keyword": "When "
});
formatter.step({
  "comments": [
    {
      "line": 7,
      "value": "# assertion for attack step success"
    }
  ],
  "line": 8,
  "name": "Assert the success of Probing",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 9,
      "value": "#assertions for security pattern testing (checker whether the pattern consequences are observed)"
    }
  ],
  "line": 10,
  "name": "assert the consequences of the pattern",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 11,
      "value": "#"
    }
  ],
  "line": 12,
  "name": "assert the consequences of the pattern secure logger",
  "keyword": "Then "
});
formatter.match({
  "location": "probing.preprobing()"
});
formatter.result({
  "duration": 31808,
  "status": "passed"
});
formatter.match({
  "location": "probing.tryprobing()"
});
formatter.result({
  "duration": 8089,
  "status": "passed"
});
formatter.match({
  "location": "probing.assprobing()"
});
formatter.result({
  "duration": 6103,
  "status": "passed"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({
  "location": "PatternSteps.asssecurelogger()"
});
formatter.result({
  "status": "skipped"
});
formatter.uri("CAPEC_215_Step_2_1.feature");
formatter.feature({
  "line": 2,
  "name": "CAPEC-215: Fuzzing and observing application log data/errors for application mapping",
  "description": "",
  "id": "capec-215:-fuzzing-and-observing-application-log-data/errors-for-application-mapping",
  "keyword": "Feature",
  "tags": [
    {
      "line": 1,
      "name": "@capec215"
    }
  ]
});
formatter.scenario({
  "comments": [
    {
      "line": 3,
      "value": "#2. Experiment"
    }
  ],
  "line": 4,
  "name": "Step2.1 Modify the parameters to get the desired information from the error messages.",
  "description": "",
  "id": "capec-215:-fuzzing-and-observing-application-log-data/errors-for-application-mapping;step2.1-modify-the-parameters-to-get-the-desired-information-from-the-error-messages.",
  "type": "scenario",
  "keyword": "Scenario"
});
formatter.step({
  "line": 5,
  "name": "prepare to Modify the parameters to get the desired information from the error messages.",
  "keyword": "Given "
});
formatter.step({
  "line": 6,
  "name": "Try to Modify the parameters to get the desired information from the error messages.",
  "keyword": "When "
});
formatter.step({
  "comments": [
    {
      "line": 7,
      "value": "# assertion for attack step success"
    }
  ],
  "line": 8,
  "name": "Assert the success of Modify the parameters to get the desired information from the error messages.",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 9,
      "value": "#assertions for security pattern testing (checker whether the pattern consequences are observed)"
    }
  ],
  "line": 10,
  "name": "assert the consequences of the pattern",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 11,
      "value": "#"
    }
  ],
  "line": 12,
  "name": "assert the consequences of the pattern secure logger",
  "keyword": "Then "
});
formatter.match({
  "location": "modifytheparameterstogetthedesiredinformationfromtheerrormessages.premodifytheparameterstogetthedesiredinformationfromtheerrormessages()"
});
formatter.result({
  "duration": 53284,
  "status": "passed"
});
formatter.match({
  "location": "modifytheparameterstogetthedesiredinformationfromtheerrormessages.trymodifytheparameterstogetthedesiredinformationfromtheerrormessages()"
});
formatter.result({
  "duration": 7957,
  "status": "passed"
});
formatter.match({
  "location": "modifytheparameterstogetthedesiredinformationfromtheerrormessages.assmodifytheparameterstogetthedesiredinformationfromtheerrormessages()"
});
formatter.result({
  "duration": 6841,
  "status": "passed"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({
  "location": "PatternSteps.asssecurelogger()"
});
formatter.result({
  "status": "skipped"
});
formatter.uri("CAPEC_217_Step_1_1.feature");
formatter.feature({
  "line": 2,
  "name": "CAPEC-217: Exploiting Incorrectly Configured SSL",
  "description": "",
  "id": "capec-217:-exploiting-incorrectly-configured-ssl",
  "keyword": "Feature",
  "tags": [
    {
      "line": 1,
      "name": "@capec217"
    }
  ]
});
formatter.scenario({
  "comments": [
    {
      "line": 3,
      "value": "#1. Explore"
    }
  ],
  "line": 4,
  "name": "Step1.1",
  "description": "",
  "id": "capec-217:-exploiting-incorrectly-configured-ssl;step1.1",
  "type": "scenario",
  "keyword": "Scenario"
});
formatter.step({
  "line": 5,
  "name": "prepare to",
  "keyword": "Given "
});
formatter.step({
  "line": 6,
  "name": "Try to",
  "keyword": "When "
});
formatter.step({
  "comments": [
    {
      "line": 7,
      "value": "# assertion for attack step success"
    }
  ],
  "line": 8,
  "name": "Assert the success of",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 9,
      "value": "#assertions for security pattern testing (checker whether the pattern consequences are observed)"
    }
  ],
  "line": 10,
  "name": "assert the consequences of the pattern",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 11,
      "value": "#"
    }
  ],
  "line": 12,
  "name": "assert the consequences of the pattern audit interceptor",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 13,
      "value": "# depends secure logger"
    }
  ],
  "line": 14,
  "name": "assert the consequences of the pattern secure logger",
  "keyword": "Then "
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({
  "location": "PatternSteps.assauditinterceptor()"
});
formatter.result({
  "status": "skipped"
});
formatter.match({
  "location": "PatternSteps.asssecurelogger()"
});
formatter.result({
  "status": "skipped"
});
formatter.uri("CAPEC_217_Step_2_1.feature");
formatter.feature({
  "line": 2,
  "name": "CAPEC-217: Exploiting Incorrectly Configured SSL",
  "description": "",
  "id": "capec-217:-exploiting-incorrectly-configured-ssl",
  "keyword": "Feature",
  "tags": [
    {
      "line": 1,
      "name": "@capec217"
    }
  ]
});
formatter.scenario({
  "comments": [
    {
      "line": 3,
      "value": "#2. Experiment"
    }
  ],
  "line": 4,
  "name": "Step2.1",
  "description": "",
  "id": "capec-217:-exploiting-incorrectly-configured-ssl;step2.1",
  "type": "scenario",
  "keyword": "Scenario"
});
formatter.step({
  "line": 5,
  "name": "prepare to",
  "keyword": "Given "
});
formatter.step({
  "line": 6,
  "name": "Try to",
  "keyword": "When "
});
formatter.step({
  "comments": [
    {
      "line": 7,
      "value": "# assertion for attack step success"
    }
  ],
  "line": 8,
  "name": "Assert the success of",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 9,
      "value": "#assertions for security pattern testing (checker whether the pattern consequences are observed)"
    }
  ],
  "line": 10,
  "name": "assert the consequences of the pattern",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 11,
      "value": "#"
    }
  ],
  "line": 12,
  "name": "assert the consequences of the pattern audit interceptor",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 13,
      "value": "# depends secure logger"
    }
  ],
  "line": 14,
  "name": "assert the consequences of the pattern secure logger",
  "keyword": "Then "
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({
  "location": "PatternSteps.assauditinterceptor()"
});
formatter.result({
  "status": "skipped"
});
formatter.match({
  "location": "PatternSteps.asssecurelogger()"
});
formatter.result({
  "status": "skipped"
});
formatter.uri("CAPEC_217_Step_3_1.feature");
formatter.feature({
  "line": 2,
  "name": "CAPEC-217: Exploiting Incorrectly Configured SSL",
  "description": "",
  "id": "capec-217:-exploiting-incorrectly-configured-ssl",
  "keyword": "Feature",
  "tags": [
    {
      "line": 1,
      "name": "@capec217"
    }
  ]
});
formatter.scenario({
  "comments": [
    {
      "line": 3,
      "value": "#3. Exploit"
    }
  ],
  "line": 4,
  "name": "Step3.1",
  "description": "",
  "id": "capec-217:-exploiting-incorrectly-configured-ssl;step3.1",
  "type": "scenario",
  "keyword": "Scenario"
});
formatter.step({
  "line": 5,
  "name": "prepare to",
  "keyword": "Given "
});
formatter.step({
  "line": 6,
  "name": "Try to",
  "keyword": "When "
});
formatter.step({
  "comments": [
    {
      "line": 7,
      "value": "# assertion for attack step success"
    }
  ],
  "line": 8,
  "name": "Assert the success of",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 9,
      "value": "#assertions for security pattern testing (checker whether the pattern consequences are observed)"
    }
  ],
  "line": 10,
  "name": "assert the consequences of the pattern",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 11,
      "value": "#"
    }
  ],
  "line": 12,
  "name": "assert the consequences of the pattern audit interceptor",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 13,
      "value": "# depends secure logger"
    }
  ],
  "line": 14,
  "name": "assert the consequences of the pattern secure logger",
  "keyword": "Then "
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({
  "location": "PatternSteps.assauditinterceptor()"
});
formatter.result({
  "status": "skipped"
});
formatter.match({
  "location": "PatternSteps.asssecurelogger()"
});
formatter.result({
  "status": "skipped"
});
formatter.uri("CAPEC_219_Step_1_1.feature");
formatter.feature({
  "line": 2,
  "name": "CAPEC-219: XML Routing Detour Attacks",
  "description": "",
  "id": "capec-219:-xml-routing-detour-attacks",
  "keyword": "Feature",
  "tags": [
    {
      "line": 1,
      "name": "@capec219"
    }
  ]
});
formatter.scenario({
  "comments": [
    {
      "line": 3,
      "value": "#1. Explore"
    }
  ],
  "line": 4,
  "name": "Step1.1 Survey the target",
  "description": "",
  "id": "capec-219:-xml-routing-detour-attacks;step1.1-survey-the-target",
  "type": "scenario",
  "keyword": "Scenario"
});
formatter.step({
  "line": 5,
  "name": "prepare to Survey the target",
  "keyword": "Given "
});
formatter.step({
  "line": 6,
  "name": "Try to Survey the target",
  "keyword": "When "
});
formatter.step({
  "comments": [
    {
      "line": 7,
      "value": "# assertion for attack step success"
    }
  ],
  "line": 8,
  "name": "Assert the success of Survey the target",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 9,
      "value": "#assertions for security pattern testing (checker whether the pattern consequences are observed)"
    }
  ],
  "line": 10,
  "name": "assert the consequences of the pattern",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 11,
      "value": "#"
    }
  ],
  "line": 12,
  "name": "assert the consequences of the pattern audit interceptor",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 13,
      "value": "# depends secure logger"
    }
  ],
  "line": 14,
  "name": "assert the consequences of the pattern secure logger",
  "keyword": "Then "
});
formatter.match({
  "location": "survey.presurvey()"
});
formatter.result({
  "duration": 0,
  "error_message": "cucumber.runtime.AmbiguousStepDefinitionsException: ✽.Given prepare to Survey the target(CAPEC_219_Step_1_1.feature:5) matches more than one step definition:\n  prepare to Survey in survey.presurvey()\n  prepare to Survey the target in surveythetarget.presurveythetarget()\n\n\tat cucumber.runtime.RuntimeGlue.stepDefinitionMatch(RuntimeGlue.java:71)\n\tat cucumber.runtime.Runtime.runStep(Runtime.java:265)\n\tat cucumber.runtime.model.StepContainer.runStep(StepContainer.java:44)\n\tat cucumber.runtime.model.StepContainer.runSteps(StepContainer.java:39)\n\tat cucumber.runtime.model.CucumberScenario.run(CucumberScenario.java:48)\n\tat cucumber.runtime.junit.ExecutionUnitRunner.run(ExecutionUnitRunner.java:91)\n\tat cucumber.runtime.junit.FeatureRunner.runChild(FeatureRunner.java:63)\n\tat cucumber.runtime.junit.FeatureRunner.runChild(FeatureRunner.java:18)\n\tat org.junit.runners.ParentRunner$3.run(ParentRunner.java:238)\n\tat org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:63)\n\tat org.junit.runners.ParentRunner.runChildren(ParentRunner.java:236)\n\tat org.junit.runners.ParentRunner.access$000(ParentRunner.java:53)\n\tat org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:229)\n\tat org.junit.runners.ParentRunner.run(ParentRunner.java:309)\n\tat cucumber.runtime.junit.FeatureRunner.run(FeatureRunner.java:70)\n\tat cucumber.api.junit.Cucumber.runChild(Cucumber.java:93)\n\tat cucumber.api.junit.Cucumber.runChild(Cucumber.java:37)\n\tat org.junit.runners.ParentRunner$3.run(ParentRunner.java:238)\n\tat org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:63)\n\tat org.junit.runners.ParentRunner.runChildren(ParentRunner.java:236)\n\tat org.junit.runners.ParentRunner.access$000(ParentRunner.java:53)\n\tat org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:229)\n\tat org.junit.internal.runners.statements.RunAfters.evaluate(RunAfters.java:27)\n\tat org.junit.runners.ParentRunner.run(ParentRunner.java:309)\n\tat cucumber.api.junit.Cucumber.run(Cucumber.java:98)\n\tat org.eclipse.jdt.internal.junit4.runner.JUnit4TestReference.run(JUnit4TestReference.java:86)\n\tat org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:459)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:678)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:382)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:192)\n",
  "status": "failed"
});
formatter.match({
  "location": "survey.trysurvey()"
});
formatter.result({
  "duration": 0,
  "error_message": "cucumber.runtime.AmbiguousStepDefinitionsException: ✽.When Try to Survey the target(CAPEC_219_Step_1_1.feature:6) matches more than one step definition:\n  Try to Survey in survey.trysurvey()\n  Try to Survey the target in surveythetarget.trysurveythetarget()\n\n\tat cucumber.runtime.RuntimeGlue.stepDefinitionMatch(RuntimeGlue.java:71)\n\tat cucumber.runtime.Runtime.runStep(Runtime.java:265)\n\tat cucumber.runtime.model.StepContainer.runStep(StepContainer.java:44)\n\tat cucumber.runtime.model.StepContainer.runSteps(StepContainer.java:39)\n\tat cucumber.runtime.model.CucumberScenario.run(CucumberScenario.java:48)\n\tat cucumber.runtime.junit.ExecutionUnitRunner.run(ExecutionUnitRunner.java:91)\n\tat cucumber.runtime.junit.FeatureRunner.runChild(FeatureRunner.java:63)\n\tat cucumber.runtime.junit.FeatureRunner.runChild(FeatureRunner.java:18)\n\tat org.junit.runners.ParentRunner$3.run(ParentRunner.java:238)\n\tat org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:63)\n\tat org.junit.runners.ParentRunner.runChildren(ParentRunner.java:236)\n\tat org.junit.runners.ParentRunner.access$000(ParentRunner.java:53)\n\tat org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:229)\n\tat org.junit.runners.ParentRunner.run(ParentRunner.java:309)\n\tat cucumber.runtime.junit.FeatureRunner.run(FeatureRunner.java:70)\n\tat cucumber.api.junit.Cucumber.runChild(Cucumber.java:93)\n\tat cucumber.api.junit.Cucumber.runChild(Cucumber.java:37)\n\tat org.junit.runners.ParentRunner$3.run(ParentRunner.java:238)\n\tat org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:63)\n\tat org.junit.runners.ParentRunner.runChildren(ParentRunner.java:236)\n\tat org.junit.runners.ParentRunner.access$000(ParentRunner.java:53)\n\tat org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:229)\n\tat org.junit.internal.runners.statements.RunAfters.evaluate(RunAfters.java:27)\n\tat org.junit.runners.ParentRunner.run(ParentRunner.java:309)\n\tat cucumber.api.junit.Cucumber.run(Cucumber.java:98)\n\tat org.eclipse.jdt.internal.junit4.runner.JUnit4TestReference.run(JUnit4TestReference.java:86)\n\tat org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:459)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:678)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:382)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:192)\n",
  "status": "failed"
});
formatter.match({
  "location": "survey.asssurvey()"
});
formatter.result({
  "duration": 0,
  "error_message": "cucumber.runtime.AmbiguousStepDefinitionsException: ✽.Then Assert the success of Survey the target(CAPEC_219_Step_1_1.feature:8) matches more than one step definition:\n  Assert the success of Survey in survey.asssurvey()\n  Assert the success of Survey the target in surveythetarget.asssurveythetarget()\n\n\tat cucumber.runtime.RuntimeGlue.stepDefinitionMatch(RuntimeGlue.java:71)\n\tat cucumber.runtime.Runtime.runStep(Runtime.java:265)\n\tat cucumber.runtime.model.StepContainer.runStep(StepContainer.java:44)\n\tat cucumber.runtime.model.StepContainer.runSteps(StepContainer.java:39)\n\tat cucumber.runtime.model.CucumberScenario.run(CucumberScenario.java:48)\n\tat cucumber.runtime.junit.ExecutionUnitRunner.run(ExecutionUnitRunner.java:91)\n\tat cucumber.runtime.junit.FeatureRunner.runChild(FeatureRunner.java:63)\n\tat cucumber.runtime.junit.FeatureRunner.runChild(FeatureRunner.java:18)\n\tat org.junit.runners.ParentRunner$3.run(ParentRunner.java:238)\n\tat org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:63)\n\tat org.junit.runners.ParentRunner.runChildren(ParentRunner.java:236)\n\tat org.junit.runners.ParentRunner.access$000(ParentRunner.java:53)\n\tat org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:229)\n\tat org.junit.runners.ParentRunner.run(ParentRunner.java:309)\n\tat cucumber.runtime.junit.FeatureRunner.run(FeatureRunner.java:70)\n\tat cucumber.api.junit.Cucumber.runChild(Cucumber.java:93)\n\tat cucumber.api.junit.Cucumber.runChild(Cucumber.java:37)\n\tat org.junit.runners.ParentRunner$3.run(ParentRunner.java:238)\n\tat org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:63)\n\tat org.junit.runners.ParentRunner.runChildren(ParentRunner.java:236)\n\tat org.junit.runners.ParentRunner.access$000(ParentRunner.java:53)\n\tat org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:229)\n\tat org.junit.internal.runners.statements.RunAfters.evaluate(RunAfters.java:27)\n\tat org.junit.runners.ParentRunner.run(ParentRunner.java:309)\n\tat cucumber.api.junit.Cucumber.run(Cucumber.java:98)\n\tat org.eclipse.jdt.internal.junit4.runner.JUnit4TestReference.run(JUnit4TestReference.java:86)\n\tat org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:459)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:678)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:382)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:192)\n",
  "status": "failed"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({
  "location": "PatternSteps.assauditinterceptor()"
});
formatter.result({
  "status": "skipped"
});
formatter.match({
  "location": "PatternSteps.asssecurelogger()"
});
formatter.result({
  "status": "skipped"
});
formatter.uri("CAPEC_219_Step_2_1.feature");
formatter.feature({
  "line": 2,
  "name": "CAPEC-219: XML Routing Detour Attacks",
  "description": "",
  "id": "capec-219:-xml-routing-detour-attacks",
  "keyword": "Feature",
  "tags": [
    {
      "line": 1,
      "name": "@capec219"
    }
  ]
});
formatter.scenario({
  "comments": [
    {
      "line": 3,
      "value": "#2. Experiment"
    }
  ],
  "line": 4,
  "name": "Step2.1 Identify SOAP messages that have multiple state processing.",
  "description": "",
  "id": "capec-219:-xml-routing-detour-attacks;step2.1-identify-soap-messages-that-have-multiple-state-processing.",
  "type": "scenario",
  "keyword": "Scenario"
});
formatter.step({
  "line": 5,
  "name": "prepare to Identify SOAP messages that have multiple state processing.",
  "keyword": "Given "
});
formatter.step({
  "line": 6,
  "name": "Try to Identify SOAP messages that have multiple state processing.",
  "keyword": "When "
});
formatter.step({
  "comments": [
    {
      "line": 7,
      "value": "# assertion for attack step success"
    }
  ],
  "line": 8,
  "name": "Assert the success of Identify SOAP messages that have multiple state processing.",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 9,
      "value": "#assertions for security pattern testing (checker whether the pattern consequences are observed)"
    }
  ],
  "line": 10,
  "name": "assert the consequences of the pattern",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 11,
      "value": "#"
    }
  ],
  "line": 12,
  "name": "assert the consequences of the pattern audit interceptor",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 13,
      "value": "# depends secure logger"
    }
  ],
  "line": 14,
  "name": "assert the consequences of the pattern secure logger",
  "keyword": "Then "
});
formatter.match({
  "location": "identifysoapmessagesthathavemultiplestateprocessing.preidentifysoapmessagesthathavemultiplestateprocessing()"
});
formatter.result({
  "duration": 113789,
  "status": "passed"
});
formatter.match({
  "location": "identifysoapmessagesthathavemultiplestateprocessing.tryidentifysoapmessagesthathavemultiplestateprocessing()"
});
formatter.result({
  "duration": 31994,
  "status": "passed"
});
formatter.match({
  "location": "identifysoapmessagesthathavemultiplestateprocessing.assidentifysoapmessagesthathavemultiplestateprocessing()"
});
formatter.result({
  "duration": 8525,
  "status": "passed"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({
  "location": "PatternSteps.assauditinterceptor()"
});
formatter.result({
  "status": "skipped"
});
formatter.match({
  "location": "PatternSteps.asssecurelogger()"
});
formatter.result({
  "status": "skipped"
});
formatter.uri("CAPEC_219_Step_3_1.feature");
formatter.feature({
  "line": 2,
  "name": "CAPEC-219: XML Routing Detour Attacks",
  "description": "",
  "id": "capec-219:-xml-routing-detour-attacks",
  "keyword": "Feature",
  "tags": [
    {
      "line": 1,
      "name": "@capec219"
    }
  ]
});
formatter.scenario({
  "comments": [
    {
      "line": 3,
      "value": "#3. Exploit"
    }
  ],
  "line": 4,
  "name": "Step3.1 Launch an XML routing detour attack",
  "description": "",
  "id": "capec-219:-xml-routing-detour-attacks;step3.1-launch-an-xml-routing-detour-attack",
  "type": "scenario",
  "keyword": "Scenario"
});
formatter.step({
  "line": 5,
  "name": "prepare to Launch an XML routing detour attack",
  "keyword": "Given "
});
formatter.step({
  "line": 6,
  "name": "Try to Launch an XML routing detour attack",
  "keyword": "When "
});
formatter.step({
  "comments": [
    {
      "line": 7,
      "value": "# assertion for attack step success"
    }
  ],
  "line": 8,
  "name": "Assert the success of Launch an XML routing detour attack",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 9,
      "value": "#assertions for security pattern testing (checker whether the pattern consequences are observed)"
    }
  ],
  "line": 10,
  "name": "assert the consequences of the pattern",
  "keyword": "Then "
});
formatter.match({
  "location": "launchanxmlroutingdetourattack.prelaunchanxmlroutingdetourattack()"
});
formatter.result({
  "duration": 73454,
  "status": "passed"
});
formatter.match({
  "location": "launchanxmlroutingdetourattack.trylaunchanxmlroutingdetourattack()"
});
formatter.result({
  "duration": 7275,
  "status": "passed"
});
formatter.match({
  "location": "launchanxmlroutingdetourattack.asslaunchanxmlroutingdetourattack()"
});
formatter.result({
  "duration": 7241,
  "status": "passed"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.uri("CAPEC_21_Step_1_1.feature");
formatter.feature({
  "line": 2,
  "name": "CAPEC-21: Exploitation of Trusted Credentials",
  "description": "",
  "id": "capec-21:-exploitation-of-trusted-credentials",
  "keyword": "Feature",
  "tags": [
    {
      "line": 1,
      "name": "@capec21"
    }
  ]
});
formatter.scenario({
  "comments": [
    {
      "line": 3,
      "value": "#1. Explore"
    }
  ],
  "line": 4,
  "name": "Step1.1 Survey the application for Indicators of Susceptibility",
  "description": "",
  "id": "capec-21:-exploitation-of-trusted-credentials;step1.1-survey-the-application-for-indicators-of-susceptibility",
  "type": "scenario",
  "keyword": "Scenario"
});
formatter.step({
  "line": 5,
  "name": "prepare to Survey the application for Indicators of Susceptibility",
  "keyword": "Given "
});
formatter.step({
  "line": 6,
  "name": "Try to Survey the application for Indicators of Susceptibility",
  "keyword": "When "
});
formatter.step({
  "comments": [
    {
      "line": 7,
      "value": "# assertion for attack step success"
    }
  ],
  "line": 8,
  "name": "Assert the success of Survey the application for Indicators of Susceptibility",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 9,
      "value": "#assertions for security pattern testing (checker whether the pattern consequences are observed)"
    }
  ],
  "line": 10,
  "name": "assert the consequences of the pattern",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 11,
      "value": "#"
    }
  ],
  "line": 12,
  "name": "assert the consequences of the pattern audit interceptor",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 13,
      "value": "# depends secure logger"
    }
  ],
  "line": 14,
  "name": "assert the consequences of the pattern secure logger",
  "keyword": "Then "
});
formatter.match({
  "location": "survey.presurvey()"
});
formatter.result({
  "duration": 0,
  "error_message": "cucumber.runtime.AmbiguousStepDefinitionsException: ✽.Given prepare to Survey the application for Indicators of Susceptibility(CAPEC_21_Step_1_1.feature:5) matches more than one step definition:\n  prepare to Survey in survey.presurvey()\n  prepare to Survey the application in surveytheapplication.presurveytheapplication()\n  prepare to Survey the application for Indicators of Susceptibility in surveytheapplicationforindicatorsofsusceptibility.presurveytheapplicationforindicatorsofsusceptibility()\n\n\tat cucumber.runtime.RuntimeGlue.stepDefinitionMatch(RuntimeGlue.java:71)\n\tat cucumber.runtime.Runtime.runStep(Runtime.java:265)\n\tat cucumber.runtime.model.StepContainer.runStep(StepContainer.java:44)\n\tat cucumber.runtime.model.StepContainer.runSteps(StepContainer.java:39)\n\tat cucumber.runtime.model.CucumberScenario.run(CucumberScenario.java:48)\n\tat cucumber.runtime.junit.ExecutionUnitRunner.run(ExecutionUnitRunner.java:91)\n\tat cucumber.runtime.junit.FeatureRunner.runChild(FeatureRunner.java:63)\n\tat cucumber.runtime.junit.FeatureRunner.runChild(FeatureRunner.java:18)\n\tat org.junit.runners.ParentRunner$3.run(ParentRunner.java:238)\n\tat org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:63)\n\tat org.junit.runners.ParentRunner.runChildren(ParentRunner.java:236)\n\tat org.junit.runners.ParentRunner.access$000(ParentRunner.java:53)\n\tat org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:229)\n\tat org.junit.runners.ParentRunner.run(ParentRunner.java:309)\n\tat cucumber.runtime.junit.FeatureRunner.run(FeatureRunner.java:70)\n\tat cucumber.api.junit.Cucumber.runChild(Cucumber.java:93)\n\tat cucumber.api.junit.Cucumber.runChild(Cucumber.java:37)\n\tat org.junit.runners.ParentRunner$3.run(ParentRunner.java:238)\n\tat org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:63)\n\tat org.junit.runners.ParentRunner.runChildren(ParentRunner.java:236)\n\tat org.junit.runners.ParentRunner.access$000(ParentRunner.java:53)\n\tat org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:229)\n\tat org.junit.internal.runners.statements.RunAfters.evaluate(RunAfters.java:27)\n\tat org.junit.runners.ParentRunner.run(ParentRunner.java:309)\n\tat cucumber.api.junit.Cucumber.run(Cucumber.java:98)\n\tat org.eclipse.jdt.internal.junit4.runner.JUnit4TestReference.run(JUnit4TestReference.java:86)\n\tat org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:459)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:678)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:382)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:192)\n",
  "status": "failed"
});
formatter.match({
  "location": "survey.trysurvey()"
});
formatter.result({
  "duration": 0,
  "error_message": "cucumber.runtime.AmbiguousStepDefinitionsException: ✽.When Try to Survey the application for Indicators of Susceptibility(CAPEC_21_Step_1_1.feature:6) matches more than one step definition:\n  Try to Survey in survey.trysurvey()\n  Try to Survey the application in surveytheapplication.trysurveytheapplication()\n  Try to Survey the application for Indicators of Susceptibility in surveytheapplicationforindicatorsofsusceptibility.trysurveytheapplicationforindicatorsofsusceptibility()\n\n\tat cucumber.runtime.RuntimeGlue.stepDefinitionMatch(RuntimeGlue.java:71)\n\tat cucumber.runtime.Runtime.runStep(Runtime.java:265)\n\tat cucumber.runtime.model.StepContainer.runStep(StepContainer.java:44)\n\tat cucumber.runtime.model.StepContainer.runSteps(StepContainer.java:39)\n\tat cucumber.runtime.model.CucumberScenario.run(CucumberScenario.java:48)\n\tat cucumber.runtime.junit.ExecutionUnitRunner.run(ExecutionUnitRunner.java:91)\n\tat cucumber.runtime.junit.FeatureRunner.runChild(FeatureRunner.java:63)\n\tat cucumber.runtime.junit.FeatureRunner.runChild(FeatureRunner.java:18)\n\tat org.junit.runners.ParentRunner$3.run(ParentRunner.java:238)\n\tat org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:63)\n\tat org.junit.runners.ParentRunner.runChildren(ParentRunner.java:236)\n\tat org.junit.runners.ParentRunner.access$000(ParentRunner.java:53)\n\tat org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:229)\n\tat org.junit.runners.ParentRunner.run(ParentRunner.java:309)\n\tat cucumber.runtime.junit.FeatureRunner.run(FeatureRunner.java:70)\n\tat cucumber.api.junit.Cucumber.runChild(Cucumber.java:93)\n\tat cucumber.api.junit.Cucumber.runChild(Cucumber.java:37)\n\tat org.junit.runners.ParentRunner$3.run(ParentRunner.java:238)\n\tat org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:63)\n\tat org.junit.runners.ParentRunner.runChildren(ParentRunner.java:236)\n\tat org.junit.runners.ParentRunner.access$000(ParentRunner.java:53)\n\tat org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:229)\n\tat org.junit.internal.runners.statements.RunAfters.evaluate(RunAfters.java:27)\n\tat org.junit.runners.ParentRunner.run(ParentRunner.java:309)\n\tat cucumber.api.junit.Cucumber.run(Cucumber.java:98)\n\tat org.eclipse.jdt.internal.junit4.runner.JUnit4TestReference.run(JUnit4TestReference.java:86)\n\tat org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:459)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:678)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:382)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:192)\n",
  "status": "failed"
});
formatter.match({
  "location": "survey.asssurvey()"
});
formatter.result({
  "duration": 0,
  "error_message": "cucumber.runtime.AmbiguousStepDefinitionsException: ✽.Then Assert the success of Survey the application for Indicators of Susceptibility(CAPEC_21_Step_1_1.feature:8) matches more than one step definition:\n  Assert the success of Survey in survey.asssurvey()\n  Assert the success of Survey the application in surveytheapplication.asssurveytheapplication()\n  Assert the success of Survey the application for Indicators of Susceptibility in surveytheapplicationforindicatorsofsusceptibility.asssurveytheapplicationforindicatorsofsusceptibility()\n\n\tat cucumber.runtime.RuntimeGlue.stepDefinitionMatch(RuntimeGlue.java:71)\n\tat cucumber.runtime.Runtime.runStep(Runtime.java:265)\n\tat cucumber.runtime.model.StepContainer.runStep(StepContainer.java:44)\n\tat cucumber.runtime.model.StepContainer.runSteps(StepContainer.java:39)\n\tat cucumber.runtime.model.CucumberScenario.run(CucumberScenario.java:48)\n\tat cucumber.runtime.junit.ExecutionUnitRunner.run(ExecutionUnitRunner.java:91)\n\tat cucumber.runtime.junit.FeatureRunner.runChild(FeatureRunner.java:63)\n\tat cucumber.runtime.junit.FeatureRunner.runChild(FeatureRunner.java:18)\n\tat org.junit.runners.ParentRunner$3.run(ParentRunner.java:238)\n\tat org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:63)\n\tat org.junit.runners.ParentRunner.runChildren(ParentRunner.java:236)\n\tat org.junit.runners.ParentRunner.access$000(ParentRunner.java:53)\n\tat org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:229)\n\tat org.junit.runners.ParentRunner.run(ParentRunner.java:309)\n\tat cucumber.runtime.junit.FeatureRunner.run(FeatureRunner.java:70)\n\tat cucumber.api.junit.Cucumber.runChild(Cucumber.java:93)\n\tat cucumber.api.junit.Cucumber.runChild(Cucumber.java:37)\n\tat org.junit.runners.ParentRunner$3.run(ParentRunner.java:238)\n\tat org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:63)\n\tat org.junit.runners.ParentRunner.runChildren(ParentRunner.java:236)\n\tat org.junit.runners.ParentRunner.access$000(ParentRunner.java:53)\n\tat org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:229)\n\tat org.junit.internal.runners.statements.RunAfters.evaluate(RunAfters.java:27)\n\tat org.junit.runners.ParentRunner.run(ParentRunner.java:309)\n\tat cucumber.api.junit.Cucumber.run(Cucumber.java:98)\n\tat org.eclipse.jdt.internal.junit4.runner.JUnit4TestReference.run(JUnit4TestReference.java:86)\n\tat org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:459)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:678)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:382)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:192)\n",
  "status": "failed"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({
  "location": "PatternSteps.assauditinterceptor()"
});
formatter.result({
  "status": "skipped"
});
formatter.match({
  "location": "PatternSteps.asssecurelogger()"
});
formatter.result({
  "status": "skipped"
});
formatter.uri("CAPEC_21_Step_2_1.feature");
formatter.feature({
  "line": 2,
  "name": "CAPEC-21: Exploitation of Trusted Credentials",
  "description": "",
  "id": "capec-21:-exploitation-of-trusted-credentials",
  "keyword": "Feature",
  "tags": [
    {
      "line": 1,
      "name": "@capec21"
    }
  ]
});
formatter.scenario({
  "comments": [
    {
      "line": 3,
      "value": "#2. Experiment"
    }
  ],
  "line": 4,
  "name": "Step2.1 Fetch samples",
  "description": "",
  "id": "capec-21:-exploitation-of-trusted-credentials;step2.1-fetch-samples",
  "type": "scenario",
  "keyword": "Scenario"
});
formatter.step({
  "line": 5,
  "name": "prepare to Fetch samples",
  "keyword": "Given "
});
formatter.step({
  "line": 6,
  "name": "Try to Fetch samples",
  "keyword": "When "
});
formatter.step({
  "comments": [
    {
      "line": 7,
      "value": "# assertion for attack step success"
    }
  ],
  "line": 8,
  "name": "Assert the success of Fetch samples",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 9,
      "value": "#assertions for security pattern testing (checker whether the pattern consequences are observed)"
    }
  ],
  "line": 10,
  "name": "assert the consequences of the pattern",
  "keyword": "Then "
});
formatter.match({
  "location": "fetchsamples.prefetchsamples()"
});
formatter.result({
  "duration": 79088,
  "status": "passed"
});
formatter.match({
  "location": "fetchsamples.tryfetchsamples()"
});
formatter.result({
  "duration": 9135,
  "status": "passed"
});
formatter.match({
  "location": "fetchsamples.assfetchsamples()"
});
formatter.result({
  "duration": 8376,
  "status": "passed"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.uri("CAPEC_21_Step_3_1.feature");
formatter.feature({
  "line": 2,
  "name": "CAPEC-21: Exploitation of Trusted Credentials",
  "description": "",
  "id": "capec-21:-exploitation-of-trusted-credentials",
  "keyword": "Feature",
  "tags": [
    {
      "line": 1,
      "name": "@capec21"
    }
  ]
});
formatter.scenario({
  "comments": [
    {
      "line": 3,
      "value": "#3. Exploit"
    }
  ],
  "line": 4,
  "name": "Step3.1 Impersonate",
  "description": "",
  "id": "capec-21:-exploitation-of-trusted-credentials;step3.1-impersonate",
  "type": "scenario",
  "keyword": "Scenario"
});
formatter.step({
  "line": 5,
  "name": "prepare to Impersonate",
  "keyword": "Given "
});
formatter.step({
  "line": 6,
  "name": "Try to Impersonate",
  "keyword": "When "
});
formatter.step({
  "comments": [
    {
      "line": 7,
      "value": "# assertion for attack step success"
    }
  ],
  "line": 8,
  "name": "Assert the success of Impersonate",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 9,
      "value": "#assertions for security pattern testing (checker whether the pattern consequences are observed)"
    }
  ],
  "line": 10,
  "name": "assert the consequences of the pattern secure logger",
  "keyword": "Then "
});
formatter.match({
  "location": "impersonate.preimpersonate()"
});
formatter.result({
  "duration": 67929,
  "status": "passed"
});
formatter.match({
  "location": "impersonate.tryimpersonate()"
});
formatter.result({
  "duration": 8914,
  "status": "passed"
});
formatter.match({
  "location": "impersonate.assimpersonate()"
});
formatter.result({
  "duration": 7400,
  "status": "passed"
});
formatter.match({
  "location": "PatternSteps.asssecurelogger()"
});
formatter.result({
  "duration": 19087,
  "status": "passed"
});
formatter.uri("CAPEC_21_Step_3_2.feature");
formatter.feature({
  "line": 2,
  "name": "CAPEC-21: Exploitation of Trusted Credentials",
  "description": "",
  "id": "capec-21:-exploitation-of-trusted-credentials",
  "keyword": "Feature",
  "tags": [
    {
      "line": 1,
      "name": "@capec21"
    }
  ]
});
formatter.scenario({
  "comments": [
    {
      "line": 3,
      "value": "#3. Exploit"
    }
  ],
  "line": 4,
  "name": "Step3.2 Spoofing",
  "description": "",
  "id": "capec-21:-exploitation-of-trusted-credentials;step3.2-spoofing",
  "type": "scenario",
  "keyword": "Scenario"
});
formatter.step({
  "line": 5,
  "name": "prepare to Spoofing",
  "keyword": "Given "
});
formatter.step({
  "line": 6,
  "name": "Try to Spoofing",
  "keyword": "When "
});
formatter.step({
  "comments": [
    {
      "line": 7,
      "value": "# assertion for attack step success"
    }
  ],
  "line": 8,
  "name": "Assert the success of Spoofing",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 9,
      "value": "#assertions for security pattern testing (checker whether the pattern consequences are observed)"
    }
  ],
  "line": 10,
  "name": "assert the consequences of the pattern secure logger",
  "keyword": "Then "
});
formatter.match({
  "location": "spoofing.prespoofing()"
});
formatter.result({
  "duration": 42704,
  "status": "passed"
});
formatter.match({
  "location": "spoofing.tryspoofing()"
});
formatter.result({
  "duration": 5564,
  "status": "passed"
});
formatter.match({
  "location": "spoofing.assspoofing()"
});
formatter.result({
  "duration": 5031,
  "status": "passed"
});
formatter.match({
  "location": "PatternSteps.asssecurelogger()"
});
formatter.result({
  "duration": 16614,
  "status": "passed"
});
formatter.uri("CAPEC_222_Step_1_1.feature");
formatter.feature({
  "line": 2,
  "name": "CAPEC-222: iFrame Overlay",
  "description": "",
  "id": "capec-222:-iframe-overlay",
  "keyword": "Feature",
  "tags": [
    {
      "line": 1,
      "name": "@capec222"
    }
  ]
});
formatter.scenario({
  "comments": [
    {
      "line": 3,
      "value": "#1. Explore"
    }
  ],
  "line": 4,
  "name": "Step1.1 Craft an iFrame Overlay page",
  "description": "",
  "id": "capec-222:-iframe-overlay;step1.1-craft-an-iframe-overlay-page",
  "type": "scenario",
  "keyword": "Scenario"
});
formatter.step({
  "line": 5,
  "name": "prepare to Craft an iFrame Overlay page",
  "keyword": "Given "
});
formatter.step({
  "line": 6,
  "name": "Try to Craft an iFrame Overlay page",
  "keyword": "When "
});
formatter.step({
  "comments": [
    {
      "line": 7,
      "value": "# assertion for attack step success"
    }
  ],
  "line": 8,
  "name": "Assert the success of Craft an iFrame Overlay page",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 9,
      "value": "#assertions for security pattern testing (checker whether the pattern consequences are observed)"
    }
  ],
  "line": 10,
  "name": "assert the consequences of the pattern output guard",
  "keyword": "Then "
});
formatter.step({
  "line": 11,
  "name": "assert the consequences of the pattern comparator checked fault tolerant system",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 12,
      "value": "# alternative output guard"
    }
  ],
  "line": 13,
  "name": "assert the consequences of the pattern secure logger",
  "keyword": "Then "
});
formatter.match({
  "location": "craftaniframeoverlaypage.precraftaniframeoverlaypage()"
});
formatter.result({
  "duration": 61152,
  "status": "passed"
});
formatter.match({
  "location": "craftaniframeoverlaypage.trycraftaniframeoverlaypage()"
});
formatter.result({
  "duration": 5054,
  "status": "passed"
});
formatter.match({
  "location": "craftaniframeoverlaypage.asscraftaniframeoverlaypage()"
});
formatter.result({
  "duration": 5409,
  "status": "passed"
});
formatter.match({
  "location": "PatternSteps.assoutputguard()"
});
formatter.result({
  "duration": 13712,
  "status": "passed"
});
formatter.match({
  "location": "PatternSteps.asscomparatorcheckedfaulttolerantsystem()"
});
formatter.result({
  "duration": 3299,
  "status": "passed"
});
formatter.match({
  "location": "PatternSteps.asssecurelogger()"
});
formatter.result({
  "duration": 4768,
  "status": "passed"
});
formatter.uri("CAPEC_222_Step_2_1.feature");
formatter.feature({
  "line": 2,
  "name": "CAPEC-222: iFrame Overlay",
  "description": "",
  "id": "capec-222:-iframe-overlay",
  "keyword": "Feature",
  "tags": [
    {
      "line": 1,
      "name": "@capec222"
    }
  ]
});
formatter.scenario({
  "comments": [
    {
      "line": 3,
      "value": "#2. Exploit"
    }
  ],
  "line": 4,
  "name": "Step2.1 Attacker tricks victim to load the iFrame overlay page",
  "description": "",
  "id": "capec-222:-iframe-overlay;step2.1-attacker-tricks-victim-to-load-the-iframe-overlay-page",
  "type": "scenario",
  "keyword": "Scenario"
});
formatter.step({
  "line": 5,
  "name": "prepare to Attacker tricks victim to load the iFrame overlay page",
  "keyword": "Given "
});
formatter.step({
  "line": 6,
  "name": "Try to Attacker tricks victim to load the iFrame overlay page",
  "keyword": "When "
});
formatter.step({
  "comments": [
    {
      "line": 7,
      "value": "# assertion for attack step success"
    }
  ],
  "line": 8,
  "name": "Assert the success of Attacker tricks victim to load the iFrame overlay page",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 9,
      "value": "#assertions for security pattern testing (checker whether the pattern consequences are observed)"
    }
  ],
  "line": 10,
  "name": "assert the consequences of the pattern output guard",
  "keyword": "Then "
});
formatter.step({
  "line": 11,
  "name": "assert the consequences of the pattern comparator checked fault tolerant system",
  "keyword": "Then "
});
formatter.match({
  "location": "attackertricksvictimtoloadtheiframeoverlaypage.preattackertricksvictimtoloadtheiframeoverlaypage()"
});
formatter.result({
  "duration": 50935,
  "status": "passed"
});
formatter.match({
  "location": "attackertricksvictimtoloadtheiframeoverlaypage.tryattackertricksvictimtoloadtheiframeoverlaypage()"
});
formatter.result({
  "duration": 14573,
  "status": "passed"
});
formatter.match({
  "location": "attackertricksvictimtoloadtheiframeoverlaypage.assattackertricksvictimtoloadtheiframeoverlaypage()"
});
formatter.result({
  "duration": 7649,
  "status": "passed"
});
formatter.match({
  "location": "PatternSteps.assoutputguard()"
});
formatter.result({
  "duration": 18232,
  "status": "passed"
});
formatter.match({
  "location": "PatternSteps.asscomparatorcheckedfaulttolerantsystem()"
});
formatter.result({
  "duration": 3512,
  "status": "passed"
});
formatter.uri("CAPEC_222_Step_2_2.feature");
formatter.feature({
  "line": 2,
  "name": "CAPEC-222: iFrame Overlay",
  "description": "",
  "id": "capec-222:-iframe-overlay",
  "keyword": "Feature",
  "tags": [
    {
      "line": 1,
      "name": "@capec222"
    }
  ]
});
formatter.scenario({
  "comments": [
    {
      "line": 3,
      "value": "#2. Exploit"
    }
  ],
  "line": 4,
  "name": "Step2.2 Trick victim into interacting with the iFrame overlay page in the desired manner",
  "description": "",
  "id": "capec-222:-iframe-overlay;step2.2-trick-victim-into-interacting-with-the-iframe-overlay-page-in-the-desired-manner",
  "type": "scenario",
  "keyword": "Scenario"
});
formatter.step({
  "line": 5,
  "name": "prepare to Trick victim into interacting with the iFrame overlay page in the desired manner",
  "keyword": "Given "
});
formatter.step({
  "line": 6,
  "name": "Try to Trick victim into interacting with the iFrame overlay page in the desired manner",
  "keyword": "When "
});
formatter.step({
  "comments": [
    {
      "line": 7,
      "value": "# assertion for attack step success"
    }
  ],
  "line": 8,
  "name": "Assert the success of Trick victim into interacting with the iFrame overlay page in the desired manner",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 9,
      "value": "#assertions for security pattern testing (checker whether the pattern consequences are observed)"
    }
  ],
  "line": 10,
  "name": "assert the consequences of the pattern",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 11,
      "value": "#"
    }
  ],
  "line": 12,
  "name": "assert the consequences of the pattern audit interceptor",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 13,
      "value": "# depends secure logger"
    }
  ],
  "line": 14,
  "name": "assert the consequences of the pattern secure logger",
  "keyword": "Then "
});
formatter.match({
  "location": "trickvictimintointeractingwiththeiframeoverlaypageinthedesiredmanner.pretrickvictimintointeractingwiththeiframeoverlaypageinthedesiredmanner()"
});
formatter.result({
  "duration": 52303,
  "status": "passed"
});
formatter.match({
  "location": "trickvictimintointeractingwiththeiframeoverlaypageinthedesiredmanner.trytrickvictimintointeractingwiththeiframeoverlaypageinthedesiredmanner()"
});
formatter.result({
  "duration": 6734,
  "status": "passed"
});
formatter.match({
  "location": "trickvictimintointeractingwiththeiframeoverlaypageinthedesiredmanner.asstrickvictimintointeractingwiththeiframeoverlaypageinthedesiredmanner()"
});
formatter.result({
  "duration": 14752,
  "status": "passed"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({
  "location": "PatternSteps.assauditinterceptor()"
});
formatter.result({
  "status": "skipped"
});
formatter.match({
  "location": "PatternSteps.asssecurelogger()"
});
formatter.result({
  "status": "skipped"
});
formatter.uri("CAPEC_230_Step_1_1.feature");
formatter.feature({
  "line": 2,
  "name": "CAPEC-230: XML Nested Payloads",
  "description": "",
  "id": "capec-230:-xml-nested-payloads",
  "keyword": "Feature",
  "tags": [
    {
      "line": 1,
      "name": "@capec230"
    }
  ]
});
formatter.scenario({
  "comments": [
    {
      "line": 3,
      "value": "#1. Explore"
    }
  ],
  "line": 4,
  "name": "Step1.1",
  "description": "",
  "id": "capec-230:-xml-nested-payloads;step1.1",
  "type": "scenario",
  "keyword": "Scenario"
});
formatter.step({
  "line": 5,
  "name": "prepare to",
  "keyword": "Given "
});
formatter.step({
  "line": 6,
  "name": "Try to",
  "keyword": "When "
});
formatter.step({
  "comments": [
    {
      "line": 7,
      "value": "# assertion for attack step success"
    }
  ],
  "line": 8,
  "name": "Assert the success of",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 9,
      "value": "#assertions for security pattern testing (checker whether the pattern consequences are observed)"
    }
  ],
  "line": 10,
  "name": "assert the consequences of the pattern",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 11,
      "value": "#"
    }
  ],
  "line": 12,
  "name": "assert the consequences of the pattern audit interceptor",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 13,
      "value": "# depends secure logger"
    }
  ],
  "line": 14,
  "name": "assert the consequences of the pattern secure logger",
  "keyword": "Then "
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({
  "location": "PatternSteps.assauditinterceptor()"
});
formatter.result({
  "status": "skipped"
});
formatter.match({
  "location": "PatternSteps.asssecurelogger()"
});
formatter.result({
  "status": "skipped"
});
formatter.uri("CAPEC_230_Step_2_1.feature");
formatter.feature({
  "line": 2,
  "name": "CAPEC-230: XML Nested Payloads",
  "description": "",
  "id": "capec-230:-xml-nested-payloads",
  "keyword": "Feature",
  "tags": [
    {
      "line": 1,
      "name": "@capec230"
    }
  ]
});
formatter.scenario({
  "comments": [
    {
      "line": 3,
      "value": "#2. Experiment"
    }
  ],
  "line": 4,
  "name": "Step2.1",
  "description": "",
  "id": "capec-230:-xml-nested-payloads;step2.1",
  "type": "scenario",
  "keyword": "Scenario"
});
formatter.step({
  "line": 5,
  "name": "prepare to",
  "keyword": "Given "
});
formatter.step({
  "line": 6,
  "name": "Try to",
  "keyword": "When "
});
formatter.step({
  "comments": [
    {
      "line": 7,
      "value": "# assertion for attack step success"
    }
  ],
  "line": 8,
  "name": "Assert the success of",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 9,
      "value": "#assertions for security pattern testing (checker whether the pattern consequences are observed)"
    }
  ],
  "line": 10,
  "name": "assert the consequences of the pattern",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 11,
      "value": "#"
    }
  ],
  "line": 12,
  "name": "assert the consequences of the pattern audit interceptor",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 13,
      "value": "# depends secure logger"
    }
  ],
  "line": 14,
  "name": "assert the consequences of the pattern secure logger",
  "keyword": "Then "
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({
  "location": "PatternSteps.assauditinterceptor()"
});
formatter.result({
  "status": "skipped"
});
formatter.match({
  "location": "PatternSteps.asssecurelogger()"
});
formatter.result({
  "status": "skipped"
});
formatter.uri("CAPEC_231_Step_1_1.feature");
formatter.feature({
  "line": 2,
  "name": "CAPEC-231: XML Oversized Payloads",
  "description": "",
  "id": "capec-231:-xml-oversized-payloads",
  "keyword": "Feature",
  "tags": [
    {
      "line": 1,
      "name": "@capec231"
    }
  ]
});
formatter.scenario({
  "comments": [
    {
      "line": 3,
      "value": "#1. Explore"
    }
  ],
  "line": 4,
  "name": "Step1.1",
  "description": "",
  "id": "capec-231:-xml-oversized-payloads;step1.1",
  "type": "scenario",
  "keyword": "Scenario"
});
formatter.step({
  "line": 5,
  "name": "prepare to",
  "keyword": "Given "
});
formatter.step({
  "line": 6,
  "name": "Try to",
  "keyword": "When "
});
formatter.step({
  "comments": [
    {
      "line": 7,
      "value": "# assertion for attack step success"
    }
  ],
  "line": 8,
  "name": "Assert the success of",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 9,
      "value": "#assertions for security pattern testing (checker whether the pattern consequences are observed)"
    }
  ],
  "line": 10,
  "name": "assert the consequences of the pattern",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 11,
      "value": "#"
    }
  ],
  "line": 12,
  "name": "assert the consequences of the pattern audit interceptor",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 13,
      "value": "# depends secure logger"
    }
  ],
  "line": 14,
  "name": "assert the consequences of the pattern secure logger",
  "keyword": "Then "
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({
  "location": "PatternSteps.assauditinterceptor()"
});
formatter.result({
  "status": "skipped"
});
formatter.match({
  "location": "PatternSteps.asssecurelogger()"
});
formatter.result({
  "status": "skipped"
});
formatter.uri("CAPEC_231_Step_2_1.feature");
formatter.feature({
  "line": 2,
  "name": "CAPEC-231: XML Oversized Payloads",
  "description": "",
  "id": "capec-231:-xml-oversized-payloads",
  "keyword": "Feature",
  "tags": [
    {
      "line": 1,
      "name": "@capec231"
    }
  ]
});
formatter.scenario({
  "comments": [
    {
      "line": 3,
      "value": "#2. Experiment"
    }
  ],
  "line": 4,
  "name": "Step2.1",
  "description": "",
  "id": "capec-231:-xml-oversized-payloads;step2.1",
  "type": "scenario",
  "keyword": "Scenario"
});
formatter.step({
  "line": 5,
  "name": "prepare to",
  "keyword": "Given "
});
formatter.step({
  "line": 6,
  "name": "Try to",
  "keyword": "When "
});
formatter.step({
  "comments": [
    {
      "line": 7,
      "value": "# assertion for attack step success"
    }
  ],
  "line": 8,
  "name": "Assert the success of",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 9,
      "value": "#assertions for security pattern testing (checker whether the pattern consequences are observed)"
    }
  ],
  "line": 10,
  "name": "assert the consequences of the pattern",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 11,
      "value": "#"
    }
  ],
  "line": 12,
  "name": "assert the consequences of the pattern audit interceptor",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 13,
      "value": "# depends secure logger"
    }
  ],
  "line": 14,
  "name": "assert the consequences of the pattern secure logger",
  "keyword": "Then "
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({
  "location": "PatternSteps.assauditinterceptor()"
});
formatter.result({
  "status": "skipped"
});
formatter.match({
  "location": "PatternSteps.asssecurelogger()"
});
formatter.result({
  "status": "skipped"
});
formatter.uri("CAPEC_236_Step_1_1.feature");
formatter.feature({
  "line": 2,
  "name": "CAPEC-236: Catching exception throw/signal from privileged block",
  "description": "",
  "id": "capec-236:-catching-exception-throw/signal-from-privileged-block",
  "keyword": "Feature",
  "tags": [
    {
      "line": 1,
      "name": "@capec236"
    }
  ]
});
formatter.scenario({
  "comments": [
    {
      "line": 3,
      "value": "#1. Explore"
    }
  ],
  "line": 4,
  "name": "Step1.1",
  "description": "",
  "id": "capec-236:-catching-exception-throw/signal-from-privileged-block;step1.1",
  "type": "scenario",
  "keyword": "Scenario"
});
formatter.step({
  "line": 5,
  "name": "prepare to",
  "keyword": "Given "
});
formatter.step({
  "line": 6,
  "name": "Try to",
  "keyword": "When "
});
formatter.step({
  "comments": [
    {
      "line": 7,
      "value": "# assertion for attack step success"
    }
  ],
  "line": 8,
  "name": "Assert the success of",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 9,
      "value": "#assertions for security pattern testing (checker whether the pattern consequences are observed)"
    }
  ],
  "line": 10,
  "name": "assert the consequences of the pattern",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 11,
      "value": "#"
    }
  ],
  "line": 12,
  "name": "assert the consequences of the pattern audit interceptor",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 13,
      "value": "# depends secure logger"
    }
  ],
  "line": 14,
  "name": "assert the consequences of the pattern secure logger",
  "keyword": "Then "
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({
  "location": "PatternSteps.assauditinterceptor()"
});
formatter.result({
  "status": "skipped"
});
formatter.match({
  "location": "PatternSteps.asssecurelogger()"
});
formatter.result({
  "status": "skipped"
});
formatter.uri("CAPEC_236_Step_2_1.feature");
formatter.feature({
  "line": 2,
  "name": "CAPEC-236: Catching exception throw/signal from privileged block",
  "description": "",
  "id": "capec-236:-catching-exception-throw/signal-from-privileged-block",
  "keyword": "Feature",
  "tags": [
    {
      "line": 1,
      "name": "@capec236"
    }
  ]
});
formatter.scenario({
  "comments": [
    {
      "line": 3,
      "value": "#2. Experiment"
    }
  ],
  "line": 4,
  "name": "Step2.1",
  "description": "",
  "id": "capec-236:-catching-exception-throw/signal-from-privileged-block;step2.1",
  "type": "scenario",
  "keyword": "Scenario"
});
formatter.step({
  "line": 5,
  "name": "prepare to",
  "keyword": "Given "
});
formatter.step({
  "line": 6,
  "name": "Try to",
  "keyword": "When "
});
formatter.step({
  "comments": [
    {
      "line": 7,
      "value": "# assertion for attack step success"
    }
  ],
  "line": 8,
  "name": "Assert the success of",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 9,
      "value": "#assertions for security pattern testing (checker whether the pattern consequences are observed)"
    }
  ],
  "line": 10,
  "name": "assert the consequences of the pattern",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 11,
      "value": "#"
    }
  ],
  "line": 12,
  "name": "assert the consequences of the pattern audit interceptor",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 13,
      "value": "# depends secure logger"
    }
  ],
  "line": 14,
  "name": "assert the consequences of the pattern secure logger",
  "keyword": "Then "
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({
  "location": "PatternSteps.assauditinterceptor()"
});
formatter.result({
  "status": "skipped"
});
formatter.match({
  "location": "PatternSteps.asssecurelogger()"
});
formatter.result({
  "status": "skipped"
});
formatter.uri("CAPEC_236_Step_3_1.feature");
formatter.feature({
  "line": 2,
  "name": "CAPEC-236: Catching exception throw/signal from privileged block",
  "description": "",
  "id": "capec-236:-catching-exception-throw/signal-from-privileged-block",
  "keyword": "Feature",
  "tags": [
    {
      "line": 1,
      "name": "@capec236"
    }
  ]
});
formatter.scenario({
  "comments": [
    {
      "line": 3,
      "value": "#3. Exploit"
    }
  ],
  "line": 4,
  "name": "Step3.1",
  "description": "",
  "id": "capec-236:-catching-exception-throw/signal-from-privileged-block;step3.1",
  "type": "scenario",
  "keyword": "Scenario"
});
formatter.step({
  "line": 5,
  "name": "prepare to",
  "keyword": "Given "
});
formatter.step({
  "line": 6,
  "name": "Try to",
  "keyword": "When "
});
formatter.step({
  "comments": [
    {
      "line": 7,
      "value": "# assertion for attack step success"
    }
  ],
  "line": 8,
  "name": "Assert the success of",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 9,
      "value": "#assertions for security pattern testing (checker whether the pattern consequences are observed)"
    }
  ],
  "line": 10,
  "name": "assert the consequences of the pattern",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 11,
      "value": "#"
    }
  ],
  "line": 12,
  "name": "assert the consequences of the pattern audit interceptor",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 13,
      "value": "# depends secure logger"
    }
  ],
  "line": 14,
  "name": "assert the consequences of the pattern secure logger",
  "keyword": "Then "
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({
  "location": "PatternSteps.assauditinterceptor()"
});
formatter.result({
  "status": "skipped"
});
formatter.match({
  "location": "PatternSteps.asssecurelogger()"
});
formatter.result({
  "status": "skipped"
});
formatter.uri("CAPEC_237_Step_1_1.feature");
formatter.feature({
  "line": 2,
  "name": "CAPEC-237: Calling Signed Code From Another Language Within A Sandbox Allow This",
  "description": "",
  "id": "capec-237:-calling-signed-code-from-another-language-within-a-sandbox-allow-this",
  "keyword": "Feature",
  "tags": [
    {
      "line": 1,
      "name": "@capec237"
    }
  ]
});
formatter.scenario({
  "comments": [
    {
      "line": 3,
      "value": "#1. Explore"
    }
  ],
  "line": 4,
  "name": "Step1.1 Probing",
  "description": "",
  "id": "capec-237:-calling-signed-code-from-another-language-within-a-sandbox-allow-this;step1.1-probing",
  "type": "scenario",
  "keyword": "Scenario"
});
formatter.step({
  "line": 5,
  "name": "prepare to Probing",
  "keyword": "Given "
});
formatter.step({
  "line": 6,
  "name": "Try to Probing",
  "keyword": "When "
});
formatter.step({
  "comments": [
    {
      "line": 7,
      "value": "# assertion for attack step success"
    }
  ],
  "line": 8,
  "name": "Assert the success of Probing",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 9,
      "value": "#assertions for security pattern testing (checker whether the pattern consequences are observed)"
    }
  ],
  "line": 10,
  "name": "assert the consequences of the pattern",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 11,
      "value": "#"
    }
  ],
  "line": 12,
  "name": "assert the consequences of the pattern audit interceptor",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 13,
      "value": "# depends secure logger"
    }
  ],
  "line": 14,
  "name": "assert the consequences of the pattern secure logger",
  "keyword": "Then "
});
formatter.match({
  "location": "probing.preprobing()"
});
formatter.result({
  "duration": 27829,
  "status": "passed"
});
formatter.match({
  "location": "probing.tryprobing()"
});
formatter.result({
  "duration": 8431,
  "status": "passed"
});
formatter.match({
  "location": "probing.assprobing()"
});
formatter.result({
  "duration": 8829,
  "status": "passed"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({
  "location": "PatternSteps.assauditinterceptor()"
});
formatter.result({
  "status": "skipped"
});
formatter.match({
  "location": "PatternSteps.asssecurelogger()"
});
formatter.result({
  "status": "skipped"
});
formatter.uri("CAPEC_237_Step_1_2.feature");
formatter.feature({
  "line": 2,
  "name": "CAPEC-237: Calling Signed Code From Another Language Within A Sandbox Allow This",
  "description": "",
  "id": "capec-237:-calling-signed-code-from-another-language-within-a-sandbox-allow-this",
  "keyword": "Feature",
  "tags": [
    {
      "line": 1,
      "name": "@capec237"
    }
  ]
});
formatter.scenario({
  "comments": [
    {
      "line": 3,
      "value": "#1. Explore"
    }
  ],
  "line": 4,
  "name": "Step1.2 Analysis",
  "description": "",
  "id": "capec-237:-calling-signed-code-from-another-language-within-a-sandbox-allow-this;step1.2-analysis",
  "type": "scenario",
  "keyword": "Scenario"
});
formatter.step({
  "line": 5,
  "name": "prepare to Analysis",
  "keyword": "Given "
});
formatter.step({
  "line": 6,
  "name": "Try to Analysis",
  "keyword": "When "
});
formatter.step({
  "comments": [
    {
      "line": 7,
      "value": "# assertion for attack step success"
    }
  ],
  "line": 8,
  "name": "Assert the success of Analysis",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 9,
      "value": "#assertions for security pattern testing (checker whether the pattern consequences are observed)"
    }
  ],
  "line": 10,
  "name": "assert the consequences of the pattern",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 11,
      "value": "#"
    }
  ],
  "line": 12,
  "name": "assert the consequences of the pattern secure logger",
  "keyword": "Then "
});
formatter.match({
  "location": "analysis.preanalysis()"
});
formatter.result({
  "duration": 57224,
  "status": "passed"
});
formatter.match({
  "location": "analysis.tryanalysis()"
});
formatter.result({
  "duration": 7025,
  "status": "passed"
});
formatter.match({
  "location": "analysis.assanalysis()"
});
formatter.result({
  "duration": 6647,
  "status": "passed"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({
  "location": "PatternSteps.asssecurelogger()"
});
formatter.result({
  "status": "skipped"
});
formatter.uri("CAPEC_237_Step_2_1.feature");
formatter.feature({
  "line": 2,
  "name": "CAPEC-237: Calling Signed Code From Another Language Within A Sandbox Allow This",
  "description": "",
  "id": "capec-237:-calling-signed-code-from-another-language-within-a-sandbox-allow-this",
  "keyword": "Feature",
  "tags": [
    {
      "line": 1,
      "name": "@capec237"
    }
  ]
});
formatter.scenario({
  "comments": [
    {
      "line": 3,
      "value": "#2. Experiment"
    }
  ],
  "line": 4,
  "name": "Step2.1 Verify the exploitable security weaknesses",
  "description": "",
  "id": "capec-237:-calling-signed-code-from-another-language-within-a-sandbox-allow-this;step2.1-verify-the-exploitable-security-weaknesses",
  "type": "scenario",
  "keyword": "Scenario"
});
formatter.step({
  "line": 5,
  "name": "prepare to Verify the exploitable security weaknesses",
  "keyword": "Given "
});
formatter.step({
  "line": 6,
  "name": "Try to Verify the exploitable security weaknesses",
  "keyword": "When "
});
formatter.step({
  "comments": [
    {
      "line": 7,
      "value": "# assertion for attack step success"
    }
  ],
  "line": 8,
  "name": "Assert the success of Verify the exploitable security weaknesses",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 9,
      "value": "#assertions for security pattern testing (checker whether the pattern consequences are observed)"
    }
  ],
  "line": 10,
  "name": "assert the consequences of the pattern secure logger",
  "keyword": "Then "
});
formatter.match({
  "location": "verifytheexploitablesecurityweaknesses.preverifytheexploitablesecurityweaknesses()"
});
formatter.result({
  "duration": 55059,
  "status": "passed"
});
formatter.match({
  "location": "verifytheexploitablesecurityweaknesses.tryverifytheexploitablesecurityweaknesses()"
});
formatter.result({
  "duration": 17744,
  "status": "passed"
});
formatter.match({
  "location": "verifytheexploitablesecurityweaknesses.assverifytheexploitablesecurityweaknesses()"
});
formatter.result({
  "duration": 7242,
  "status": "passed"
});
formatter.match({
  "location": "PatternSteps.asssecurelogger()"
});
formatter.result({
  "duration": 24143,
  "status": "passed"
});
formatter.uri("CAPEC_237_Step_3_1.feature");
formatter.feature({
  "line": 2,
  "name": "CAPEC-237: Calling Signed Code From Another Language Within A Sandbox Allow This",
  "description": "",
  "id": "capec-237:-calling-signed-code-from-another-language-within-a-sandbox-allow-this",
  "keyword": "Feature",
  "tags": [
    {
      "line": 1,
      "name": "@capec237"
    }
  ]
});
formatter.scenario({
  "comments": [
    {
      "line": 3,
      "value": "#3. Exploit"
    }
  ],
  "line": 4,
  "name": "Step3.1 Exploit the security weaknesses in the standard libraries",
  "description": "",
  "id": "capec-237:-calling-signed-code-from-another-language-within-a-sandbox-allow-this;step3.1-exploit-the-security-weaknesses-in-the-standard-libraries",
  "type": "scenario",
  "keyword": "Scenario"
});
formatter.step({
  "line": 5,
  "name": "prepare to Exploit the security weaknesses in the standard libraries",
  "keyword": "Given "
});
formatter.step({
  "line": 6,
  "name": "Try to Exploit the security weaknesses in the standard libraries",
  "keyword": "When "
});
formatter.step({
  "comments": [
    {
      "line": 7,
      "value": "# assertion for attack step success"
    }
  ],
  "line": 8,
  "name": "Assert the success of Exploit the security weaknesses in the standard libraries",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 9,
      "value": "#assertions for security pattern testing (checker whether the pattern consequences are observed)"
    }
  ],
  "line": 10,
  "name": "assert the consequences of the pattern",
  "keyword": "Then "
});
formatter.match({
  "location": "exploitthesecurityweaknessesinthestandardlibraries.preexploitthesecurityweaknessesinthestandardlibraries()"
});
formatter.result({
  "duration": 85804,
  "status": "passed"
});
formatter.match({
  "location": "exploitthesecurityweaknessesinthestandardlibraries.tryexploitthesecurityweaknessesinthestandardlibraries()"
});
formatter.result({
  "duration": 11962,
  "status": "passed"
});
formatter.match({
  "location": "exploitthesecurityweaknessesinthestandardlibraries.assexploitthesecurityweaknessesinthestandardlibraries()"
});
formatter.result({
  "duration": 11150,
  "status": "passed"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.uri("CAPEC_244_Step_1_1.feature");
formatter.feature({
  "line": 2,
  "name": "CAPEC-244: Cross-Site Scripting via Encoded URI Schemes",
  "description": "",
  "id": "capec-244:-cross-site-scripting-via-encoded-uri-schemes",
  "keyword": "Feature",
  "tags": [
    {
      "line": 1,
      "name": "@capec244"
    }
  ]
});
formatter.scenario({
  "comments": [
    {
      "line": 3,
      "value": "#1. Explore"
    }
  ],
  "line": 4,
  "name": "Step1.1 Survey the application",
  "description": "",
  "id": "capec-244:-cross-site-scripting-via-encoded-uri-schemes;step1.1-survey-the-application",
  "type": "scenario",
  "keyword": "Scenario"
});
formatter.step({
  "line": 5,
  "name": "prepare to Survey the application",
  "keyword": "Given "
});
formatter.step({
  "line": 6,
  "name": "Try to Survey the application",
  "keyword": "When "
});
formatter.step({
  "comments": [
    {
      "line": 7,
      "value": "# assertion for attack step success"
    }
  ],
  "line": 8,
  "name": "Assert the success of Survey the application",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 9,
      "value": "#assertions for security pattern testing (checker whether the pattern consequences are observed)"
    }
  ],
  "line": 10,
  "name": "assert the consequences of the pattern audit interceptor",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 11,
      "value": "# depends secure logger"
    }
  ],
  "line": 12,
  "name": "assert the consequences of the pattern secure logger",
  "keyword": "Then "
});
formatter.match({
  "location": "survey.presurvey()"
});
formatter.result({
  "duration": 0,
  "error_message": "cucumber.runtime.AmbiguousStepDefinitionsException: ✽.Given prepare to Survey the application(CAPEC_244_Step_1_1.feature:5) matches more than one step definition:\n  prepare to Survey in survey.presurvey()\n  prepare to Survey the application in surveytheapplication.presurveytheapplication()\n\n\tat cucumber.runtime.RuntimeGlue.stepDefinitionMatch(RuntimeGlue.java:71)\n\tat cucumber.runtime.Runtime.runStep(Runtime.java:265)\n\tat cucumber.runtime.model.StepContainer.runStep(StepContainer.java:44)\n\tat cucumber.runtime.model.StepContainer.runSteps(StepContainer.java:39)\n\tat cucumber.runtime.model.CucumberScenario.run(CucumberScenario.java:48)\n\tat cucumber.runtime.junit.ExecutionUnitRunner.run(ExecutionUnitRunner.java:91)\n\tat cucumber.runtime.junit.FeatureRunner.runChild(FeatureRunner.java:63)\n\tat cucumber.runtime.junit.FeatureRunner.runChild(FeatureRunner.java:18)\n\tat org.junit.runners.ParentRunner$3.run(ParentRunner.java:238)\n\tat org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:63)\n\tat org.junit.runners.ParentRunner.runChildren(ParentRunner.java:236)\n\tat org.junit.runners.ParentRunner.access$000(ParentRunner.java:53)\n\tat org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:229)\n\tat org.junit.runners.ParentRunner.run(ParentRunner.java:309)\n\tat cucumber.runtime.junit.FeatureRunner.run(FeatureRunner.java:70)\n\tat cucumber.api.junit.Cucumber.runChild(Cucumber.java:93)\n\tat cucumber.api.junit.Cucumber.runChild(Cucumber.java:37)\n\tat org.junit.runners.ParentRunner$3.run(ParentRunner.java:238)\n\tat org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:63)\n\tat org.junit.runners.ParentRunner.runChildren(ParentRunner.java:236)\n\tat org.junit.runners.ParentRunner.access$000(ParentRunner.java:53)\n\tat org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:229)\n\tat org.junit.internal.runners.statements.RunAfters.evaluate(RunAfters.java:27)\n\tat org.junit.runners.ParentRunner.run(ParentRunner.java:309)\n\tat cucumber.api.junit.Cucumber.run(Cucumber.java:98)\n\tat org.eclipse.jdt.internal.junit4.runner.JUnit4TestReference.run(JUnit4TestReference.java:86)\n\tat org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:459)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:678)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:382)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:192)\n",
  "status": "failed"
});
formatter.match({
  "location": "survey.trysurvey()"
});
formatter.result({
  "duration": 0,
  "error_message": "cucumber.runtime.AmbiguousStepDefinitionsException: ✽.When Try to Survey the application(CAPEC_244_Step_1_1.feature:6) matches more than one step definition:\n  Try to Survey in survey.trysurvey()\n  Try to Survey the application in surveytheapplication.trysurveytheapplication()\n\n\tat cucumber.runtime.RuntimeGlue.stepDefinitionMatch(RuntimeGlue.java:71)\n\tat cucumber.runtime.Runtime.runStep(Runtime.java:265)\n\tat cucumber.runtime.model.StepContainer.runStep(StepContainer.java:44)\n\tat cucumber.runtime.model.StepContainer.runSteps(StepContainer.java:39)\n\tat cucumber.runtime.model.CucumberScenario.run(CucumberScenario.java:48)\n\tat cucumber.runtime.junit.ExecutionUnitRunner.run(ExecutionUnitRunner.java:91)\n\tat cucumber.runtime.junit.FeatureRunner.runChild(FeatureRunner.java:63)\n\tat cucumber.runtime.junit.FeatureRunner.runChild(FeatureRunner.java:18)\n\tat org.junit.runners.ParentRunner$3.run(ParentRunner.java:238)\n\tat org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:63)\n\tat org.junit.runners.ParentRunner.runChildren(ParentRunner.java:236)\n\tat org.junit.runners.ParentRunner.access$000(ParentRunner.java:53)\n\tat org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:229)\n\tat org.junit.runners.ParentRunner.run(ParentRunner.java:309)\n\tat cucumber.runtime.junit.FeatureRunner.run(FeatureRunner.java:70)\n\tat cucumber.api.junit.Cucumber.runChild(Cucumber.java:93)\n\tat cucumber.api.junit.Cucumber.runChild(Cucumber.java:37)\n\tat org.junit.runners.ParentRunner$3.run(ParentRunner.java:238)\n\tat org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:63)\n\tat org.junit.runners.ParentRunner.runChildren(ParentRunner.java:236)\n\tat org.junit.runners.ParentRunner.access$000(ParentRunner.java:53)\n\tat org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:229)\n\tat org.junit.internal.runners.statements.RunAfters.evaluate(RunAfters.java:27)\n\tat org.junit.runners.ParentRunner.run(ParentRunner.java:309)\n\tat cucumber.api.junit.Cucumber.run(Cucumber.java:98)\n\tat org.eclipse.jdt.internal.junit4.runner.JUnit4TestReference.run(JUnit4TestReference.java:86)\n\tat org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:459)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:678)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:382)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:192)\n",
  "status": "failed"
});
formatter.match({
  "location": "survey.asssurvey()"
});
formatter.result({
  "duration": 0,
  "error_message": "cucumber.runtime.AmbiguousStepDefinitionsException: ✽.Then Assert the success of Survey the application(CAPEC_244_Step_1_1.feature:8) matches more than one step definition:\n  Assert the success of Survey in survey.asssurvey()\n  Assert the success of Survey the application in surveytheapplication.asssurveytheapplication()\n\n\tat cucumber.runtime.RuntimeGlue.stepDefinitionMatch(RuntimeGlue.java:71)\n\tat cucumber.runtime.Runtime.runStep(Runtime.java:265)\n\tat cucumber.runtime.model.StepContainer.runStep(StepContainer.java:44)\n\tat cucumber.runtime.model.StepContainer.runSteps(StepContainer.java:39)\n\tat cucumber.runtime.model.CucumberScenario.run(CucumberScenario.java:48)\n\tat cucumber.runtime.junit.ExecutionUnitRunner.run(ExecutionUnitRunner.java:91)\n\tat cucumber.runtime.junit.FeatureRunner.runChild(FeatureRunner.java:63)\n\tat cucumber.runtime.junit.FeatureRunner.runChild(FeatureRunner.java:18)\n\tat org.junit.runners.ParentRunner$3.run(ParentRunner.java:238)\n\tat org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:63)\n\tat org.junit.runners.ParentRunner.runChildren(ParentRunner.java:236)\n\tat org.junit.runners.ParentRunner.access$000(ParentRunner.java:53)\n\tat org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:229)\n\tat org.junit.runners.ParentRunner.run(ParentRunner.java:309)\n\tat cucumber.runtime.junit.FeatureRunner.run(FeatureRunner.java:70)\n\tat cucumber.api.junit.Cucumber.runChild(Cucumber.java:93)\n\tat cucumber.api.junit.Cucumber.runChild(Cucumber.java:37)\n\tat org.junit.runners.ParentRunner$3.run(ParentRunner.java:238)\n\tat org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:63)\n\tat org.junit.runners.ParentRunner.runChildren(ParentRunner.java:236)\n\tat org.junit.runners.ParentRunner.access$000(ParentRunner.java:53)\n\tat org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:229)\n\tat org.junit.internal.runners.statements.RunAfters.evaluate(RunAfters.java:27)\n\tat org.junit.runners.ParentRunner.run(ParentRunner.java:309)\n\tat cucumber.api.junit.Cucumber.run(Cucumber.java:98)\n\tat org.eclipse.jdt.internal.junit4.runner.JUnit4TestReference.run(JUnit4TestReference.java:86)\n\tat org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:459)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:678)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:382)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:192)\n",
  "status": "failed"
});
formatter.match({
  "location": "PatternSteps.assauditinterceptor()"
});
formatter.result({
  "status": "skipped"
});
formatter.match({
  "location": "PatternSteps.asssecurelogger()"
});
formatter.result({
  "status": "skipped"
});
formatter.uri("CAPEC_244_Step_2_1.feature");
formatter.feature({
  "line": 2,
  "name": "CAPEC-244: Cross-Site Scripting via Encoded URI Schemes",
  "description": "",
  "id": "capec-244:-cross-site-scripting-via-encoded-uri-schemes",
  "keyword": "Feature",
  "tags": [
    {
      "line": 1,
      "name": "@capec244"
    }
  ]
});
formatter.scenario({
  "comments": [
    {
      "line": 3,
      "value": "#2. Experiment"
    }
  ],
  "line": 4,
  "name": "Step2.1 Attempt injection payload variations on input parameters",
  "description": "",
  "id": "capec-244:-cross-site-scripting-via-encoded-uri-schemes;step2.1-attempt-injection-payload-variations-on-input-parameters",
  "type": "scenario",
  "keyword": "Scenario"
});
formatter.step({
  "line": 5,
  "name": "prepare to Attempt injection payload variations on input parameters",
  "keyword": "Given "
});
formatter.step({
  "line": 6,
  "name": "Try to Attempt injection payload variations on input parameters",
  "keyword": "When "
});
formatter.step({
  "comments": [
    {
      "line": 7,
      "value": "# assertion for attack step success"
    }
  ],
  "line": 8,
  "name": "Assert the success of Attempt injection payload variations on input parameters",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 9,
      "value": "#assertions for security pattern testing (checker whether the pattern consequences are observed)"
    }
  ],
  "line": 10,
  "name": "assert the consequences of the pattern audit interceptor",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 11,
      "value": "# depends secure logger"
    }
  ],
  "line": 12,
  "name": "assert the consequences of the pattern secure logger",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 13,
      "value": "# benifits audit interceptor"
    }
  ],
  "line": 14,
  "name": "assert the consequences of the pattern input guard",
  "keyword": "Then "
});
formatter.match({
  "location": "attemptinjectionpayloadvariationsoninputparameters.preattemptinjectionpayloadvariationsoninputparameters()"
});
formatter.result({
  "duration": 2685997,
  "error_message": "net.continuumsecurity.proxy.ProxyException: org.zaproxy.clientapi.core.ClientApiException: java.net.ConnectException: Connection refused\n\tat net.continuumsecurity.proxy.ZAProxyScanner.validateMinimumRequiredZapVersion(ZAProxyScanner.java:96)\n\tat net.continuumsecurity.proxy.ZAProxyScanner.\u003cinit\u003e(ZAProxyScanner.java:38)\n\tat steps.attemptinjectionpayloadvariationsoninputparameters.preattemptinjectionpayloadvariationsoninputparameters(attemptinjectionpayloadvariationsoninputparameters.java:16)\n\tat ✽.Given prepare to Attempt injection payload variations on input parameters(CAPEC_244_Step_2_1.feature:5)\nCaused by: org.zaproxy.clientapi.core.ClientApiException: java.net.ConnectException: Connection refused\n\tat org.zaproxy.clientapi.core.ClientApi.callApiDom(ClientApi.java:307)\n\tat org.zaproxy.clientapi.core.ClientApi.callApi(ClientApi.java:289)\n\tat org.zaproxy.clientapi.gen.Core.version(Core.java:158)\n\tat net.continuumsecurity.proxy.ZAProxyScanner.validateMinimumRequiredZapVersion(ZAProxyScanner.java:85)\n\tat net.continuumsecurity.proxy.ZAProxyScanner.\u003cinit\u003e(ZAProxyScanner.java:38)\n\tat steps.attemptinjectionpayloadvariationsoninputparameters.preattemptinjectionpayloadvariationsoninputparameters(attemptinjectionpayloadvariationsoninputparameters.java:16)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.lang.reflect.Method.invoke(Method.java:498)\n\tat cucumber.runtime.Utils$1.call(Utils.java:37)\n\tat cucumber.runtime.Timeout.timeout(Timeout.java:13)\n\tat cucumber.runtime.Utils.invoke(Utils.java:31)\n\tat cucumber.runtime.java.JavaStepDefinition.execute(JavaStepDefinition.java:37)\n\tat cucumber.runtime.StepDefinitionMatch.runStep(StepDefinitionMatch.java:37)\n\tat cucumber.runtime.Runtime.runStep(Runtime.java:298)\n\tat cucumber.runtime.model.StepContainer.runStep(StepContainer.java:44)\n\tat cucumber.runtime.model.StepContainer.runSteps(StepContainer.java:39)\n\tat cucumber.runtime.model.CucumberScenario.run(CucumberScenario.java:48)\n\tat cucumber.runtime.junit.ExecutionUnitRunner.run(ExecutionUnitRunner.java:91)\n\tat cucumber.runtime.junit.FeatureRunner.runChild(FeatureRunner.java:63)\n\tat cucumber.runtime.junit.FeatureRunner.runChild(FeatureRunner.java:18)\n\tat org.junit.runners.ParentRunner$3.run(ParentRunner.java:238)\n\tat org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:63)\n\tat org.junit.runners.ParentRunner.runChildren(ParentRunner.java:236)\n\tat org.junit.runners.ParentRunner.access$000(ParentRunner.java:53)\n\tat org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:229)\n\tat org.junit.runners.ParentRunner.run(ParentRunner.java:309)\n\tat cucumber.runtime.junit.FeatureRunner.run(FeatureRunner.java:70)\n\tat cucumber.api.junit.Cucumber.runChild(Cucumber.java:93)\n\tat cucumber.api.junit.Cucumber.runChild(Cucumber.java:37)\n\tat org.junit.runners.ParentRunner$3.run(ParentRunner.java:238)\n\tat org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:63)\n\tat org.junit.runners.ParentRunner.runChildren(ParentRunner.java:236)\n\tat org.junit.runners.ParentRunner.access$000(ParentRunner.java:53)\n\tat org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:229)\n\tat org.junit.internal.runners.statements.RunAfters.evaluate(RunAfters.java:27)\n\tat org.junit.runners.ParentRunner.run(ParentRunner.java:309)\n\tat cucumber.api.junit.Cucumber.run(Cucumber.java:98)\n\tat org.eclipse.jdt.internal.junit4.runner.JUnit4TestReference.run(JUnit4TestReference.java:86)\n\tat org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:459)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:678)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:382)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:192)\nCaused by: java.net.ConnectException: Connection refused\n\tat java.net.PlainSocketImpl.socketConnect(Native Method)\n\tat java.net.AbstractPlainSocketImpl.doConnect(AbstractPlainSocketImpl.java:350)\n\tat java.net.AbstractPlainSocketImpl.connectToAddress(AbstractPlainSocketImpl.java:206)\n\tat java.net.AbstractPlainSocketImpl.connect(AbstractPlainSocketImpl.java:188)\n\tat java.net.Socket.connect(Socket.java:589)\n\tat java.net.Socket.connect(Socket.java:538)\n\tat sun.net.NetworkClient.doConnect(NetworkClient.java:180)\n\tat sun.net.www.http.HttpClient.openServer(HttpClient.java:432)\n\tat sun.net.www.http.HttpClient$1.run(HttpClient.java:484)\n\tat sun.net.www.http.HttpClient$1.run(HttpClient.java:482)\n\tat java.security.AccessController.doPrivileged(Native Method)\n\tat sun.net.www.http.HttpClient.privilegedOpenServer(HttpClient.java:481)\n\tat sun.net.www.http.HttpClient.openServer(HttpClient.java:522)\n\tat sun.net.www.http.HttpClient.\u003cinit\u003e(HttpClient.java:211)\n\tat sun.net.www.http.HttpClient.New(HttpClient.java:308)\n\tat sun.net.www.http.HttpClient.New(HttpClient.java:326)\n\tat sun.net.www.protocol.http.HttpURLConnection.getNewHttpClient(HttpURLConnection.java:1169)\n\tat sun.net.www.protocol.http.HttpURLConnection.plainConnect0(HttpURLConnection.java:1148)\n\tat sun.net.www.protocol.http.HttpURLConnection.plainConnect(HttpURLConnection.java:999)\n\tat sun.net.www.protocol.http.HttpURLConnection.connect(HttpURLConnection.java:933)\n\tat org.zaproxy.clientapi.core.ClientApi.getConnectionInputStream(ClientApi.java:313)\n\tat org.zaproxy.clientapi.core.ClientApi.callApiDom(ClientApi.java:305)\n\t... 44 more\n",
  "status": "failed"
});
formatter.match({
  "location": "attemptinjectionpayloadvariationsoninputparameters.tryattemptinjectionpayloadvariationsoninputparameters()"
});
formatter.result({
  "status": "skipped"
});
formatter.match({
  "location": "attemptinjectionpayloadvariationsoninputparameters.assattemptinjectionpayloadvariationsoninputparameters()"
});
formatter.result({
  "status": "skipped"
});
formatter.match({
  "location": "PatternSteps.assauditinterceptor()"
});
formatter.result({
  "status": "skipped"
});
formatter.match({
  "location": "PatternSteps.asssecurelogger()"
});
formatter.result({
  "status": "skipped"
});
formatter.match({
  "location": "PatternSteps.assinputguard()"
});
formatter.result({
  "status": "skipped"
});
formatter.uri("CAPEC_244_Step_3_1.feature");
formatter.feature({
  "line": 2,
  "name": "CAPEC-244: Cross-Site Scripting via Encoded URI Schemes",
  "description": "",
  "id": "capec-244:-cross-site-scripting-via-encoded-uri-schemes",
  "keyword": "Feature",
  "tags": [
    {
      "line": 1,
      "name": "@capec244"
    }
  ]
});
formatter.scenario({
  "comments": [
    {
      "line": 3,
      "value": "#3. Exploit"
    }
  ],
  "line": 4,
  "name": "Step3.1 Steal session IDs, credentials, page content, etc.",
  "description": "",
  "id": "capec-244:-cross-site-scripting-via-encoded-uri-schemes;step3.1-steal-session-ids,-credentials,-page-content,-etc.",
  "type": "scenario",
  "keyword": "Scenario"
});
formatter.step({
  "line": 5,
  "name": "prepare to Steal session IDs, credentials, page content, etc.",
  "keyword": "Given "
});
formatter.step({
  "line": 6,
  "name": "Try to Steal session IDs, credentials, page content, etc.",
  "keyword": "When "
});
formatter.step({
  "comments": [
    {
      "line": 7,
      "value": "# assertion for attack step success"
    }
  ],
  "line": 8,
  "name": "Assert the success of Steal session IDs, credentials, page content, etc.",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 9,
      "value": "#assertions for security pattern testing (checker whether the pattern consequences are observed)"
    }
  ],
  "line": 10,
  "name": "assert the consequences of the pattern audit interceptor",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 11,
      "value": "# depends secure logger"
    }
  ],
  "line": 12,
  "name": "assert the consequences of the pattern secure logger",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 13,
      "value": "# benifits audit interceptor"
    }
  ],
  "line": 14,
  "name": "assert the consequences of the pattern application firewall",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 15,
      "value": "# alternative output guard"
    },
    {
      "line": 16,
      "value": "# alternative input guard"
    }
  ],
  "line": 17,
  "name": "assert the consequences of the pattern input guard",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 18,
      "value": "# alternative application firewall"
    },
    {
      "line": 19,
      "value": "# benifits output guard"
    }
  ],
  "line": 20,
  "name": "assert the consequences of the pattern output guard",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 21,
      "value": "# alternative application firewall"
    },
    {
      "line": 22,
      "value": "# benifits input guard"
    }
  ],
  "line": 23,
  "name": "assert the consequences of the pattern comparator checked fault tolerant system",
  "keyword": "Then "
});
formatter.match({
  "location": "stealsessionidscredentialspagecontentetc.prestealsessionidscredentialspagecontentetc()"
});
formatter.result({
  "duration": 36041,
  "status": "passed"
});
formatter.match({
  "location": "stealsessionidscredentialspagecontentetc.trystealsessionidscredentialspagecontentetc()"
});
formatter.result({
  "duration": 8490,
  "status": "passed"
});
formatter.match({
  "location": "stealsessionidscredentialspagecontentetc.assstealsessionidscredentialspagecontentetc()"
});
formatter.result({
  "duration": 9587,
  "status": "passed"
});
formatter.match({
  "location": "PatternSteps.assauditinterceptor()"
});
formatter.result({
  "duration": 22593,
  "status": "passed"
});
formatter.match({
  "location": "PatternSteps.asssecurelogger()"
});
formatter.result({
  "duration": 6517,
  "status": "passed"
});
formatter.match({
  "location": "PatternSteps.assapplicationfirewall()"
});
formatter.result({
  "duration": 5185,
  "status": "passed"
});
formatter.match({
  "location": "PatternSteps.assinputguard()"
});
formatter.result({
  "duration": 4748,
  "status": "passed"
});
formatter.match({
  "location": "PatternSteps.assoutputguard()"
});
formatter.result({
  "duration": 286624,
  "status": "passed"
});
formatter.match({
  "location": "PatternSteps.asscomparatorcheckedfaulttolerantsystem()"
});
formatter.result({
  "duration": 297774,
  "status": "passed"
});
formatter.uri("CAPEC_244_Step_3_2.feature");
formatter.feature({
  "line": 2,
  "name": "CAPEC-244: Cross-Site Scripting via Encoded URI Schemes",
  "description": "",
  "id": "capec-244:-cross-site-scripting-via-encoded-uri-schemes",
  "keyword": "Feature",
  "tags": [
    {
      "line": 1,
      "name": "@capec244"
    }
  ]
});
formatter.scenario({
  "comments": [
    {
      "line": 3,
      "value": "#3. Exploit"
    }
  ],
  "line": 4,
  "name": "Step3.2 Forceful browsing",
  "description": "",
  "id": "capec-244:-cross-site-scripting-via-encoded-uri-schemes;step3.2-forceful-browsing",
  "type": "scenario",
  "keyword": "Scenario"
});
formatter.step({
  "line": 5,
  "name": "prepare to Forceful browsing",
  "keyword": "Given "
});
formatter.step({
  "line": 6,
  "name": "Try to Forceful browsing",
  "keyword": "When "
});
formatter.step({
  "comments": [
    {
      "line": 7,
      "value": "# assertion for attack step success"
    }
  ],
  "line": 8,
  "name": "Assert the success of Forceful browsing",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 9,
      "value": "#assertions for security pattern testing (checker whether the pattern consequences are observed)"
    }
  ],
  "line": 10,
  "name": "assert the consequences of the pattern audit interceptor",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 11,
      "value": "# depends secure logger"
    }
  ],
  "line": 12,
  "name": "assert the consequences of the pattern secure logger",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 13,
      "value": "# benifits audit interceptor"
    }
  ],
  "line": 14,
  "name": "assert the consequences of the pattern application firewall",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 15,
      "value": "# alternative output guard"
    },
    {
      "line": 16,
      "value": "# alternative input guard"
    }
  ],
  "line": 17,
  "name": "assert the consequences of the pattern input guard",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 18,
      "value": "# alternative application firewall"
    },
    {
      "line": 19,
      "value": "# benifits output guard"
    }
  ],
  "line": 20,
  "name": "assert the consequences of the pattern output guard",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 21,
      "value": "# alternative application firewall"
    },
    {
      "line": 22,
      "value": "# benifits input guard"
    }
  ],
  "line": 23,
  "name": "assert the consequences of the pattern comparator checked fault tolerant system",
  "keyword": "Then "
});
formatter.match({
  "location": "forcefulbrowsing.preforcefulbrowsing()"
});
formatter.result({
  "duration": 31701,
  "status": "passed"
});
formatter.match({
  "location": "forcefulbrowsing.tryforcefulbrowsing()"
});
formatter.result({
  "duration": 7182,
  "status": "passed"
});
formatter.match({
  "location": "forcefulbrowsing.assforcefulbrowsing()"
});
formatter.result({
  "duration": 12972,
  "status": "passed"
});
formatter.match({
  "location": "PatternSteps.assauditinterceptor()"
});
formatter.result({
  "duration": 26248,
  "status": "passed"
});
formatter.match({
  "location": "PatternSteps.asssecurelogger()"
});
formatter.result({
  "duration": 5997,
  "status": "passed"
});
formatter.match({
  "location": "PatternSteps.assapplicationfirewall()"
});
formatter.result({
  "duration": 5877,
  "status": "passed"
});
formatter.match({
  "location": "PatternSteps.assinputguard()"
});
formatter.result({
  "duration": 5939,
  "status": "passed"
});
formatter.match({
  "location": "PatternSteps.assoutputguard()"
});
formatter.result({
  "duration": 20446,
  "status": "passed"
});
formatter.match({
  "location": "PatternSteps.asscomparatorcheckedfaulttolerantsystem()"
});
formatter.result({
  "duration": 15718,
  "status": "passed"
});
formatter.uri("CAPEC_244_Step_3_3.feature");
formatter.feature({
  "line": 2,
  "name": "CAPEC-244: Cross-Site Scripting via Encoded URI Schemes",
  "description": "",
  "id": "capec-244:-cross-site-scripting-via-encoded-uri-schemes",
  "keyword": "Feature",
  "tags": [
    {
      "line": 1,
      "name": "@capec244"
    }
  ]
});
formatter.scenario({
  "comments": [
    {
      "line": 3,
      "value": "#3. Exploit"
    }
  ],
  "line": 4,
  "name": "Step3.3 Content spoofing",
  "description": "",
  "id": "capec-244:-cross-site-scripting-via-encoded-uri-schemes;step3.3-content-spoofing",
  "type": "scenario",
  "keyword": "Scenario"
});
formatter.step({
  "line": 5,
  "name": "prepare to Content spoofing",
  "keyword": "Given "
});
formatter.step({
  "line": 6,
  "name": "Try to Content spoofing",
  "keyword": "When "
});
formatter.step({
  "comments": [
    {
      "line": 7,
      "value": "# assertion for attack step success"
    }
  ],
  "line": 8,
  "name": "Assert the success of Content spoofing",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 9,
      "value": "#assertions for security pattern testing (checker whether the pattern consequences are observed)"
    }
  ],
  "line": 10,
  "name": "assert the consequences of the pattern audit interceptor",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 11,
      "value": "# depends secure logger"
    }
  ],
  "line": 12,
  "name": "assert the consequences of the pattern secure logger",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 13,
      "value": "# benifits audit interceptor"
    }
  ],
  "line": 14,
  "name": "assert the consequences of the pattern application firewall",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 15,
      "value": "# alternative output guard"
    },
    {
      "line": 16,
      "value": "# alternative input guard"
    }
  ],
  "line": 17,
  "name": "assert the consequences of the pattern input guard",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 18,
      "value": "# alternative application firewall"
    },
    {
      "line": 19,
      "value": "# benifits output guard"
    }
  ],
  "line": 20,
  "name": "assert the consequences of the pattern output guard",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 21,
      "value": "# alternative application firewall"
    },
    {
      "line": 22,
      "value": "# benifits input guard"
    }
  ],
  "line": 23,
  "name": "assert the consequences of the pattern comparator checked fault tolerant system",
  "keyword": "Then "
});
formatter.match({
  "location": "contentspoofing.precontentspoofing()"
});
formatter.result({
  "duration": 22335,
  "status": "passed"
});
formatter.match({
  "location": "contentspoofing.trycontentspoofing()"
});
formatter.result({
  "duration": 4718,
  "status": "passed"
});
formatter.match({
  "location": "contentspoofing.asscontentspoofing()"
});
formatter.result({
  "duration": 3876,
  "status": "passed"
});
formatter.match({
  "location": "PatternSteps.assauditinterceptor()"
});
formatter.result({
  "duration": 15496,
  "status": "passed"
});
formatter.match({
  "location": "PatternSteps.asssecurelogger()"
});
formatter.result({
  "duration": 4566,
  "status": "passed"
});
formatter.match({
  "location": "PatternSteps.assapplicationfirewall()"
});
formatter.result({
  "duration": 3755,
  "status": "passed"
});
formatter.match({
  "location": "PatternSteps.assinputguard()"
});
formatter.result({
  "duration": 3142,
  "status": "passed"
});
formatter.match({
  "location": "PatternSteps.assoutputguard()"
});
formatter.result({
  "duration": 3960,
  "status": "passed"
});
formatter.match({
  "location": "PatternSteps.asscomparatorcheckedfaulttolerantsystem()"
});
formatter.result({
  "duration": 3697,
  "status": "passed"
});
formatter.uri("CAPEC_246_Step_1_1.feature");
formatter.feature({
  "line": 2,
  "name": "CAPEC-246: Cross-Site Scripting Using Flash",
  "description": "",
  "id": "capec-246:-cross-site-scripting-using-flash",
  "keyword": "Feature",
  "tags": [
    {
      "line": 1,
      "name": "@capec246"
    }
  ]
});
formatter.scenario({
  "comments": [
    {
      "line": 3,
      "value": "#1. Explore"
    }
  ],
  "line": 4,
  "name": "Step1.1 Spider",
  "description": "",
  "id": "capec-246:-cross-site-scripting-using-flash;step1.1-spider",
  "type": "scenario",
  "keyword": "Scenario"
});
formatter.step({
  "line": 5,
  "name": "prepare to Spider",
  "keyword": "Given "
});
formatter.step({
  "line": 6,
  "name": "Try to Spider",
  "keyword": "When "
});
formatter.step({
  "comments": [
    {
      "line": 7,
      "value": "# assertion for attack step success"
    }
  ],
  "line": 8,
  "name": "Assert the success of Spider",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 9,
      "value": "#assertions for security pattern testing (checker whether the pattern consequences are observed)"
    }
  ],
  "line": 10,
  "name": "assert the consequences of the pattern",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 11,
      "value": "#"
    }
  ],
  "line": 12,
  "name": "assert the consequences of the pattern audit interceptor",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 13,
      "value": "# depends secure logger"
    }
  ],
  "line": 14,
  "name": "assert the consequences of the pattern secure logger",
  "keyword": "Then "
});
formatter.match({
  "location": "spider.prespider()"
});
formatter.result({
  "duration": 7434429,
  "error_message": "net.continuumsecurity.proxy.ProxyException: org.zaproxy.clientapi.core.ClientApiException: java.net.ConnectException: Connection refused\n\tat net.continuumsecurity.proxy.ZAProxyScanner.validateMinimumRequiredZapVersion(ZAProxyScanner.java:96)\n\tat net.continuumsecurity.proxy.ZAProxyScanner.\u003cinit\u003e(ZAProxyScanner.java:38)\n\tat steps.spider.prespider(spider.java:17)\n\tat ✽.Given prepare to Spider(CAPEC_246_Step_1_1.feature:5)\nCaused by: org.zaproxy.clientapi.core.ClientApiException: java.net.ConnectException: Connection refused\n\tat org.zaproxy.clientapi.core.ClientApi.callApiDom(ClientApi.java:307)\n\tat org.zaproxy.clientapi.core.ClientApi.callApi(ClientApi.java:289)\n\tat org.zaproxy.clientapi.gen.Core.version(Core.java:158)\n\tat net.continuumsecurity.proxy.ZAProxyScanner.validateMinimumRequiredZapVersion(ZAProxyScanner.java:85)\n\tat net.continuumsecurity.proxy.ZAProxyScanner.\u003cinit\u003e(ZAProxyScanner.java:38)\n\tat steps.spider.prespider(spider.java:17)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.lang.reflect.Method.invoke(Method.java:498)\n\tat cucumber.runtime.Utils$1.call(Utils.java:37)\n\tat cucumber.runtime.Timeout.timeout(Timeout.java:13)\n\tat cucumber.runtime.Utils.invoke(Utils.java:31)\n\tat cucumber.runtime.java.JavaStepDefinition.execute(JavaStepDefinition.java:37)\n\tat cucumber.runtime.StepDefinitionMatch.runStep(StepDefinitionMatch.java:37)\n\tat cucumber.runtime.Runtime.runStep(Runtime.java:298)\n\tat cucumber.runtime.model.StepContainer.runStep(StepContainer.java:44)\n\tat cucumber.runtime.model.StepContainer.runSteps(StepContainer.java:39)\n\tat cucumber.runtime.model.CucumberScenario.run(CucumberScenario.java:48)\n\tat cucumber.runtime.junit.ExecutionUnitRunner.run(ExecutionUnitRunner.java:91)\n\tat cucumber.runtime.junit.FeatureRunner.runChild(FeatureRunner.java:63)\n\tat cucumber.runtime.junit.FeatureRunner.runChild(FeatureRunner.java:18)\n\tat org.junit.runners.ParentRunner$3.run(ParentRunner.java:238)\n\tat org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:63)\n\tat org.junit.runners.ParentRunner.runChildren(ParentRunner.java:236)\n\tat org.junit.runners.ParentRunner.access$000(ParentRunner.java:53)\n\tat org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:229)\n\tat org.junit.runners.ParentRunner.run(ParentRunner.java:309)\n\tat cucumber.runtime.junit.FeatureRunner.run(FeatureRunner.java:70)\n\tat cucumber.api.junit.Cucumber.runChild(Cucumber.java:93)\n\tat cucumber.api.junit.Cucumber.runChild(Cucumber.java:37)\n\tat org.junit.runners.ParentRunner$3.run(ParentRunner.java:238)\n\tat org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:63)\n\tat org.junit.runners.ParentRunner.runChildren(ParentRunner.java:236)\n\tat org.junit.runners.ParentRunner.access$000(ParentRunner.java:53)\n\tat org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:229)\n\tat org.junit.internal.runners.statements.RunAfters.evaluate(RunAfters.java:27)\n\tat org.junit.runners.ParentRunner.run(ParentRunner.java:309)\n\tat cucumber.api.junit.Cucumber.run(Cucumber.java:98)\n\tat org.eclipse.jdt.internal.junit4.runner.JUnit4TestReference.run(JUnit4TestReference.java:86)\n\tat org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:459)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:678)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:382)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:192)\nCaused by: java.net.ConnectException: Connection refused\n\tat java.net.PlainSocketImpl.socketConnect(Native Method)\n\tat java.net.AbstractPlainSocketImpl.doConnect(AbstractPlainSocketImpl.java:350)\n\tat java.net.AbstractPlainSocketImpl.connectToAddress(AbstractPlainSocketImpl.java:206)\n\tat java.net.AbstractPlainSocketImpl.connect(AbstractPlainSocketImpl.java:188)\n\tat java.net.Socket.connect(Socket.java:589)\n\tat java.net.Socket.connect(Socket.java:538)\n\tat sun.net.NetworkClient.doConnect(NetworkClient.java:180)\n\tat sun.net.www.http.HttpClient.openServer(HttpClient.java:432)\n\tat sun.net.www.http.HttpClient$1.run(HttpClient.java:484)\n\tat sun.net.www.http.HttpClient$1.run(HttpClient.java:482)\n\tat java.security.AccessController.doPrivileged(Native Method)\n\tat sun.net.www.http.HttpClient.privilegedOpenServer(HttpClient.java:481)\n\tat sun.net.www.http.HttpClient.openServer(HttpClient.java:522)\n\tat sun.net.www.http.HttpClient.\u003cinit\u003e(HttpClient.java:211)\n\tat sun.net.www.http.HttpClient.New(HttpClient.java:308)\n\tat sun.net.www.http.HttpClient.New(HttpClient.java:326)\n\tat sun.net.www.protocol.http.HttpURLConnection.getNewHttpClient(HttpURLConnection.java:1169)\n\tat sun.net.www.protocol.http.HttpURLConnection.plainConnect0(HttpURLConnection.java:1148)\n\tat sun.net.www.protocol.http.HttpURLConnection.plainConnect(HttpURLConnection.java:999)\n\tat sun.net.www.protocol.http.HttpURLConnection.connect(HttpURLConnection.java:933)\n\tat org.zaproxy.clientapi.core.ClientApi.getConnectionInputStream(ClientApi.java:313)\n\tat org.zaproxy.clientapi.core.ClientApi.callApiDom(ClientApi.java:305)\n\t... 44 more\n",
  "status": "failed"
});
formatter.match({
  "location": "spider.tryspider()"
});
formatter.result({
  "status": "skipped"
});
formatter.match({
  "location": "spider.assspider()"
});
formatter.result({
  "status": "skipped"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({
  "location": "PatternSteps.assauditinterceptor()"
});
formatter.result({
  "status": "skipped"
});
formatter.match({
  "location": "PatternSteps.asssecurelogger()"
});
formatter.result({
  "status": "skipped"
});
formatter.uri("CAPEC_246_Step_2_1.feature");
formatter.feature({
  "line": 2,
  "name": "CAPEC-246: Cross-Site Scripting Using Flash",
  "description": "",
  "id": "capec-246:-cross-site-scripting-using-flash",
  "keyword": "Feature",
  "tags": [
    {
      "line": 1,
      "name": "@capec246"
    }
  ]
});
formatter.scenario({
  "comments": [
    {
      "line": 3,
      "value": "#2. Experiment"
    }
  ],
  "line": 4,
  "name": "Step2.1 Determine the SWF file susceptibility to XSS",
  "description": "",
  "id": "capec-246:-cross-site-scripting-using-flash;step2.1-determine-the-swf-file-susceptibility-to-xss",
  "type": "scenario",
  "keyword": "Scenario"
});
formatter.step({
  "line": 5,
  "name": "prepare to Determine the SWF file susceptibility to XSS",
  "keyword": "Given "
});
formatter.step({
  "line": 6,
  "name": "Try to Determine the SWF file susceptibility to XSS",
  "keyword": "When "
});
formatter.step({
  "comments": [
    {
      "line": 7,
      "value": "# assertion for attack step success"
    }
  ],
  "line": 8,
  "name": "Assert the success of Determine the SWF file susceptibility to XSS",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 9,
      "value": "#assertions for security pattern testing (checker whether the pattern consequences are observed)"
    }
  ],
  "line": 10,
  "name": "assert the consequences of the pattern secure logger",
  "keyword": "Then "
});
formatter.step({
  "line": 11,
  "name": "assert the consequences of the pattern application firewall",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 12,
      "value": "# alternative output guard"
    },
    {
      "line": 13,
      "value": "# alternative input guard"
    }
  ],
  "line": 14,
  "name": "assert the consequences of the pattern input guard",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 15,
      "value": "# alternative application firewall"
    },
    {
      "line": 16,
      "value": "# benifits output guard"
    }
  ],
  "line": 17,
  "name": "assert the consequences of the pattern pathname canonicalization",
  "keyword": "Then "
});
formatter.step({
  "line": 18,
  "name": "assert the consequences of the pattern output guard",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 19,
      "value": "# alternative application firewall"
    },
    {
      "line": 20,
      "value": "# benifits input guard"
    }
  ],
  "line": 21,
  "name": "assert the consequences of the pattern comparator checked fault tolerant system",
  "keyword": "Then "
});
formatter.match({
  "location": "determinetheswffilesusceptibilitytoxss.predeterminetheswffilesusceptibilitytoxss()"
});
formatter.result({
  "duration": 76086,
  "status": "passed"
});
formatter.match({
  "location": "determinetheswffilesusceptibilitytoxss.trydeterminetheswffilesusceptibilitytoxss()"
});
formatter.result({
  "duration": 9738,
  "status": "passed"
});
formatter.match({
  "location": "determinetheswffilesusceptibilitytoxss.assdeterminetheswffilesusceptibilitytoxss()"
});
formatter.result({
  "duration": 7998,
  "status": "passed"
});
formatter.match({
  "location": "PatternSteps.asssecurelogger()"
});
formatter.result({
  "duration": 30356,
  "status": "passed"
});
formatter.match({
  "location": "PatternSteps.assapplicationfirewall()"
});
formatter.result({
  "duration": 7363,
  "status": "passed"
});
formatter.match({
  "location": "PatternSteps.assinputguard()"
});
formatter.result({
  "duration": 5851,
  "status": "passed"
});
formatter.match({
  "location": "PatternSteps.asspathnamecanonicalization()"
});
formatter.result({
  "duration": 6057,
  "status": "passed"
});
formatter.match({
  "location": "PatternSteps.assoutputguard()"
});
formatter.result({
  "duration": 4471,
  "status": "passed"
});
formatter.match({
  "location": "PatternSteps.asscomparatorcheckedfaulttolerantsystem()"
});
formatter.result({
  "duration": 5287,
  "status": "passed"
});
formatter.uri("CAPEC_24_Step_1_1.feature");
formatter.feature({
  "line": 2,
  "name": "CAPEC-24: Filter Failure through Buffer Overflow",
  "description": "",
  "id": "capec-24:-filter-failure-through-buffer-overflow",
  "keyword": "Feature",
  "tags": [
    {
      "line": 1,
      "name": "@capec24"
    }
  ]
});
formatter.scenario({
  "comments": [
    {
      "line": 3,
      "value": "#1. Explore"
    }
  ],
  "line": 4,
  "name": "Step1.1 Survey",
  "description": "",
  "id": "capec-24:-filter-failure-through-buffer-overflow;step1.1-survey",
  "type": "scenario",
  "keyword": "Scenario"
});
formatter.step({
  "line": 5,
  "name": "prepare to Survey",
  "keyword": "Given "
});
formatter.step({
  "line": 6,
  "name": "Try to Survey",
  "keyword": "When "
});
formatter.step({
  "comments": [
    {
      "line": 7,
      "value": "# assertion for attack step success"
    }
  ],
  "line": 8,
  "name": "Assert the success of Survey",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 9,
      "value": "#assertions for security pattern testing (checker whether the pattern consequences are observed)"
    }
  ],
  "line": 10,
  "name": "assert the consequences of the pattern",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 11,
      "value": "#"
    }
  ],
  "line": 12,
  "name": "assert the consequences of the pattern audit interceptor",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 13,
      "value": "# depends secure logger"
    }
  ],
  "line": 14,
  "name": "assert the consequences of the pattern secure logger",
  "keyword": "Then "
});
formatter.match({
  "location": "survey.presurvey()"
});
formatter.result({
  "duration": 4813855,
  "error_message": "net.continuumsecurity.proxy.ProxyException: org.zaproxy.clientapi.core.ClientApiException: java.net.ConnectException: Connection refused\n\tat net.continuumsecurity.proxy.ZAProxyScanner.validateMinimumRequiredZapVersion(ZAProxyScanner.java:96)\n\tat net.continuumsecurity.proxy.ZAProxyScanner.\u003cinit\u003e(ZAProxyScanner.java:38)\n\tat steps.survey.presurvey(survey.java:17)\n\tat ✽.Given prepare to Survey(CAPEC_24_Step_1_1.feature:5)\nCaused by: org.zaproxy.clientapi.core.ClientApiException: java.net.ConnectException: Connection refused\n\tat org.zaproxy.clientapi.core.ClientApi.callApiDom(ClientApi.java:307)\n\tat org.zaproxy.clientapi.core.ClientApi.callApi(ClientApi.java:289)\n\tat org.zaproxy.clientapi.gen.Core.version(Core.java:158)\n\tat net.continuumsecurity.proxy.ZAProxyScanner.validateMinimumRequiredZapVersion(ZAProxyScanner.java:85)\n\tat net.continuumsecurity.proxy.ZAProxyScanner.\u003cinit\u003e(ZAProxyScanner.java:38)\n\tat steps.survey.presurvey(survey.java:17)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.lang.reflect.Method.invoke(Method.java:498)\n\tat cucumber.runtime.Utils$1.call(Utils.java:37)\n\tat cucumber.runtime.Timeout.timeout(Timeout.java:13)\n\tat cucumber.runtime.Utils.invoke(Utils.java:31)\n\tat cucumber.runtime.java.JavaStepDefinition.execute(JavaStepDefinition.java:37)\n\tat cucumber.runtime.StepDefinitionMatch.runStep(StepDefinitionMatch.java:37)\n\tat cucumber.runtime.Runtime.runStep(Runtime.java:298)\n\tat cucumber.runtime.model.StepContainer.runStep(StepContainer.java:44)\n\tat cucumber.runtime.model.StepContainer.runSteps(StepContainer.java:39)\n\tat cucumber.runtime.model.CucumberScenario.run(CucumberScenario.java:48)\n\tat cucumber.runtime.junit.ExecutionUnitRunner.run(ExecutionUnitRunner.java:91)\n\tat cucumber.runtime.junit.FeatureRunner.runChild(FeatureRunner.java:63)\n\tat cucumber.runtime.junit.FeatureRunner.runChild(FeatureRunner.java:18)\n\tat org.junit.runners.ParentRunner$3.run(ParentRunner.java:238)\n\tat org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:63)\n\tat org.junit.runners.ParentRunner.runChildren(ParentRunner.java:236)\n\tat org.junit.runners.ParentRunner.access$000(ParentRunner.java:53)\n\tat org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:229)\n\tat org.junit.runners.ParentRunner.run(ParentRunner.java:309)\n\tat cucumber.runtime.junit.FeatureRunner.run(FeatureRunner.java:70)\n\tat cucumber.api.junit.Cucumber.runChild(Cucumber.java:93)\n\tat cucumber.api.junit.Cucumber.runChild(Cucumber.java:37)\n\tat org.junit.runners.ParentRunner$3.run(ParentRunner.java:238)\n\tat org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:63)\n\tat org.junit.runners.ParentRunner.runChildren(ParentRunner.java:236)\n\tat org.junit.runners.ParentRunner.access$000(ParentRunner.java:53)\n\tat org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:229)\n\tat org.junit.internal.runners.statements.RunAfters.evaluate(RunAfters.java:27)\n\tat org.junit.runners.ParentRunner.run(ParentRunner.java:309)\n\tat cucumber.api.junit.Cucumber.run(Cucumber.java:98)\n\tat org.eclipse.jdt.internal.junit4.runner.JUnit4TestReference.run(JUnit4TestReference.java:86)\n\tat org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:459)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:678)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:382)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:192)\nCaused by: java.net.ConnectException: Connection refused\n\tat java.net.PlainSocketImpl.socketConnect(Native Method)\n\tat java.net.AbstractPlainSocketImpl.doConnect(AbstractPlainSocketImpl.java:350)\n\tat java.net.AbstractPlainSocketImpl.connectToAddress(AbstractPlainSocketImpl.java:206)\n\tat java.net.AbstractPlainSocketImpl.connect(AbstractPlainSocketImpl.java:188)\n\tat java.net.Socket.connect(Socket.java:589)\n\tat java.net.Socket.connect(Socket.java:538)\n\tat sun.net.NetworkClient.doConnect(NetworkClient.java:180)\n\tat sun.net.www.http.HttpClient.openServer(HttpClient.java:432)\n\tat sun.net.www.http.HttpClient$1.run(HttpClient.java:484)\n\tat sun.net.www.http.HttpClient$1.run(HttpClient.java:482)\n\tat java.security.AccessController.doPrivileged(Native Method)\n\tat sun.net.www.http.HttpClient.privilegedOpenServer(HttpClient.java:481)\n\tat sun.net.www.http.HttpClient.openServer(HttpClient.java:522)\n\tat sun.net.www.http.HttpClient.\u003cinit\u003e(HttpClient.java:211)\n\tat sun.net.www.http.HttpClient.New(HttpClient.java:308)\n\tat sun.net.www.http.HttpClient.New(HttpClient.java:326)\n\tat sun.net.www.protocol.http.HttpURLConnection.getNewHttpClient(HttpURLConnection.java:1169)\n\tat sun.net.www.protocol.http.HttpURLConnection.plainConnect0(HttpURLConnection.java:1148)\n\tat sun.net.www.protocol.http.HttpURLConnection.plainConnect(HttpURLConnection.java:999)\n\tat sun.net.www.protocol.http.HttpURLConnection.connect(HttpURLConnection.java:933)\n\tat org.zaproxy.clientapi.core.ClientApi.getConnectionInputStream(ClientApi.java:313)\n\tat org.zaproxy.clientapi.core.ClientApi.callApiDom(ClientApi.java:305)\n\t... 44 more\n",
  "status": "failed"
});
formatter.match({
  "location": "survey.trysurvey()"
});
formatter.result({
  "status": "skipped"
});
formatter.match({
  "location": "survey.asssurvey()"
});
formatter.result({
  "status": "skipped"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({
  "location": "PatternSteps.assauditinterceptor()"
});
formatter.result({
  "status": "skipped"
});
formatter.match({
  "location": "PatternSteps.asssecurelogger()"
});
formatter.result({
  "status": "skipped"
});
formatter.uri("CAPEC_24_Step_2_1.feature");
formatter.feature({
  "line": 2,
  "name": "CAPEC-24: Filter Failure through Buffer Overflow",
  "description": "",
  "id": "capec-24:-filter-failure-through-buffer-overflow",
  "keyword": "Feature",
  "tags": [
    {
      "line": 1,
      "name": "@capec24"
    }
  ]
});
formatter.scenario({
  "comments": [
    {
      "line": 3,
      "value": "#2. Experiment"
    }
  ],
  "line": 4,
  "name": "Step2.1 Attempt injections",
  "description": "",
  "id": "capec-24:-filter-failure-through-buffer-overflow;step2.1-attempt-injections",
  "type": "scenario",
  "keyword": "Scenario"
});
formatter.step({
  "line": 5,
  "name": "prepare to Attempt injections",
  "keyword": "Given "
});
formatter.step({
  "line": 6,
  "name": "Try to Attempt injections",
  "keyword": "When "
});
formatter.step({
  "comments": [
    {
      "line": 7,
      "value": "# assertion for attack step success"
    }
  ],
  "line": 8,
  "name": "Assert the success of Attempt injections",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 9,
      "value": "#assertions for security pattern testing (checker whether the pattern consequences are observed)"
    }
  ],
  "line": 10,
  "name": "assert the consequences of the pattern secure logger",
  "keyword": "Then "
});
formatter.step({
  "line": 11,
  "name": "assert the consequences of the pattern",
  "keyword": "Then "
});
formatter.match({
  "location": "attemptinjections.preattemptinjections()"
});
formatter.result({
  "duration": 6269016,
  "error_message": "net.continuumsecurity.proxy.ProxyException: org.zaproxy.clientapi.core.ClientApiException: java.net.ConnectException: Connection refused\n\tat net.continuumsecurity.proxy.ZAProxyScanner.validateMinimumRequiredZapVersion(ZAProxyScanner.java:96)\n\tat net.continuumsecurity.proxy.ZAProxyScanner.\u003cinit\u003e(ZAProxyScanner.java:38)\n\tat steps.attemptinjections.preattemptinjections(attemptinjections.java:15)\n\tat ✽.Given prepare to Attempt injections(CAPEC_24_Step_2_1.feature:5)\nCaused by: org.zaproxy.clientapi.core.ClientApiException: java.net.ConnectException: Connection refused\n\tat org.zaproxy.clientapi.core.ClientApi.callApiDom(ClientApi.java:307)\n\tat org.zaproxy.clientapi.core.ClientApi.callApi(ClientApi.java:289)\n\tat org.zaproxy.clientapi.gen.Core.version(Core.java:158)\n\tat net.continuumsecurity.proxy.ZAProxyScanner.validateMinimumRequiredZapVersion(ZAProxyScanner.java:85)\n\tat net.continuumsecurity.proxy.ZAProxyScanner.\u003cinit\u003e(ZAProxyScanner.java:38)\n\tat steps.attemptinjections.preattemptinjections(attemptinjections.java:15)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.lang.reflect.Method.invoke(Method.java:498)\n\tat cucumber.runtime.Utils$1.call(Utils.java:37)\n\tat cucumber.runtime.Timeout.timeout(Timeout.java:13)\n\tat cucumber.runtime.Utils.invoke(Utils.java:31)\n\tat cucumber.runtime.java.JavaStepDefinition.execute(JavaStepDefinition.java:37)\n\tat cucumber.runtime.StepDefinitionMatch.runStep(StepDefinitionMatch.java:37)\n\tat cucumber.runtime.Runtime.runStep(Runtime.java:298)\n\tat cucumber.runtime.model.StepContainer.runStep(StepContainer.java:44)\n\tat cucumber.runtime.model.StepContainer.runSteps(StepContainer.java:39)\n\tat cucumber.runtime.model.CucumberScenario.run(CucumberScenario.java:48)\n\tat cucumber.runtime.junit.ExecutionUnitRunner.run(ExecutionUnitRunner.java:91)\n\tat cucumber.runtime.junit.FeatureRunner.runChild(FeatureRunner.java:63)\n\tat cucumber.runtime.junit.FeatureRunner.runChild(FeatureRunner.java:18)\n\tat org.junit.runners.ParentRunner$3.run(ParentRunner.java:238)\n\tat org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:63)\n\tat org.junit.runners.ParentRunner.runChildren(ParentRunner.java:236)\n\tat org.junit.runners.ParentRunner.access$000(ParentRunner.java:53)\n\tat org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:229)\n\tat org.junit.runners.ParentRunner.run(ParentRunner.java:309)\n\tat cucumber.runtime.junit.FeatureRunner.run(FeatureRunner.java:70)\n\tat cucumber.api.junit.Cucumber.runChild(Cucumber.java:93)\n\tat cucumber.api.junit.Cucumber.runChild(Cucumber.java:37)\n\tat org.junit.runners.ParentRunner$3.run(ParentRunner.java:238)\n\tat org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:63)\n\tat org.junit.runners.ParentRunner.runChildren(ParentRunner.java:236)\n\tat org.junit.runners.ParentRunner.access$000(ParentRunner.java:53)\n\tat org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:229)\n\tat org.junit.internal.runners.statements.RunAfters.evaluate(RunAfters.java:27)\n\tat org.junit.runners.ParentRunner.run(ParentRunner.java:309)\n\tat cucumber.api.junit.Cucumber.run(Cucumber.java:98)\n\tat org.eclipse.jdt.internal.junit4.runner.JUnit4TestReference.run(JUnit4TestReference.java:86)\n\tat org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:459)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:678)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:382)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:192)\nCaused by: java.net.ConnectException: Connection refused\n\tat java.net.PlainSocketImpl.socketConnect(Native Method)\n\tat java.net.AbstractPlainSocketImpl.doConnect(AbstractPlainSocketImpl.java:350)\n\tat java.net.AbstractPlainSocketImpl.connectToAddress(AbstractPlainSocketImpl.java:206)\n\tat java.net.AbstractPlainSocketImpl.connect(AbstractPlainSocketImpl.java:188)\n\tat java.net.Socket.connect(Socket.java:589)\n\tat java.net.Socket.connect(Socket.java:538)\n\tat sun.net.NetworkClient.doConnect(NetworkClient.java:180)\n\tat sun.net.www.http.HttpClient.openServer(HttpClient.java:432)\n\tat sun.net.www.http.HttpClient$1.run(HttpClient.java:484)\n\tat sun.net.www.http.HttpClient$1.run(HttpClient.java:482)\n\tat java.security.AccessController.doPrivileged(Native Method)\n\tat sun.net.www.http.HttpClient.privilegedOpenServer(HttpClient.java:481)\n\tat sun.net.www.http.HttpClient.openServer(HttpClient.java:522)\n\tat sun.net.www.http.HttpClient.\u003cinit\u003e(HttpClient.java:211)\n\tat sun.net.www.http.HttpClient.New(HttpClient.java:308)\n\tat sun.net.www.http.HttpClient.New(HttpClient.java:326)\n\tat sun.net.www.protocol.http.HttpURLConnection.getNewHttpClient(HttpURLConnection.java:1169)\n\tat sun.net.www.protocol.http.HttpURLConnection.plainConnect0(HttpURLConnection.java:1148)\n\tat sun.net.www.protocol.http.HttpURLConnection.plainConnect(HttpURLConnection.java:999)\n\tat sun.net.www.protocol.http.HttpURLConnection.connect(HttpURLConnection.java:933)\n\tat org.zaproxy.clientapi.core.ClientApi.getConnectionInputStream(ClientApi.java:313)\n\tat org.zaproxy.clientapi.core.ClientApi.callApiDom(ClientApi.java:305)\n\t... 44 more\n",
  "status": "failed"
});
formatter.match({
  "location": "attemptinjections.tryattemptinjections()"
});
formatter.result({
  "status": "skipped"
});
formatter.match({
  "location": "attemptinjections.assattemptinjections()"
});
formatter.result({
  "status": "skipped"
});
formatter.match({
  "location": "PatternSteps.asssecurelogger()"
});
formatter.result({
  "status": "skipped"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.uri("CAPEC_24_Step_2_2.feature");
formatter.feature({
  "line": 2,
  "name": "CAPEC-24: Filter Failure through Buffer Overflow",
  "description": "",
  "id": "capec-24:-filter-failure-through-buffer-overflow",
  "keyword": "Feature",
  "tags": [
    {
      "line": 1,
      "name": "@capec24"
    }
  ]
});
formatter.scenario({
  "comments": [
    {
      "line": 3,
      "value": "#2. Experiment"
    }
  ],
  "line": 4,
  "name": "Step2.2 Monitor responses",
  "description": "",
  "id": "capec-24:-filter-failure-through-buffer-overflow;step2.2-monitor-responses",
  "type": "scenario",
  "keyword": "Scenario"
});
formatter.step({
  "line": 5,
  "name": "prepare to Monitor responses",
  "keyword": "Given "
});
formatter.step({
  "line": 6,
  "name": "Try to Monitor responses",
  "keyword": "When "
});
formatter.step({
  "comments": [
    {
      "line": 7,
      "value": "# assertion for attack step success"
    }
  ],
  "line": 8,
  "name": "Assert the success of Monitor responses",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 9,
      "value": "#assertions for security pattern testing (checker whether the pattern consequences are observed)"
    }
  ],
  "line": 10,
  "name": "assert the consequences of the pattern secure logger",
  "keyword": "Then "
});
formatter.match({
  "location": "monitorresponses.premonitorresponses()"
});
formatter.result({
  "duration": 89309,
  "status": "passed"
});
formatter.match({
  "location": "monitorresponses.trymonitorresponses()"
});
formatter.result({
  "duration": 7767,
  "status": "passed"
});
formatter.match({
  "location": "monitorresponses.assmonitorresponses()"
});
formatter.result({
  "duration": 6885,
  "status": "passed"
});
formatter.match({
  "location": "PatternSteps.asssecurelogger()"
});
formatter.result({
  "duration": 19332,
  "status": "passed"
});
formatter.uri("CAPEC_24_Step_3_1.feature");
formatter.feature({
  "line": 2,
  "name": "CAPEC-24: Filter Failure through Buffer Overflow",
  "description": "",
  "id": "capec-24:-filter-failure-through-buffer-overflow",
  "keyword": "Feature",
  "tags": [
    {
      "line": 1,
      "name": "@capec24"
    }
  ]
});
formatter.scenario({
  "comments": [
    {
      "line": 3,
      "value": "#3. Exploit"
    }
  ],
  "line": 4,
  "name": "Step3.1 Abuse the system through filter failure",
  "description": "",
  "id": "capec-24:-filter-failure-through-buffer-overflow;step3.1-abuse-the-system-through-filter-failure",
  "type": "scenario",
  "keyword": "Scenario"
});
formatter.step({
  "line": 5,
  "name": "prepare to Abuse the system through filter failure",
  "keyword": "Given "
});
formatter.step({
  "line": 6,
  "name": "Try to Abuse the system through filter failure",
  "keyword": "When "
});
formatter.step({
  "comments": [
    {
      "line": 7,
      "value": "# assertion for attack step success"
    }
  ],
  "line": 8,
  "name": "Assert the success of Abuse the system through filter failure",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 9,
      "value": "#assertions for security pattern testing (checker whether the pattern consequences are observed)"
    }
  ],
  "line": 10,
  "name": "assert the consequences of the pattern secure logger",
  "keyword": "Then "
});
formatter.match({
  "location": "abusethesystemthroughfilterfailure.preabusethesystemthroughfilterfailure()"
});
formatter.result({
  "duration": 78184,
  "status": "passed"
});
formatter.match({
  "location": "abusethesystemthroughfilterfailure.tryabusethesystemthroughfilterfailure()"
});
formatter.result({
  "duration": 7871,
  "status": "passed"
});
formatter.match({
  "location": "abusethesystemthroughfilterfailure.assabusethesystemthroughfilterfailure()"
});
formatter.result({
  "duration": 6839,
  "status": "passed"
});
formatter.match({
  "location": "PatternSteps.asssecurelogger()"
});
formatter.result({
  "duration": 15876,
  "status": "passed"
});
formatter.uri("CAPEC_250_Step_1_1.feature");
formatter.feature({
  "line": 2,
  "name": "CAPEC-250: XML Injection",
  "description": "",
  "id": "capec-250:-xml-injection",
  "keyword": "Feature",
  "tags": [
    {
      "line": 1,
      "name": "@capec250"
    }
  ]
});
formatter.scenario({
  "comments": [
    {
      "line": 3,
      "value": "#1. Explore"
    }
  ],
  "line": 4,
  "name": "Step1.1 Survey Application",
  "description": "",
  "id": "capec-250:-xml-injection;step1.1-survey-application",
  "type": "scenario",
  "keyword": "Scenario"
});
formatter.step({
  "line": 5,
  "name": "prepare to Survey Application",
  "keyword": "Given "
});
formatter.step({
  "line": 6,
  "name": "Try to Survey Application",
  "keyword": "When "
});
formatter.step({
  "comments": [
    {
      "line": 7,
      "value": "# assertion for attack step success"
    }
  ],
  "line": 8,
  "name": "Assert the success of Survey Application",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 9,
      "value": "#assertions for security pattern testing (checker whether the pattern consequences are observed)"
    }
  ],
  "line": 10,
  "name": "assert the consequences of the pattern",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 11,
      "value": "#"
    }
  ],
  "line": 12,
  "name": "assert the consequences of the pattern audit interceptor",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 13,
      "value": "# depends secure logger"
    }
  ],
  "line": 14,
  "name": "assert the consequences of the pattern secure logger",
  "keyword": "Then "
});
formatter.match({
  "location": "survey.presurvey()"
});
formatter.result({
  "duration": 4838293,
  "error_message": "net.continuumsecurity.proxy.ProxyException: org.zaproxy.clientapi.core.ClientApiException: java.net.ConnectException: Connection refused\n\tat net.continuumsecurity.proxy.ZAProxyScanner.validateMinimumRequiredZapVersion(ZAProxyScanner.java:96)\n\tat net.continuumsecurity.proxy.ZAProxyScanner.\u003cinit\u003e(ZAProxyScanner.java:38)\n\tat steps.survey.presurvey(survey.java:17)\n\tat ✽.Given prepare to Survey Application(CAPEC_250_Step_1_1.feature:5)\nCaused by: org.zaproxy.clientapi.core.ClientApiException: java.net.ConnectException: Connection refused\n\tat org.zaproxy.clientapi.core.ClientApi.callApiDom(ClientApi.java:307)\n\tat org.zaproxy.clientapi.core.ClientApi.callApi(ClientApi.java:289)\n\tat org.zaproxy.clientapi.gen.Core.version(Core.java:158)\n\tat net.continuumsecurity.proxy.ZAProxyScanner.validateMinimumRequiredZapVersion(ZAProxyScanner.java:85)\n\tat net.continuumsecurity.proxy.ZAProxyScanner.\u003cinit\u003e(ZAProxyScanner.java:38)\n\tat steps.survey.presurvey(survey.java:17)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.lang.reflect.Method.invoke(Method.java:498)\n\tat cucumber.runtime.Utils$1.call(Utils.java:37)\n\tat cucumber.runtime.Timeout.timeout(Timeout.java:13)\n\tat cucumber.runtime.Utils.invoke(Utils.java:31)\n\tat cucumber.runtime.java.JavaStepDefinition.execute(JavaStepDefinition.java:37)\n\tat cucumber.runtime.StepDefinitionMatch.runStep(StepDefinitionMatch.java:37)\n\tat cucumber.runtime.Runtime.runStep(Runtime.java:298)\n\tat cucumber.runtime.model.StepContainer.runStep(StepContainer.java:44)\n\tat cucumber.runtime.model.StepContainer.runSteps(StepContainer.java:39)\n\tat cucumber.runtime.model.CucumberScenario.run(CucumberScenario.java:48)\n\tat cucumber.runtime.junit.ExecutionUnitRunner.run(ExecutionUnitRunner.java:91)\n\tat cucumber.runtime.junit.FeatureRunner.runChild(FeatureRunner.java:63)\n\tat cucumber.runtime.junit.FeatureRunner.runChild(FeatureRunner.java:18)\n\tat org.junit.runners.ParentRunner$3.run(ParentRunner.java:238)\n\tat org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:63)\n\tat org.junit.runners.ParentRunner.runChildren(ParentRunner.java:236)\n\tat org.junit.runners.ParentRunner.access$000(ParentRunner.java:53)\n\tat org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:229)\n\tat org.junit.runners.ParentRunner.run(ParentRunner.java:309)\n\tat cucumber.runtime.junit.FeatureRunner.run(FeatureRunner.java:70)\n\tat cucumber.api.junit.Cucumber.runChild(Cucumber.java:93)\n\tat cucumber.api.junit.Cucumber.runChild(Cucumber.java:37)\n\tat org.junit.runners.ParentRunner$3.run(ParentRunner.java:238)\n\tat org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:63)\n\tat org.junit.runners.ParentRunner.runChildren(ParentRunner.java:236)\n\tat org.junit.runners.ParentRunner.access$000(ParentRunner.java:53)\n\tat org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:229)\n\tat org.junit.internal.runners.statements.RunAfters.evaluate(RunAfters.java:27)\n\tat org.junit.runners.ParentRunner.run(ParentRunner.java:309)\n\tat cucumber.api.junit.Cucumber.run(Cucumber.java:98)\n\tat org.eclipse.jdt.internal.junit4.runner.JUnit4TestReference.run(JUnit4TestReference.java:86)\n\tat org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:459)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:678)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:382)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:192)\nCaused by: java.net.ConnectException: Connection refused\n\tat java.net.PlainSocketImpl.socketConnect(Native Method)\n\tat java.net.AbstractPlainSocketImpl.doConnect(AbstractPlainSocketImpl.java:350)\n\tat java.net.AbstractPlainSocketImpl.connectToAddress(AbstractPlainSocketImpl.java:206)\n\tat java.net.AbstractPlainSocketImpl.connect(AbstractPlainSocketImpl.java:188)\n\tat java.net.Socket.connect(Socket.java:589)\n\tat java.net.Socket.connect(Socket.java:538)\n\tat sun.net.NetworkClient.doConnect(NetworkClient.java:180)\n\tat sun.net.www.http.HttpClient.openServer(HttpClient.java:432)\n\tat sun.net.www.http.HttpClient$1.run(HttpClient.java:484)\n\tat sun.net.www.http.HttpClient$1.run(HttpClient.java:482)\n\tat java.security.AccessController.doPrivileged(Native Method)\n\tat sun.net.www.http.HttpClient.privilegedOpenServer(HttpClient.java:481)\n\tat sun.net.www.http.HttpClient.openServer(HttpClient.java:522)\n\tat sun.net.www.http.HttpClient.\u003cinit\u003e(HttpClient.java:211)\n\tat sun.net.www.http.HttpClient.New(HttpClient.java:308)\n\tat sun.net.www.http.HttpClient.New(HttpClient.java:326)\n\tat sun.net.www.protocol.http.HttpURLConnection.getNewHttpClient(HttpURLConnection.java:1169)\n\tat sun.net.www.protocol.http.HttpURLConnection.plainConnect0(HttpURLConnection.java:1148)\n\tat sun.net.www.protocol.http.HttpURLConnection.plainConnect(HttpURLConnection.java:999)\n\tat sun.net.www.protocol.http.HttpURLConnection.connect(HttpURLConnection.java:933)\n\tat org.zaproxy.clientapi.core.ClientApi.getConnectionInputStream(ClientApi.java:313)\n\tat org.zaproxy.clientapi.core.ClientApi.callApiDom(ClientApi.java:305)\n\t... 44 more\n",
  "status": "failed"
});
formatter.match({
  "location": "survey.trysurvey()"
});
formatter.result({
  "status": "skipped"
});
formatter.match({
  "location": "survey.asssurvey()"
});
formatter.result({
  "status": "skipped"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({
  "location": "PatternSteps.assauditinterceptor()"
});
formatter.result({
  "status": "skipped"
});
formatter.match({
  "location": "PatternSteps.asssecurelogger()"
});
formatter.result({
  "status": "skipped"
});
formatter.uri("CAPEC_250_Step_2_1.feature");
formatter.feature({
  "line": 2,
  "name": "CAPEC-250: XML Injection",
  "description": "",
  "id": "capec-250:-xml-injection",
  "keyword": "Feature",
  "tags": [
    {
      "line": 1,
      "name": "@capec250"
    }
  ]
});
formatter.scenario({
  "comments": [
    {
      "line": 3,
      "value": "#2. Experiment"
    }
  ],
  "line": 4,
  "name": "Step2.1 Test user-controllable inputs for injection",
  "description": "",
  "id": "capec-250:-xml-injection;step2.1-test-user-controllable-inputs-for-injection",
  "type": "scenario",
  "keyword": "Scenario"
});
formatter.step({
  "line": 5,
  "name": "prepare to Test user-controllable inputs for injection",
  "keyword": "Given "
});
formatter.step({
  "line": 6,
  "name": "Try to Test user-controllable inputs for injection",
  "keyword": "When "
});
formatter.step({
  "comments": [
    {
      "line": 7,
      "value": "# assertion for attack step success"
    }
  ],
  "line": 8,
  "name": "Assert the success of Test user-controllable inputs for injection",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 9,
      "value": "#assertions for security pattern testing (checker whether the pattern consequences are observed)"
    }
  ],
  "line": 10,
  "name": "assert the consequences of the pattern",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 11,
      "value": "#"
    }
  ],
  "line": 12,
  "name": "assert the consequences of the pattern audit interceptor",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 13,
      "value": "# depends secure logger"
    }
  ],
  "line": 14,
  "name": "assert the consequences of the pattern secure logger",
  "keyword": "Then "
});
formatter.match({
  "location": "testusercontrollableinputsforinjection.pretestusercontrollableinputsforinjection()"
});
formatter.result({
  "duration": 3642665,
  "error_message": "net.continuumsecurity.proxy.ProxyException: org.zaproxy.clientapi.core.ClientApiException: java.net.ConnectException: Connection refused\n\tat net.continuumsecurity.proxy.ZAProxyScanner.validateMinimumRequiredZapVersion(ZAProxyScanner.java:96)\n\tat net.continuumsecurity.proxy.ZAProxyScanner.\u003cinit\u003e(ZAProxyScanner.java:38)\n\tat steps.testusercontrollableinputsforinjection.pretestusercontrollableinputsforinjection(testusercontrollableinputsforinjection.java:16)\n\tat ✽.Given prepare to Test user-controllable inputs for injection(CAPEC_250_Step_2_1.feature:5)\nCaused by: org.zaproxy.clientapi.core.ClientApiException: java.net.ConnectException: Connection refused\n\tat org.zaproxy.clientapi.core.ClientApi.callApiDom(ClientApi.java:307)\n\tat org.zaproxy.clientapi.core.ClientApi.callApi(ClientApi.java:289)\n\tat org.zaproxy.clientapi.gen.Core.version(Core.java:158)\n\tat net.continuumsecurity.proxy.ZAProxyScanner.validateMinimumRequiredZapVersion(ZAProxyScanner.java:85)\n\tat net.continuumsecurity.proxy.ZAProxyScanner.\u003cinit\u003e(ZAProxyScanner.java:38)\n\tat steps.testusercontrollableinputsforinjection.pretestusercontrollableinputsforinjection(testusercontrollableinputsforinjection.java:16)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.lang.reflect.Method.invoke(Method.java:498)\n\tat cucumber.runtime.Utils$1.call(Utils.java:37)\n\tat cucumber.runtime.Timeout.timeout(Timeout.java:13)\n\tat cucumber.runtime.Utils.invoke(Utils.java:31)\n\tat cucumber.runtime.java.JavaStepDefinition.execute(JavaStepDefinition.java:37)\n\tat cucumber.runtime.StepDefinitionMatch.runStep(StepDefinitionMatch.java:37)\n\tat cucumber.runtime.Runtime.runStep(Runtime.java:298)\n\tat cucumber.runtime.model.StepContainer.runStep(StepContainer.java:44)\n\tat cucumber.runtime.model.StepContainer.runSteps(StepContainer.java:39)\n\tat cucumber.runtime.model.CucumberScenario.run(CucumberScenario.java:48)\n\tat cucumber.runtime.junit.ExecutionUnitRunner.run(ExecutionUnitRunner.java:91)\n\tat cucumber.runtime.junit.FeatureRunner.runChild(FeatureRunner.java:63)\n\tat cucumber.runtime.junit.FeatureRunner.runChild(FeatureRunner.java:18)\n\tat org.junit.runners.ParentRunner$3.run(ParentRunner.java:238)\n\tat org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:63)\n\tat org.junit.runners.ParentRunner.runChildren(ParentRunner.java:236)\n\tat org.junit.runners.ParentRunner.access$000(ParentRunner.java:53)\n\tat org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:229)\n\tat org.junit.runners.ParentRunner.run(ParentRunner.java:309)\n\tat cucumber.runtime.junit.FeatureRunner.run(FeatureRunner.java:70)\n\tat cucumber.api.junit.Cucumber.runChild(Cucumber.java:93)\n\tat cucumber.api.junit.Cucumber.runChild(Cucumber.java:37)\n\tat org.junit.runners.ParentRunner$3.run(ParentRunner.java:238)\n\tat org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:63)\n\tat org.junit.runners.ParentRunner.runChildren(ParentRunner.java:236)\n\tat org.junit.runners.ParentRunner.access$000(ParentRunner.java:53)\n\tat org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:229)\n\tat org.junit.internal.runners.statements.RunAfters.evaluate(RunAfters.java:27)\n\tat org.junit.runners.ParentRunner.run(ParentRunner.java:309)\n\tat cucumber.api.junit.Cucumber.run(Cucumber.java:98)\n\tat org.eclipse.jdt.internal.junit4.runner.JUnit4TestReference.run(JUnit4TestReference.java:86)\n\tat org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:459)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:678)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:382)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:192)\nCaused by: java.net.ConnectException: Connection refused\n\tat java.net.PlainSocketImpl.socketConnect(Native Method)\n\tat java.net.AbstractPlainSocketImpl.doConnect(AbstractPlainSocketImpl.java:350)\n\tat java.net.AbstractPlainSocketImpl.connectToAddress(AbstractPlainSocketImpl.java:206)\n\tat java.net.AbstractPlainSocketImpl.connect(AbstractPlainSocketImpl.java:188)\n\tat java.net.Socket.connect(Socket.java:589)\n\tat java.net.Socket.connect(Socket.java:538)\n\tat sun.net.NetworkClient.doConnect(NetworkClient.java:180)\n\tat sun.net.www.http.HttpClient.openServer(HttpClient.java:432)\n\tat sun.net.www.http.HttpClient$1.run(HttpClient.java:484)\n\tat sun.net.www.http.HttpClient$1.run(HttpClient.java:482)\n\tat java.security.AccessController.doPrivileged(Native Method)\n\tat sun.net.www.http.HttpClient.privilegedOpenServer(HttpClient.java:481)\n\tat sun.net.www.http.HttpClient.openServer(HttpClient.java:522)\n\tat sun.net.www.http.HttpClient.\u003cinit\u003e(HttpClient.java:211)\n\tat sun.net.www.http.HttpClient.New(HttpClient.java:308)\n\tat sun.net.www.http.HttpClient.New(HttpClient.java:326)\n\tat sun.net.www.protocol.http.HttpURLConnection.getNewHttpClient(HttpURLConnection.java:1169)\n\tat sun.net.www.protocol.http.HttpURLConnection.plainConnect0(HttpURLConnection.java:1148)\n\tat sun.net.www.protocol.http.HttpURLConnection.plainConnect(HttpURLConnection.java:999)\n\tat sun.net.www.protocol.http.HttpURLConnection.connect(HttpURLConnection.java:933)\n\tat org.zaproxy.clientapi.core.ClientApi.getConnectionInputStream(ClientApi.java:313)\n\tat org.zaproxy.clientapi.core.ClientApi.callApiDom(ClientApi.java:305)\n\t... 44 more\n",
  "status": "failed"
});
formatter.match({
  "location": "testusercontrollableinputsforinjection.trytestusercontrollableinputsforinjection()"
});
formatter.result({
  "status": "skipped"
});
formatter.match({
  "location": "testusercontrollableinputsforinjection.asstestusercontrollableinputsforinjection()"
});
formatter.result({
  "status": "skipped"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({
  "location": "PatternSteps.assauditinterceptor()"
});
formatter.result({
  "status": "skipped"
});
formatter.match({
  "location": "PatternSteps.asssecurelogger()"
});
formatter.result({
  "status": "skipped"
});
formatter.uri("CAPEC_258_Step_1_1.feature");
formatter.feature({
  "line": 2,
  "name": "CAPEC-258: Passively Sniffing and Capturing Application Code Bound for an Authorized Client During Dynamic Update",
  "description": "",
  "id": "capec-258:-passively-sniffing-and-capturing-application-code-bound-for-an-authorized-client-during-dynamic-update",
  "keyword": "Feature",
  "tags": [
    {
      "line": 1,
      "name": "@capec258"
    }
  ]
});
formatter.scenario({
  "comments": [
    {
      "line": 3,
      "value": "#1. Explore"
    }
  ],
  "line": 4,
  "name": "Step1.1",
  "description": "",
  "id": "capec-258:-passively-sniffing-and-capturing-application-code-bound-for-an-authorized-client-during-dynamic-update;step1.1",
  "type": "scenario",
  "keyword": "Scenario"
});
formatter.step({
  "line": 5,
  "name": "prepare to",
  "keyword": "Given "
});
formatter.step({
  "line": 6,
  "name": "Try to",
  "keyword": "When "
});
formatter.step({
  "comments": [
    {
      "line": 7,
      "value": "# assertion for attack step success"
    }
  ],
  "line": 8,
  "name": "Assert the success of",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 9,
      "value": "#assertions for security pattern testing (checker whether the pattern consequences are observed)"
    }
  ],
  "line": 10,
  "name": "assert the consequences of the pattern",
  "keyword": "Then "
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.uri("CAPEC_258_Step_2_1.feature");
formatter.feature({
  "line": 2,
  "name": "CAPEC-258: Passively Sniffing and Capturing Application Code Bound for an Authorized Client During Dynamic Update",
  "description": "",
  "id": "capec-258:-passively-sniffing-and-capturing-application-code-bound-for-an-authorized-client-during-dynamic-update",
  "keyword": "Feature",
  "tags": [
    {
      "line": 1,
      "name": "@capec258"
    }
  ]
});
formatter.scenario({
  "comments": [
    {
      "line": 3,
      "value": "#2. Exploit"
    }
  ],
  "line": 4,
  "name": "Step2.1",
  "description": "",
  "id": "capec-258:-passively-sniffing-and-capturing-application-code-bound-for-an-authorized-client-during-dynamic-update;step2.1",
  "type": "scenario",
  "keyword": "Scenario"
});
formatter.step({
  "line": 5,
  "name": "prepare to",
  "keyword": "Given "
});
formatter.step({
  "line": 6,
  "name": "Try to",
  "keyword": "When "
});
formatter.step({
  "comments": [
    {
      "line": 7,
      "value": "# assertion for attack step success"
    }
  ],
  "line": 8,
  "name": "Assert the success of",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 9,
      "value": "#assertions for security pattern testing (checker whether the pattern consequences are observed)"
    }
  ],
  "line": 10,
  "name": "assert the consequences of the pattern",
  "keyword": "Then "
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.uri("CAPEC_259_Step_1_1.feature");
formatter.feature({
  "line": 2,
  "name": "CAPEC-259: Passively Sniffing and Capturing Application Code Bound for an Authorized Client During Patching",
  "description": "",
  "id": "capec-259:-passively-sniffing-and-capturing-application-code-bound-for-an-authorized-client-during-patching",
  "keyword": "Feature",
  "tags": [
    {
      "line": 1,
      "name": "@capec259"
    }
  ]
});
formatter.scenario({
  "comments": [
    {
      "line": 3,
      "value": "#1. Explore"
    }
  ],
  "line": 4,
  "name": "Step1.1 Set up a sniffer",
  "description": "",
  "id": "capec-259:-passively-sniffing-and-capturing-application-code-bound-for-an-authorized-client-during-patching;step1.1-set-up-a-sniffer",
  "type": "scenario",
  "keyword": "Scenario"
});
formatter.step({
  "line": 5,
  "name": "prepare to Set up a sniffer",
  "keyword": "Given "
});
formatter.step({
  "line": 6,
  "name": "Try to Set up a sniffer",
  "keyword": "When "
});
formatter.step({
  "comments": [
    {
      "line": 7,
      "value": "# assertion for attack step success"
    }
  ],
  "line": 8,
  "name": "Assert the success of Set up a sniffer",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 9,
      "value": "#assertions for security pattern testing (checker whether the pattern consequences are observed)"
    }
  ],
  "line": 10,
  "name": "assert the consequences of the pattern",
  "keyword": "Then "
});
formatter.match({
  "location": "setupasniffer.presetupasniffer()"
});
formatter.result({
  "duration": 67447,
  "status": "passed"
});
formatter.match({
  "location": "setupasniffer.trysetupasniffer()"
});
formatter.result({
  "duration": 6983,
  "status": "passed"
});
formatter.match({
  "location": "setupasniffer.asssetupasniffer()"
});
formatter.result({
  "duration": 7939,
  "status": "passed"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.uri("CAPEC_259_Step_2_1.feature");
formatter.feature({
  "line": 2,
  "name": "CAPEC-259: Passively Sniffing and Capturing Application Code Bound for an Authorized Client During Patching",
  "description": "",
  "id": "capec-259:-passively-sniffing-and-capturing-application-code-bound-for-an-authorized-client-during-patching",
  "keyword": "Feature",
  "tags": [
    {
      "line": 1,
      "name": "@capec259"
    }
  ]
});
formatter.scenario({
  "comments": [
    {
      "line": 3,
      "value": "#2. Exploit"
    }
  ],
  "line": 4,
  "name": "Step2.1 Capturing Application Code Bound During Patching",
  "description": "",
  "id": "capec-259:-passively-sniffing-and-capturing-application-code-bound-for-an-authorized-client-during-patching;step2.1-capturing-application-code-bound-during-patching",
  "type": "scenario",
  "keyword": "Scenario"
});
formatter.step({
  "line": 5,
  "name": "prepare to Capturing Application Code Bound During Patching",
  "keyword": "Given "
});
formatter.step({
  "line": 6,
  "name": "Try to Capturing Application Code Bound During Patching",
  "keyword": "When "
});
formatter.step({
  "comments": [
    {
      "line": 7,
      "value": "# assertion for attack step success"
    }
  ],
  "line": 8,
  "name": "Assert the success of Capturing Application Code Bound During Patching",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 9,
      "value": "#assertions for security pattern testing (checker whether the pattern consequences are observed)"
    }
  ],
  "line": 10,
  "name": "assert the consequences of the pattern",
  "keyword": "Then "
});
formatter.match({
  "location": "capturingapplicationcodeboundduringpatching.precapturingapplicationcodeboundduringpatching()"
});
formatter.result({
  "duration": 55917,
  "status": "passed"
});
formatter.match({
  "location": "capturingapplicationcodeboundduringpatching.trycapturingapplicationcodeboundduringpatching()"
});
formatter.result({
  "duration": 6492,
  "status": "passed"
});
formatter.match({
  "location": "capturingapplicationcodeboundduringpatching.asscapturingapplicationcodeboundduringpatching()"
});
formatter.result({
  "duration": 6896,
  "status": "passed"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.uri("CAPEC_25_Step_1_1.feature");
formatter.feature({
  "line": 2,
  "name": "CAPEC-25: Forced Deadlock",
  "description": "",
  "id": "capec-25:-forced-deadlock",
  "keyword": "Feature",
  "tags": [
    {
      "line": 1,
      "name": "@capec25"
    }
  ]
});
formatter.scenario({
  "comments": [
    {
      "line": 3,
      "value": "#1. Explore"
    }
  ],
  "line": 4,
  "name": "Step1.1",
  "description": "",
  "id": "capec-25:-forced-deadlock;step1.1",
  "type": "scenario",
  "keyword": "Scenario"
});
formatter.step({
  "line": 5,
  "name": "prepare to",
  "keyword": "Given "
});
formatter.step({
  "line": 6,
  "name": "Try to",
  "keyword": "When "
});
formatter.step({
  "comments": [
    {
      "line": 7,
      "value": "# assertion for attack step success"
    }
  ],
  "line": 8,
  "name": "Assert the success of",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 9,
      "value": "#assertions for security pattern testing (checker whether the pattern consequences are observed)"
    }
  ],
  "line": 10,
  "name": "assert the consequences of the pattern",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 11,
      "value": "#"
    }
  ],
  "line": 12,
  "name": "assert the consequences of the pattern audit interceptor",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 13,
      "value": "# depends secure logger"
    }
  ],
  "line": 14,
  "name": "assert the consequences of the pattern secure logger",
  "keyword": "Then "
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({
  "location": "PatternSteps.assauditinterceptor()"
});
formatter.result({
  "status": "skipped"
});
formatter.match({
  "location": "PatternSteps.asssecurelogger()"
});
formatter.result({
  "status": "skipped"
});
formatter.uri("CAPEC_260_Step_1_1.feature");
formatter.feature({
  "line": 2,
  "name": "CAPEC-260: Passively Sniffing and Capturing Application Code Bound for an Authorized Client During Initial Distribution",
  "description": "",
  "id": "capec-260:-passively-sniffing-and-capturing-application-code-bound-for-an-authorized-client-during-initial-distribution",
  "keyword": "Feature",
  "tags": [
    {
      "line": 1,
      "name": "@capec260"
    }
  ]
});
formatter.scenario({
  "comments": [
    {
      "line": 3,
      "value": "#1. Explore"
    }
  ],
  "line": 4,
  "name": "Step1.1 Set up a sniffer",
  "description": "",
  "id": "capec-260:-passively-sniffing-and-capturing-application-code-bound-for-an-authorized-client-during-initial-distribution;step1.1-set-up-a-sniffer",
  "type": "scenario",
  "keyword": "Scenario"
});
formatter.step({
  "line": 5,
  "name": "prepare to Set up a sniffer",
  "keyword": "Given "
});
formatter.step({
  "line": 6,
  "name": "Try to Set up a sniffer",
  "keyword": "When "
});
formatter.step({
  "comments": [
    {
      "line": 7,
      "value": "# assertion for attack step success"
    }
  ],
  "line": 8,
  "name": "Assert the success of Set up a sniffer",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 9,
      "value": "#assertions for security pattern testing (checker whether the pattern consequences are observed)"
    }
  ],
  "line": 10,
  "name": "assert the consequences of the pattern",
  "keyword": "Then "
});
formatter.match({
  "location": "setupasniffer.presetupasniffer()"
});
formatter.result({
  "duration": 27959,
  "status": "passed"
});
formatter.match({
  "location": "setupasniffer.trysetupasniffer()"
});
formatter.result({
  "duration": 4739,
  "status": "passed"
});
formatter.match({
  "location": "setupasniffer.asssetupasniffer()"
});
formatter.result({
  "duration": 4200,
  "status": "passed"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.uri("CAPEC_260_Step_2_1.feature");
formatter.feature({
  "line": 2,
  "name": "CAPEC-260: Passively Sniffing and Capturing Application Code Bound for an Authorized Client During Initial Distribution",
  "description": "",
  "id": "capec-260:-passively-sniffing-and-capturing-application-code-bound-for-an-authorized-client-during-initial-distribution",
  "keyword": "Feature",
  "tags": [
    {
      "line": 1,
      "name": "@capec260"
    }
  ]
});
formatter.scenario({
  "comments": [
    {
      "line": 3,
      "value": "#2. Exploit"
    }
  ],
  "line": 4,
  "name": "Step2.1 Capturing Application Code Bound During Patching",
  "description": "",
  "id": "capec-260:-passively-sniffing-and-capturing-application-code-bound-for-an-authorized-client-during-initial-distribution;step2.1-capturing-application-code-bound-during-patching",
  "type": "scenario",
  "keyword": "Scenario"
});
formatter.step({
  "line": 5,
  "name": "prepare to Capturing Application Code Bound During Patching",
  "keyword": "Given "
});
formatter.step({
  "line": 6,
  "name": "Try to Capturing Application Code Bound During Patching",
  "keyword": "When "
});
formatter.step({
  "comments": [
    {
      "line": 7,
      "value": "# assertion for attack step success"
    }
  ],
  "line": 8,
  "name": "Assert the success of Capturing Application Code Bound During Patching",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 9,
      "value": "#assertions for security pattern testing (checker whether the pattern consequences are observed)"
    }
  ],
  "line": 10,
  "name": "assert the consequences of the pattern",
  "keyword": "Then "
});
formatter.match({
  "location": "capturingapplicationcodeboundduringpatching.precapturingapplicationcodeboundduringpatching()"
});
formatter.result({
  "duration": 39191,
  "status": "passed"
});
formatter.match({
  "location": "capturingapplicationcodeboundduringpatching.trycapturingapplicationcodeboundduringpatching()"
});
formatter.result({
  "duration": 4092,
  "status": "passed"
});
formatter.match({
  "location": "capturingapplicationcodeboundduringpatching.asscapturingapplicationcodeboundduringpatching()"
});
formatter.result({
  "duration": 4487,
  "status": "passed"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.uri("CAPEC_267_Step_1_1.feature");
formatter.feature({
  "line": 2,
  "name": "CAPEC-267: Leverage Alternate Encoding",
  "description": "",
  "id": "capec-267:-leverage-alternate-encoding",
  "keyword": "Feature",
  "tags": [
    {
      "line": 1,
      "name": "@capec267"
    }
  ]
});
formatter.scenario({
  "comments": [
    {
      "line": 3,
      "value": "#1. Explore"
    }
  ],
  "line": 4,
  "name": "Step1.1 Survey the application for user-controllable inputs",
  "description": "",
  "id": "capec-267:-leverage-alternate-encoding;step1.1-survey-the-application-for-user-controllable-inputs",
  "type": "scenario",
  "keyword": "Scenario"
});
formatter.step({
  "line": 5,
  "name": "prepare to Survey the application for user-controllable inputs",
  "keyword": "Given "
});
formatter.step({
  "line": 6,
  "name": "Try to Survey the application for user-controllable inputs",
  "keyword": "When "
});
formatter.step({
  "comments": [
    {
      "line": 7,
      "value": "# assertion for attack step success"
    }
  ],
  "line": 8,
  "name": "Assert the success of Survey the application for user-controllable inputs",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 9,
      "value": "#assertions for security pattern testing (checker whether the pattern consequences are observed)"
    }
  ],
  "line": 10,
  "name": "assert the consequences of the pattern",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 11,
      "value": "#"
    }
  ],
  "line": 12,
  "name": "assert the consequences of the pattern audit interceptor",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 13,
      "value": "# depends secure logger"
    }
  ],
  "line": 14,
  "name": "assert the consequences of the pattern secure logger",
  "keyword": "Then "
});
formatter.match({
  "location": "survey.presurvey()"
});
formatter.result({
  "duration": 0,
  "error_message": "cucumber.runtime.AmbiguousStepDefinitionsException: ✽.Given prepare to Survey the application for user-controllable inputs(CAPEC_267_Step_1_1.feature:5) matches more than one step definition:\n  prepare to Survey in survey.presurvey()\n  prepare to Survey the application in surveytheapplication.presurveytheapplication()\n  prepare to Survey the application for user-controllable inputs in surveytheapplicationforusercontrollableinputs.presurveytheapplicationforusercontrollableinputs()\n\n\tat cucumber.runtime.RuntimeGlue.stepDefinitionMatch(RuntimeGlue.java:71)\n\tat cucumber.runtime.Runtime.runStep(Runtime.java:265)\n\tat cucumber.runtime.model.StepContainer.runStep(StepContainer.java:44)\n\tat cucumber.runtime.model.StepContainer.runSteps(StepContainer.java:39)\n\tat cucumber.runtime.model.CucumberScenario.run(CucumberScenario.java:48)\n\tat cucumber.runtime.junit.ExecutionUnitRunner.run(ExecutionUnitRunner.java:91)\n\tat cucumber.runtime.junit.FeatureRunner.runChild(FeatureRunner.java:63)\n\tat cucumber.runtime.junit.FeatureRunner.runChild(FeatureRunner.java:18)\n\tat org.junit.runners.ParentRunner$3.run(ParentRunner.java:238)\n\tat org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:63)\n\tat org.junit.runners.ParentRunner.runChildren(ParentRunner.java:236)\n\tat org.junit.runners.ParentRunner.access$000(ParentRunner.java:53)\n\tat org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:229)\n\tat org.junit.runners.ParentRunner.run(ParentRunner.java:309)\n\tat cucumber.runtime.junit.FeatureRunner.run(FeatureRunner.java:70)\n\tat cucumber.api.junit.Cucumber.runChild(Cucumber.java:93)\n\tat cucumber.api.junit.Cucumber.runChild(Cucumber.java:37)\n\tat org.junit.runners.ParentRunner$3.run(ParentRunner.java:238)\n\tat org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:63)\n\tat org.junit.runners.ParentRunner.runChildren(ParentRunner.java:236)\n\tat org.junit.runners.ParentRunner.access$000(ParentRunner.java:53)\n\tat org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:229)\n\tat org.junit.internal.runners.statements.RunAfters.evaluate(RunAfters.java:27)\n\tat org.junit.runners.ParentRunner.run(ParentRunner.java:309)\n\tat cucumber.api.junit.Cucumber.run(Cucumber.java:98)\n\tat org.eclipse.jdt.internal.junit4.runner.JUnit4TestReference.run(JUnit4TestReference.java:86)\n\tat org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:459)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:678)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:382)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:192)\n",
  "status": "failed"
});
formatter.match({
  "location": "survey.trysurvey()"
});
formatter.result({
  "duration": 0,
  "error_message": "cucumber.runtime.AmbiguousStepDefinitionsException: ✽.When Try to Survey the application for user-controllable inputs(CAPEC_267_Step_1_1.feature:6) matches more than one step definition:\n  Try to Survey in survey.trysurvey()\n  Try to Survey the application in surveytheapplication.trysurveytheapplication()\n  Try to Survey the application for user-controllable inputs in surveytheapplicationforusercontrollableinputs.trysurveytheapplicationforusercontrollableinputs()\n\n\tat cucumber.runtime.RuntimeGlue.stepDefinitionMatch(RuntimeGlue.java:71)\n\tat cucumber.runtime.Runtime.runStep(Runtime.java:265)\n\tat cucumber.runtime.model.StepContainer.runStep(StepContainer.java:44)\n\tat cucumber.runtime.model.StepContainer.runSteps(StepContainer.java:39)\n\tat cucumber.runtime.model.CucumberScenario.run(CucumberScenario.java:48)\n\tat cucumber.runtime.junit.ExecutionUnitRunner.run(ExecutionUnitRunner.java:91)\n\tat cucumber.runtime.junit.FeatureRunner.runChild(FeatureRunner.java:63)\n\tat cucumber.runtime.junit.FeatureRunner.runChild(FeatureRunner.java:18)\n\tat org.junit.runners.ParentRunner$3.run(ParentRunner.java:238)\n\tat org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:63)\n\tat org.junit.runners.ParentRunner.runChildren(ParentRunner.java:236)\n\tat org.junit.runners.ParentRunner.access$000(ParentRunner.java:53)\n\tat org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:229)\n\tat org.junit.runners.ParentRunner.run(ParentRunner.java:309)\n\tat cucumber.runtime.junit.FeatureRunner.run(FeatureRunner.java:70)\n\tat cucumber.api.junit.Cucumber.runChild(Cucumber.java:93)\n\tat cucumber.api.junit.Cucumber.runChild(Cucumber.java:37)\n\tat org.junit.runners.ParentRunner$3.run(ParentRunner.java:238)\n\tat org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:63)\n\tat org.junit.runners.ParentRunner.runChildren(ParentRunner.java:236)\n\tat org.junit.runners.ParentRunner.access$000(ParentRunner.java:53)\n\tat org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:229)\n\tat org.junit.internal.runners.statements.RunAfters.evaluate(RunAfters.java:27)\n\tat org.junit.runners.ParentRunner.run(ParentRunner.java:309)\n\tat cucumber.api.junit.Cucumber.run(Cucumber.java:98)\n\tat org.eclipse.jdt.internal.junit4.runner.JUnit4TestReference.run(JUnit4TestReference.java:86)\n\tat org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:459)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:678)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:382)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:192)\n",
  "status": "failed"
});
formatter.match({
  "location": "survey.asssurvey()"
});
formatter.result({
  "duration": 0,
  "error_message": "cucumber.runtime.AmbiguousStepDefinitionsException: ✽.Then Assert the success of Survey the application for user-controllable inputs(CAPEC_267_Step_1_1.feature:8) matches more than one step definition:\n  Assert the success of Survey in survey.asssurvey()\n  Assert the success of Survey the application in surveytheapplication.asssurveytheapplication()\n  Assert the success of Survey the application for user-controllable inputs in surveytheapplicationforusercontrollableinputs.asssurveytheapplicationforusercontrollableinputs()\n\n\tat cucumber.runtime.RuntimeGlue.stepDefinitionMatch(RuntimeGlue.java:71)\n\tat cucumber.runtime.Runtime.runStep(Runtime.java:265)\n\tat cucumber.runtime.model.StepContainer.runStep(StepContainer.java:44)\n\tat cucumber.runtime.model.StepContainer.runSteps(StepContainer.java:39)\n\tat cucumber.runtime.model.CucumberScenario.run(CucumberScenario.java:48)\n\tat cucumber.runtime.junit.ExecutionUnitRunner.run(ExecutionUnitRunner.java:91)\n\tat cucumber.runtime.junit.FeatureRunner.runChild(FeatureRunner.java:63)\n\tat cucumber.runtime.junit.FeatureRunner.runChild(FeatureRunner.java:18)\n\tat org.junit.runners.ParentRunner$3.run(ParentRunner.java:238)\n\tat org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:63)\n\tat org.junit.runners.ParentRunner.runChildren(ParentRunner.java:236)\n\tat org.junit.runners.ParentRunner.access$000(ParentRunner.java:53)\n\tat org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:229)\n\tat org.junit.runners.ParentRunner.run(ParentRunner.java:309)\n\tat cucumber.runtime.junit.FeatureRunner.run(FeatureRunner.java:70)\n\tat cucumber.api.junit.Cucumber.runChild(Cucumber.java:93)\n\tat cucumber.api.junit.Cucumber.runChild(Cucumber.java:37)\n\tat org.junit.runners.ParentRunner$3.run(ParentRunner.java:238)\n\tat org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:63)\n\tat org.junit.runners.ParentRunner.runChildren(ParentRunner.java:236)\n\tat org.junit.runners.ParentRunner.access$000(ParentRunner.java:53)\n\tat org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:229)\n\tat org.junit.internal.runners.statements.RunAfters.evaluate(RunAfters.java:27)\n\tat org.junit.runners.ParentRunner.run(ParentRunner.java:309)\n\tat cucumber.api.junit.Cucumber.run(Cucumber.java:98)\n\tat org.eclipse.jdt.internal.junit4.runner.JUnit4TestReference.run(JUnit4TestReference.java:86)\n\tat org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:459)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:678)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:382)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:192)\n",
  "status": "failed"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({
  "location": "PatternSteps.assauditinterceptor()"
});
formatter.result({
  "status": "skipped"
});
formatter.match({
  "location": "PatternSteps.asssecurelogger()"
});
formatter.result({
  "status": "skipped"
});
formatter.uri("CAPEC_267_Step_2_1.feature");
formatter.feature({
  "line": 2,
  "name": "CAPEC-267: Leverage Alternate Encoding",
  "description": "",
  "id": "capec-267:-leverage-alternate-encoding",
  "keyword": "Feature",
  "tags": [
    {
      "line": 1,
      "name": "@capec267"
    }
  ]
});
formatter.scenario({
  "comments": [
    {
      "line": 3,
      "value": "#2. Experiment"
    }
  ],
  "line": 4,
  "name": "Step2.1 Probe entry points to locate vulnerabilities",
  "description": "",
  "id": "capec-267:-leverage-alternate-encoding;step2.1-probe-entry-points-to-locate-vulnerabilities",
  "type": "scenario",
  "keyword": "Scenario"
});
formatter.step({
  "line": 5,
  "name": "prepare to Probe entry points to locate vulnerabilities",
  "keyword": "Given "
});
formatter.step({
  "line": 6,
  "name": "Try to Probe entry points to locate vulnerabilities",
  "keyword": "When "
});
formatter.step({
  "comments": [
    {
      "line": 7,
      "value": "# assertion for attack step success"
    }
  ],
  "line": 8,
  "name": "Assert the success of Probe entry points to locate vulnerabilities",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 9,
      "value": "#assertions for security pattern testing (checker whether the pattern consequences are observed)"
    }
  ],
  "line": 10,
  "name": "assert the consequences of the pattern",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 11,
      "value": "#"
    }
  ],
  "line": 12,
  "name": "assert the consequences of the pattern application firewall",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 13,
      "value": "# alternative input guard"
    }
  ],
  "line": 14,
  "name": "assert the consequences of the pattern input guard",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 15,
      "value": "# alternative application firewall"
    }
  ],
  "line": 16,
  "name": "assert the consequences of the pattern pathname canonicalization",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 17,
      "value": "#"
    }
  ],
  "line": 18,
  "name": "assert the consequences of the pattern audit interceptor",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 19,
      "value": "# depends secure logger"
    }
  ],
  "line": 20,
  "name": "assert the consequences of the pattern secure logger",
  "keyword": "Then "
});
formatter.match({
  "location": "probeentrypointstolocatevulnerabilities.preprobeentrypointstolocatevulnerabilities()"
});
formatter.result({
  "duration": 77019,
  "status": "passed"
});
formatter.match({
  "location": "probeentrypointstolocatevulnerabilities.tryprobeentrypointstolocatevulnerabilities()"
});
formatter.result({
  "duration": 6265,
  "status": "passed"
});
formatter.match({
  "location": "probeentrypointstolocatevulnerabilities.assprobeentrypointstolocatevulnerabilities()"
});
formatter.result({
  "duration": 4752,
  "status": "passed"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({
  "location": "PatternSteps.assapplicationfirewall()"
});
formatter.result({
  "status": "skipped"
});
formatter.match({
  "location": "PatternSteps.assinputguard()"
});
formatter.result({
  "status": "skipped"
});
formatter.match({
  "location": "PatternSteps.asspathnamecanonicalization()"
});
formatter.result({
  "status": "skipped"
});
formatter.match({
  "location": "PatternSteps.assauditinterceptor()"
});
formatter.result({
  "status": "skipped"
});
formatter.match({
  "location": "PatternSteps.asssecurelogger()"
});
formatter.result({
  "status": "skipped"
});
formatter.uri("CAPEC_26_Step_1_1.feature");
formatter.feature({
  "line": 2,
  "name": "CAPEC-26: Leveraging Race Conditions",
  "description": "",
  "id": "capec-26:-leveraging-race-conditions",
  "keyword": "Feature",
  "tags": [
    {
      "line": 1,
      "name": "@capec26"
    }
  ]
});
formatter.scenario({
  "comments": [
    {
      "line": 3,
      "value": "#1. Explore"
    }
  ],
  "line": 4,
  "name": "Step1.1",
  "description": "",
  "id": "capec-26:-leveraging-race-conditions;step1.1",
  "type": "scenario",
  "keyword": "Scenario"
});
formatter.step({
  "line": 5,
  "name": "prepare to",
  "keyword": "Given "
});
formatter.step({
  "line": 6,
  "name": "Try to",
  "keyword": "When "
});
formatter.step({
  "comments": [
    {
      "line": 7,
      "value": "# assertion for attack step success"
    }
  ],
  "line": 8,
  "name": "Assert the success of",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 9,
      "value": "#assertions for security pattern testing (checker whether the pattern consequences are observed)"
    }
  ],
  "line": 10,
  "name": "assert the consequences of the pattern",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 11,
      "value": "#"
    }
  ],
  "line": 12,
  "name": "assert the consequences of the pattern audit interceptor",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 13,
      "value": "# depends secure logger"
    }
  ],
  "line": 14,
  "name": "assert the consequences of the pattern secure logger",
  "keyword": "Then "
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({
  "location": "PatternSteps.assauditinterceptor()"
});
formatter.result({
  "status": "skipped"
});
formatter.match({
  "location": "PatternSteps.asssecurelogger()"
});
formatter.result({
  "status": "skipped"
});
formatter.uri("CAPEC_26_Step_2_1.feature");
formatter.feature({
  "line": 2,
  "name": "CAPEC-26: Leveraging Race Conditions",
  "description": "",
  "id": "capec-26:-leveraging-race-conditions",
  "keyword": "Feature",
  "tags": [
    {
      "line": 1,
      "name": "@capec26"
    }
  ]
});
formatter.scenario({
  "comments": [
    {
      "line": 3,
      "value": "#2. Experiment"
    }
  ],
  "line": 4,
  "name": "Step2.1",
  "description": "",
  "id": "capec-26:-leveraging-race-conditions;step2.1",
  "type": "scenario",
  "keyword": "Scenario"
});
formatter.step({
  "line": 5,
  "name": "prepare to",
  "keyword": "Given "
});
formatter.step({
  "line": 6,
  "name": "Try to",
  "keyword": "When "
});
formatter.step({
  "comments": [
    {
      "line": 7,
      "value": "# assertion for attack step success"
    }
  ],
  "line": 8,
  "name": "Assert the success of",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 9,
      "value": "#assertions for security pattern testing (checker whether the pattern consequences are observed)"
    }
  ],
  "line": 10,
  "name": "assert the consequences of the pattern",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 11,
      "value": "#"
    }
  ],
  "line": 12,
  "name": "assert the consequences of the pattern audit interceptor",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 13,
      "value": "# depends secure logger"
    }
  ],
  "line": 14,
  "name": "assert the consequences of the pattern secure logger",
  "keyword": "Then "
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({
  "location": "PatternSteps.assauditinterceptor()"
});
formatter.result({
  "status": "skipped"
});
formatter.match({
  "location": "PatternSteps.asssecurelogger()"
});
formatter.result({
  "status": "skipped"
});
formatter.uri("CAPEC_26_Step_3_1.feature");
formatter.feature({
  "line": 2,
  "name": "CAPEC-26: Leveraging Race Conditions",
  "description": "",
  "id": "capec-26:-leveraging-race-conditions",
  "keyword": "Feature",
  "tags": [
    {
      "line": 1,
      "name": "@capec26"
    }
  ]
});
formatter.scenario({
  "comments": [
    {
      "line": 3,
      "value": "#3. Exploit"
    }
  ],
  "line": 4,
  "name": "Step3.1",
  "description": "",
  "id": "capec-26:-leveraging-race-conditions;step3.1",
  "type": "scenario",
  "keyword": "Scenario"
});
formatter.step({
  "line": 5,
  "name": "prepare to",
  "keyword": "Given "
});
formatter.step({
  "line": 6,
  "name": "Try to",
  "keyword": "When "
});
formatter.step({
  "comments": [
    {
      "line": 7,
      "value": "# assertion for attack step success"
    }
  ],
  "line": 8,
  "name": "Assert the success of",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 9,
      "value": "#assertions for security pattern testing (checker whether the pattern consequences are observed)"
    }
  ],
  "line": 10,
  "name": "assert the consequences of the pattern",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 11,
      "value": "#"
    }
  ],
  "line": 12,
  "name": "assert the consequences of the pattern audit interceptor",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 13,
      "value": "# depends secure logger"
    }
  ],
  "line": 14,
  "name": "assert the consequences of the pattern secure logger",
  "keyword": "Then "
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({
  "location": "PatternSteps.assauditinterceptor()"
});
formatter.result({
  "status": "skipped"
});
formatter.match({
  "location": "PatternSteps.asssecurelogger()"
});
formatter.result({
  "status": "skipped"
});
formatter.uri("CAPEC_275_Step_1_1.feature");
formatter.feature({
  "line": 2,
  "name": "CAPEC-275: DNS Rebinding",
  "description": "",
  "id": "capec-275:-dns-rebinding",
  "keyword": "Feature",
  "tags": [
    {
      "line": 1,
      "name": "@capec275"
    }
  ]
});
formatter.scenario({
  "comments": [
    {
      "line": 3,
      "value": "#1. Explore"
    }
  ],
  "line": 4,
  "name": "Step1.1 Identify potential DNS rebinding targets",
  "description": "",
  "id": "capec-275:-dns-rebinding;step1.1-identify-potential-dns-rebinding-targets",
  "type": "scenario",
  "keyword": "Scenario"
});
formatter.step({
  "line": 5,
  "name": "prepare to Identify potential DNS rebinding targets",
  "keyword": "Given "
});
formatter.step({
  "line": 6,
  "name": "Try to Identify potential DNS rebinding targets",
  "keyword": "When "
});
formatter.step({
  "comments": [
    {
      "line": 7,
      "value": "# assertion for attack step success"
    }
  ],
  "line": 8,
  "name": "Assert the success of Identify potential DNS rebinding targets",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 9,
      "value": "#assertions for security pattern testing (checker whether the pattern consequences are observed)"
    }
  ],
  "line": 10,
  "name": "assert the consequences of the pattern",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 11,
      "value": "#"
    }
  ],
  "line": 12,
  "name": "assert the consequences of the pattern audit interceptor",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 13,
      "value": "# depends secure logger"
    }
  ],
  "line": 14,
  "name": "assert the consequences of the pattern secure logger",
  "keyword": "Then "
});
formatter.match({
  "location": "identifypotentialdnsrebindingtargets.preidentifypotentialdnsrebindingtargets()"
});
formatter.result({
  "duration": 49649,
  "status": "passed"
});
formatter.match({
  "location": "identifypotentialdnsrebindingtargets.tryidentifypotentialdnsrebindingtargets()"
});
formatter.result({
  "duration": 12017,
  "status": "passed"
});
formatter.match({
  "location": "identifypotentialdnsrebindingtargets.assidentifypotentialdnsrebindingtargets()"
});
formatter.result({
  "duration": 4875,
  "status": "passed"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({
  "location": "PatternSteps.assauditinterceptor()"
});
formatter.result({
  "status": "skipped"
});
formatter.match({
  "location": "PatternSteps.asssecurelogger()"
});
formatter.result({
  "status": "skipped"
});
formatter.uri("CAPEC_275_Step_2_1.feature");
formatter.feature({
  "line": 2,
  "name": "CAPEC-275: DNS Rebinding",
  "description": "",
  "id": "capec-275:-dns-rebinding",
  "keyword": "Feature",
  "tags": [
    {
      "line": 1,
      "name": "@capec275"
    }
  ]
});
formatter.scenario({
  "comments": [
    {
      "line": 3,
      "value": "#2. Experiment"
    }
  ],
  "line": 4,
  "name": "Step2.1 Establish initial target access to attacker DNS",
  "description": "",
  "id": "capec-275:-dns-rebinding;step2.1-establish-initial-target-access-to-attacker-dns",
  "type": "scenario",
  "keyword": "Scenario"
});
formatter.step({
  "line": 5,
  "name": "prepare to Establish initial target access to attacker DNS",
  "keyword": "Given "
});
formatter.step({
  "line": 6,
  "name": "Try to Establish initial target access to attacker DNS",
  "keyword": "When "
});
formatter.step({
  "comments": [
    {
      "line": 7,
      "value": "# assertion for attack step success"
    }
  ],
  "line": 8,
  "name": "Assert the success of Establish initial target access to attacker DNS",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 9,
      "value": "#assertions for security pattern testing (checker whether the pattern consequences are observed)"
    }
  ],
  "line": 10,
  "name": "assert the consequences of the pattern",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 11,
      "value": "#"
    }
  ],
  "line": 12,
  "name": "assert the consequences of the pattern audit interceptor",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 13,
      "value": "# depends secure logger"
    }
  ],
  "line": 14,
  "name": "assert the consequences of the pattern secure logger",
  "keyword": "Then "
});
formatter.match({
  "location": "establishinitialtargetaccesstoattackerdns.preestablishinitialtargetaccesstoattackerdns()"
});
formatter.result({
  "duration": 47463,
  "status": "passed"
});
formatter.match({
  "location": "establishinitialtargetaccesstoattackerdns.tryestablishinitialtargetaccesstoattackerdns()"
});
formatter.result({
  "duration": 4772,
  "status": "passed"
});
formatter.match({
  "location": "establishinitialtargetaccesstoattackerdns.assestablishinitialtargetaccesstoattackerdns()"
});
formatter.result({
  "duration": 4706,
  "status": "passed"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({
  "location": "PatternSteps.assauditinterceptor()"
});
formatter.result({
  "status": "skipped"
});
formatter.match({
  "location": "PatternSteps.asssecurelogger()"
});
formatter.result({
  "status": "skipped"
});
formatter.uri("CAPEC_275_Step_2_2.feature");
formatter.feature({
  "line": 2,
  "name": "CAPEC-275: DNS Rebinding",
  "description": "",
  "id": "capec-275:-dns-rebinding",
  "keyword": "Feature",
  "tags": [
    {
      "line": 1,
      "name": "@capec275"
    }
  ]
});
formatter.scenario({
  "comments": [
    {
      "line": 3,
      "value": "#2. Experiment"
    }
  ],
  "line": 4,
  "name": "Step2.2 Rebind DNS resolution to target address",
  "description": "",
  "id": "capec-275:-dns-rebinding;step2.2-rebind-dns-resolution-to-target-address",
  "type": "scenario",
  "keyword": "Scenario"
});
formatter.step({
  "line": 5,
  "name": "prepare to Rebind DNS resolution to target address",
  "keyword": "Given "
});
formatter.step({
  "line": 6,
  "name": "Try to Rebind DNS resolution to target address",
  "keyword": "When "
});
formatter.step({
  "comments": [
    {
      "line": 7,
      "value": "# assertion for attack step success"
    }
  ],
  "line": 8,
  "name": "Assert the success of Rebind DNS resolution to target address",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 9,
      "value": "#assertions for security pattern testing (checker whether the pattern consequences are observed)"
    }
  ],
  "line": 10,
  "name": "assert the consequences of the pattern",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 11,
      "value": "#"
    }
  ],
  "line": 12,
  "name": "assert the consequences of the pattern audit interceptor",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 13,
      "value": "# depends secure logger"
    }
  ],
  "line": 14,
  "name": "assert the consequences of the pattern secure logger",
  "keyword": "Then "
});
formatter.match({
  "location": "rebinddnsresolutiontotargetaddress.prerebinddnsresolutiontotargetaddress()"
});
formatter.result({
  "duration": 83816,
  "status": "passed"
});
formatter.match({
  "location": "rebinddnsresolutiontotargetaddress.tryrebinddnsresolutiontotargetaddress()"
});
formatter.result({
  "duration": 6126,
  "status": "passed"
});
formatter.match({
  "location": "rebinddnsresolutiontotargetaddress.assrebinddnsresolutiontotargetaddress()"
});
formatter.result({
  "duration": 5912,
  "status": "passed"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({
  "location": "PatternSteps.assauditinterceptor()"
});
formatter.result({
  "status": "skipped"
});
formatter.match({
  "location": "PatternSteps.asssecurelogger()"
});
formatter.result({
  "status": "skipped"
});
formatter.uri("CAPEC_275_Step_2_3.feature");
formatter.feature({
  "line": 2,
  "name": "CAPEC-275: DNS Rebinding",
  "description": "",
  "id": "capec-275:-dns-rebinding",
  "keyword": "Feature",
  "tags": [
    {
      "line": 1,
      "name": "@capec275"
    }
  ]
});
formatter.scenario({
  "comments": [
    {
      "line": 3,
      "value": "#2. Experiment"
    }
  ],
  "line": 4,
  "name": "Step2.3 Determine exploitability of DNS rebinding access to target address",
  "description": "",
  "id": "capec-275:-dns-rebinding;step2.3-determine-exploitability-of-dns-rebinding-access-to-target-address",
  "type": "scenario",
  "keyword": "Scenario"
});
formatter.step({
  "line": 5,
  "name": "prepare to Determine exploitability of DNS rebinding access to target address",
  "keyword": "Given "
});
formatter.step({
  "line": 6,
  "name": "Try to Determine exploitability of DNS rebinding access to target address",
  "keyword": "When "
});
formatter.step({
  "comments": [
    {
      "line": 7,
      "value": "# assertion for attack step success"
    }
  ],
  "line": 8,
  "name": "Assert the success of Determine exploitability of DNS rebinding access to target address",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 9,
      "value": "#assertions for security pattern testing (checker whether the pattern consequences are observed)"
    }
  ],
  "line": 10,
  "name": "assert the consequences of the pattern secure logger",
  "keyword": "Then "
});
formatter.step({
  "line": 11,
  "name": "assert the consequences of the pattern",
  "keyword": "Then "
});
formatter.match({
  "location": "determineexploitabilityofdnsrebindingaccesstotargetaddress.predetermineexploitabilityofdnsrebindingaccesstotargetaddress()"
});
formatter.result({
  "duration": 85480,
  "status": "passed"
});
formatter.match({
  "location": "determineexploitabilityofdnsrebindingaccesstotargetaddress.trydetermineexploitabilityofdnsrebindingaccesstotargetaddress()"
});
formatter.result({
  "duration": 6414,
  "status": "passed"
});
formatter.match({
  "location": "determineexploitabilityofdnsrebindingaccesstotargetaddress.assdetermineexploitabilityofdnsrebindingaccesstotargetaddress()"
});
formatter.result({
  "duration": 6188,
  "status": "passed"
});
formatter.match({
  "location": "PatternSteps.asssecurelogger()"
});
formatter.result({
  "duration": 17573,
  "status": "passed"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.uri("CAPEC_275_Step_3_1.feature");
formatter.feature({
  "line": 2,
  "name": "CAPEC-275: DNS Rebinding",
  "description": "",
  "id": "capec-275:-dns-rebinding",
  "keyword": "Feature",
  "tags": [
    {
      "line": 1,
      "name": "@capec275"
    }
  ]
});
formatter.scenario({
  "comments": [
    {
      "line": 3,
      "value": "#3. Exploit"
    }
  ],
  "line": 4,
  "name": "Step3.1 Access \u0026 exfiltrate data within the victim\u0027s security zone",
  "description": "",
  "id": "capec-275:-dns-rebinding;step3.1-access-\u0026-exfiltrate-data-within-the-victim\u0027s-security-zone",
  "type": "scenario",
  "keyword": "Scenario"
});
formatter.step({
  "line": 5,
  "name": "prepare to Access \u0026 exfiltrate data within the victim\u0027s security zone",
  "keyword": "Given "
});
formatter.step({
  "line": 6,
  "name": "Try to Access \u0026 exfiltrate data within the victim\u0027s security zone",
  "keyword": "When "
});
formatter.step({
  "comments": [
    {
      "line": 7,
      "value": "# assertion for attack step success"
    }
  ],
  "line": 8,
  "name": "Assert the success of Access \u0026 exfiltrate data within the victim\u0027s security zone",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 9,
      "value": "#assertions for security pattern testing (checker whether the pattern consequences are observed)"
    }
  ],
  "line": 10,
  "name": "assert the consequences of the pattern output guard",
  "keyword": "Then "
});
formatter.step({
  "line": 11,
  "name": "assert the consequences of the pattern comparator checked fault tolerant system",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 12,
      "value": "# alternative output guard"
    }
  ],
  "line": 13,
  "name": "assert the consequences of the pattern",
  "keyword": "Then "
});
formatter.match({
  "location": "accessexfiltratedatawithinthevictimssecurityzone.preaccessexfiltratedatawithinthevictimssecurityzone()"
});
formatter.result({
  "duration": 105243,
  "status": "passed"
});
formatter.match({
  "location": "accessexfiltratedatawithinthevictimssecurityzone.tryaccessexfiltratedatawithinthevictimssecurityzone()"
});
formatter.result({
  "duration": 6705,
  "status": "passed"
});
formatter.match({
  "location": "accessexfiltratedatawithinthevictimssecurityzone.assaccessexfiltratedatawithinthevictimssecurityzone()"
});
formatter.result({
  "duration": 5887,
  "status": "passed"
});
formatter.match({
  "location": "PatternSteps.assoutputguard()"
});
formatter.result({
  "duration": 16183,
  "status": "passed"
});
formatter.match({
  "location": "PatternSteps.asscomparatorcheckedfaulttolerantsystem()"
});
formatter.result({
  "duration": 3795,
  "status": "passed"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.uri("CAPEC_27_Step_1_1.feature");
formatter.feature({
  "line": 2,
  "name": "CAPEC-27: Leveraging Race Conditions via Symbolic Links",
  "description": "",
  "id": "capec-27:-leveraging-race-conditions-via-symbolic-links",
  "keyword": "Feature",
  "tags": [
    {
      "line": 1,
      "name": "@capec27"
    }
  ]
});
formatter.scenario({
  "comments": [
    {
      "line": 3,
      "value": "#1. Explore"
    }
  ],
  "line": 4,
  "name": "Step1.1 Verify that target host\u0027s platform supports symbolic links.",
  "description": "",
  "id": "capec-27:-leveraging-race-conditions-via-symbolic-links;step1.1-verify-that-target-host\u0027s-platform-supports-symbolic-links.",
  "type": "scenario",
  "keyword": "Scenario"
});
formatter.step({
  "line": 5,
  "name": "prepare to Verify that target host\u0027s platform supports symbolic links.",
  "keyword": "Given "
});
formatter.step({
  "line": 6,
  "name": "Try to Verify that target host\u0027s platform supports symbolic links.",
  "keyword": "When "
});
formatter.step({
  "comments": [
    {
      "line": 7,
      "value": "# assertion for attack step success"
    }
  ],
  "line": 8,
  "name": "Assert the success of Verify that target host\u0027s platform supports symbolic links.",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 9,
      "value": "#assertions for security pattern testing (checker whether the pattern consequences are observed)"
    }
  ],
  "line": 10,
  "name": "assert the consequences of the pattern",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 11,
      "value": "#"
    }
  ],
  "line": 12,
  "name": "assert the consequences of the pattern audit interceptor",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 13,
      "value": "# depends secure logger"
    }
  ],
  "line": 14,
  "name": "assert the consequences of the pattern secure logger",
  "keyword": "Then "
});
formatter.match({
  "location": "verifythattargethostsplatformsupportssymboliclinks.preverifythattargethostsplatformsupportssymboliclinks()"
});
formatter.result({
  "duration": 56251,
  "status": "passed"
});
formatter.match({
  "location": "verifythattargethostsplatformsupportssymboliclinks.tryverifythattargethostsplatformsupportssymboliclinks()"
});
formatter.result({
  "duration": 4889,
  "status": "passed"
});
formatter.match({
  "location": "verifythattargethostsplatformsupportssymboliclinks.assverifythattargethostsplatformsupportssymboliclinks()"
});
formatter.result({
  "duration": 3945,
  "status": "passed"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({
  "location": "PatternSteps.assauditinterceptor()"
});
formatter.result({
  "status": "skipped"
});
formatter.match({
  "location": "PatternSteps.asssecurelogger()"
});
formatter.result({
  "status": "skipped"
});
formatter.uri("CAPEC_27_Step_1_2.feature");
formatter.feature({
  "line": 2,
  "name": "CAPEC-27: Leveraging Race Conditions via Symbolic Links",
  "description": "",
  "id": "capec-27:-leveraging-race-conditions-via-symbolic-links",
  "keyword": "Feature",
  "tags": [
    {
      "line": 1,
      "name": "@capec27"
    }
  ]
});
formatter.scenario({
  "comments": [
    {
      "line": 3,
      "value": "#1. Explore"
    }
  ],
  "line": 4,
  "name": "Step1.2 Examine application\u0027s file I/O behavior",
  "description": "",
  "id": "capec-27:-leveraging-race-conditions-via-symbolic-links;step1.2-examine-application\u0027s-file-i/o-behavior",
  "type": "scenario",
  "keyword": "Scenario"
});
formatter.step({
  "line": 5,
  "name": "prepare to Examine application\u0027s file I/O behavior",
  "keyword": "Given "
});
formatter.step({
  "line": 6,
  "name": "Try to Examine application\u0027s file I/O behavior",
  "keyword": "When "
});
formatter.step({
  "comments": [
    {
      "line": 7,
      "value": "# assertion for attack step success"
    }
  ],
  "line": 8,
  "name": "Assert the success of Examine application\u0027s file I/O behavior",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 9,
      "value": "#assertions for security pattern testing (checker whether the pattern consequences are observed)"
    }
  ],
  "line": 10,
  "name": "assert the consequences of the pattern",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 11,
      "value": "#"
    }
  ],
  "line": 12,
  "name": "assert the consequences of the pattern audit interceptor",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 13,
      "value": "# depends secure logger"
    }
  ],
  "line": 14,
  "name": "assert the consequences of the pattern secure logger",
  "keyword": "Then "
});
formatter.match({
  "location": "examineapplicationsfileiobehavior.preexamineapplicationsfileiobehavior()"
});
formatter.result({
  "duration": 55477,
  "status": "passed"
});
formatter.match({
  "location": "examineapplicationsfileiobehavior.tryexamineapplicationsfileiobehavior()"
});
formatter.result({
  "duration": 4466,
  "status": "passed"
});
formatter.match({
  "location": "examineapplicationsfileiobehavior.assexamineapplicationsfileiobehavior()"
});
formatter.result({
  "duration": 4264,
  "status": "passed"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({
  "location": "PatternSteps.assauditinterceptor()"
});
formatter.result({
  "status": "skipped"
});
formatter.match({
  "location": "PatternSteps.asssecurelogger()"
});
formatter.result({
  "status": "skipped"
});
formatter.uri("CAPEC_27_Step_2_1.feature");
formatter.feature({
  "line": 2,
  "name": "CAPEC-27: Leveraging Race Conditions via Symbolic Links",
  "description": "",
  "id": "capec-27:-leveraging-race-conditions-via-symbolic-links",
  "keyword": "Feature",
  "tags": [
    {
      "line": 1,
      "name": "@capec27"
    }
  ]
});
formatter.scenario({
  "comments": [
    {
      "line": 3,
      "value": "#2. Experiment"
    }
  ],
  "line": 4,
  "name": "Step2.1 Verify ability to write to filesystem",
  "description": "",
  "id": "capec-27:-leveraging-race-conditions-via-symbolic-links;step2.1-verify-ability-to-write-to-filesystem",
  "type": "scenario",
  "keyword": "Scenario"
});
formatter.step({
  "line": 5,
  "name": "prepare to Verify ability to write to filesystem",
  "keyword": "Given "
});
formatter.step({
  "line": 6,
  "name": "Try to Verify ability to write to filesystem",
  "keyword": "When "
});
formatter.step({
  "comments": [
    {
      "line": 7,
      "value": "# assertion for attack step success"
    }
  ],
  "line": 8,
  "name": "Assert the success of Verify ability to write to filesystem",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 9,
      "value": "#assertions for security pattern testing (checker whether the pattern consequences are observed)"
    }
  ],
  "line": 10,
  "name": "assert the consequences of the pattern secure logger",
  "keyword": "Then "
});
formatter.match({
  "location": "verifyabilitytowritetofilesystem.preverifyabilitytowritetofilesystem()"
});
formatter.result({
  "duration": 58933,
  "status": "passed"
});
formatter.match({
  "location": "verifyabilitytowritetofilesystem.tryverifyabilitytowritetofilesystem()"
});
formatter.result({
  "duration": 4297,
  "status": "passed"
});
formatter.match({
  "location": "verifyabilitytowritetofilesystem.assverifyabilitytowritetofilesystem()"
});
formatter.result({
  "duration": 4066,
  "status": "passed"
});
formatter.match({
  "location": "PatternSteps.asssecurelogger()"
});
formatter.result({
  "duration": 14265,
  "status": "passed"
});
formatter.uri("CAPEC_27_Step_3_1.feature");
formatter.feature({
  "line": 2,
  "name": "CAPEC-27: Leveraging Race Conditions via Symbolic Links",
  "description": "",
  "id": "capec-27:-leveraging-race-conditions-via-symbolic-links",
  "keyword": "Feature",
  "tags": [
    {
      "line": 1,
      "name": "@capec27"
    }
  ]
});
formatter.scenario({
  "comments": [
    {
      "line": 3,
      "value": "#3. Exploit"
    }
  ],
  "line": 4,
  "name": "Step3.1 Replace file with a symlink to a sensitive system file.",
  "description": "",
  "id": "capec-27:-leveraging-race-conditions-via-symbolic-links;step3.1-replace-file-with-a-symlink-to-a-sensitive-system-file.",
  "type": "scenario",
  "keyword": "Scenario"
});
formatter.step({
  "line": 5,
  "name": "prepare to Replace file with a symlink to a sensitive system file.",
  "keyword": "Given "
});
formatter.step({
  "line": 6,
  "name": "Try to Replace file with a symlink to a sensitive system file.",
  "keyword": "When "
});
formatter.step({
  "comments": [
    {
      "line": 7,
      "value": "# assertion for attack step success"
    }
  ],
  "line": 8,
  "name": "Assert the success of Replace file with a symlink to a sensitive system file.",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 9,
      "value": "#assertions for security pattern testing (checker whether the pattern consequences are observed)"
    }
  ],
  "line": 10,
  "name": "assert the consequences of the pattern secure logger",
  "keyword": "Then "
});
formatter.match({
  "location": "replacefilewithasymlinktoasensitivesystemfile.prereplacefilewithasymlinktoasensitivesystemfile()"
});
formatter.result({
  "duration": 43400,
  "status": "passed"
});
formatter.match({
  "location": "replacefilewithasymlinktoasensitivesystemfile.tryreplacefilewithasymlinktoasensitivesystemfile()"
});
formatter.result({
  "duration": 4728,
  "status": "passed"
});
formatter.match({
  "location": "replacefilewithasymlinktoasensitivesystemfile.assreplacefilewithasymlinktoasensitivesystemfile()"
});
formatter.result({
  "duration": 4043,
  "status": "passed"
});
formatter.match({
  "location": "PatternSteps.asssecurelogger()"
});
formatter.result({
  "duration": 15963,
  "status": "passed"
});
formatter.uri("CAPEC_28_Step_1_1.feature");
formatter.feature({
  "line": 2,
  "name": "CAPEC-28: Fuzzing",
  "description": "",
  "id": "capec-28:-fuzzing",
  "keyword": "Feature",
  "tags": [
    {
      "line": 1,
      "name": "@capec28"
    }
  ]
});
formatter.scenario({
  "comments": [
    {
      "line": 3,
      "value": "#1. Explore"
    }
  ],
  "line": 4,
  "name": "Step1.1 Observe communication and inputs",
  "description": "",
  "id": "capec-28:-fuzzing;step1.1-observe-communication-and-inputs",
  "type": "scenario",
  "keyword": "Scenario"
});
formatter.step({
  "line": 5,
  "name": "prepare to Observe communication and inputs",
  "keyword": "Given "
});
formatter.step({
  "line": 6,
  "name": "Try to Observe communication and inputs",
  "keyword": "When "
});
formatter.step({
  "comments": [
    {
      "line": 7,
      "value": "# assertion for attack step success"
    }
  ],
  "line": 8,
  "name": "Assert the success of Observe communication and inputs",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 9,
      "value": "#assertions for security pattern testing (checker whether the pattern consequences are observed)"
    }
  ],
  "line": 10,
  "name": "assert the consequences of the pattern",
  "keyword": "Then "
});
formatter.match({
  "location": "observecommunicationandinputs.preobservecommunicationandinputs()"
});
formatter.result({
  "duration": 47070,
  "status": "passed"
});
formatter.match({
  "location": "observecommunicationandinputs.tryobservecommunicationandinputs()"
});
formatter.result({
  "duration": 4600,
  "status": "passed"
});
formatter.match({
  "location": "observecommunicationandinputs.assobservecommunicationandinputs()"
});
formatter.result({
  "duration": 3889,
  "status": "passed"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.uri("CAPEC_28_Step_2_1.feature");
formatter.feature({
  "line": 2,
  "name": "CAPEC-28: Fuzzing",
  "description": "",
  "id": "capec-28:-fuzzing",
  "keyword": "Feature",
  "tags": [
    {
      "line": 1,
      "name": "@capec28"
    }
  ]
});
formatter.scenario({
  "comments": [
    {
      "line": 3,
      "value": "#2. Experiment"
    }
  ],
  "line": 4,
  "name": "Step2.1 Generate fuzzed inputs",
  "description": "",
  "id": "capec-28:-fuzzing;step2.1-generate-fuzzed-inputs",
  "type": "scenario",
  "keyword": "Scenario"
});
formatter.step({
  "line": 5,
  "name": "prepare to Generate fuzzed inputs",
  "keyword": "Given "
});
formatter.step({
  "line": 6,
  "name": "Try to Generate fuzzed inputs",
  "keyword": "When "
});
formatter.step({
  "comments": [
    {
      "line": 7,
      "value": "# assertion for attack step success"
    }
  ],
  "line": 8,
  "name": "Assert the success of Generate fuzzed inputs",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 9,
      "value": "#assertions for security pattern testing (checker whether the pattern consequences are observed)"
    }
  ],
  "line": 10,
  "name": "assert the consequences of the pattern secure logger",
  "keyword": "Then "
});
formatter.match({
  "location": "generatefuzzedinputs.pregeneratefuzzedinputs()"
});
formatter.result({
  "duration": 62984,
  "status": "passed"
});
formatter.match({
  "location": "generatefuzzedinputs.trygeneratefuzzedinputs()"
});
formatter.result({
  "duration": 4333,
  "status": "passed"
});
formatter.match({
  "location": "generatefuzzedinputs.assgeneratefuzzedinputs()"
});
formatter.result({
  "duration": 4302,
  "status": "passed"
});
formatter.match({
  "location": "PatternSteps.asssecurelogger()"
});
formatter.result({
  "duration": 18145,
  "status": "passed"
});
formatter.uri("CAPEC_28_Step_2_2.feature");
formatter.feature({
  "line": 2,
  "name": "CAPEC-28: Fuzzing",
  "description": "",
  "id": "capec-28:-fuzzing",
  "keyword": "Feature",
  "tags": [
    {
      "line": 1,
      "name": "@capec28"
    }
  ]
});
formatter.scenario({
  "comments": [
    {
      "line": 3,
      "value": "#2. Experiment"
    }
  ],
  "line": 4,
  "name": "Step2.2 Observe the outcome",
  "description": "",
  "id": "capec-28:-fuzzing;step2.2-observe-the-outcome",
  "type": "scenario",
  "keyword": "Scenario"
});
formatter.step({
  "line": 5,
  "name": "prepare to Observe the outcome",
  "keyword": "Given "
});
formatter.step({
  "line": 6,
  "name": "Try to Observe the outcome",
  "keyword": "When "
});
formatter.step({
  "comments": [
    {
      "line": 7,
      "value": "# assertion for attack step success"
    }
  ],
  "line": 8,
  "name": "Assert the success of Observe the outcome",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 9,
      "value": "#assertions for security pattern testing (checker whether the pattern consequences are observed)"
    }
  ],
  "line": 10,
  "name": "assert the consequences of the pattern",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 11,
      "value": "#"
    }
  ],
  "line": 12,
  "name": "assert the consequences of the pattern audit interceptor",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 13,
      "value": "# depends secure logger"
    }
  ],
  "line": 14,
  "name": "assert the consequences of the pattern secure logger",
  "keyword": "Then "
});
formatter.match({
  "location": "observetheoutcome.preobservetheoutcome()"
});
formatter.result({
  "duration": 53383,
  "status": "passed"
});
formatter.match({
  "location": "observetheoutcome.tryobservetheoutcome()"
});
formatter.result({
  "duration": 4461,
  "status": "passed"
});
formatter.match({
  "location": "observetheoutcome.assobservetheoutcome()"
});
formatter.result({
  "duration": 4634,
  "status": "passed"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({
  "location": "PatternSteps.assauditinterceptor()"
});
formatter.result({
  "status": "skipped"
});
formatter.match({
  "location": "PatternSteps.asssecurelogger()"
});
formatter.result({
  "status": "skipped"
});
formatter.uri("CAPEC_28_Step_3_1.feature");
formatter.feature({
  "line": 2,
  "name": "CAPEC-28: Fuzzing",
  "description": "",
  "id": "capec-28:-fuzzing",
  "keyword": "Feature",
  "tags": [
    {
      "line": 1,
      "name": "@capec28"
    }
  ]
});
formatter.scenario({
  "comments": [
    {
      "line": 3,
      "value": "#3. Exploit"
    }
  ],
  "line": 4,
  "name": "Step3.1 Craft exploit payloads",
  "description": "",
  "id": "capec-28:-fuzzing;step3.1-craft-exploit-payloads",
  "type": "scenario",
  "keyword": "Scenario"
});
formatter.step({
  "line": 5,
  "name": "prepare to Craft exploit payloads",
  "keyword": "Given "
});
formatter.step({
  "line": 6,
  "name": "Try to Craft exploit payloads",
  "keyword": "When "
});
formatter.step({
  "comments": [
    {
      "line": 7,
      "value": "# assertion for attack step success"
    }
  ],
  "line": 8,
  "name": "Assert the success of Craft exploit payloads",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 9,
      "value": "#assertions for security pattern testing (checker whether the pattern consequences are observed)"
    }
  ],
  "line": 10,
  "name": "assert the consequences of the pattern",
  "keyword": "Then "
});
formatter.match({
  "location": "craftexploitpayloads.precraftexploitpayloads()"
});
formatter.result({
  "duration": 74405,
  "status": "passed"
});
formatter.match({
  "location": "craftexploitpayloads.trycraftexploitpayloads()"
});
formatter.result({
  "duration": 5742,
  "status": "passed"
});
formatter.match({
  "location": "craftexploitpayloads.asscraftexploitpayloads()"
});
formatter.result({
  "duration": 3819,
  "status": "passed"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.uri("CAPEC_29_Step_1_1.feature");
formatter.feature({
  "line": 2,
  "name": "CAPEC-29: Leveraging Time-of-Check and Time-of-Use (TOCTOU) Race Conditions",
  "description": "",
  "id": "capec-29:-leveraging-time-of-check-and-time-of-use-(toctou)-race-conditions",
  "keyword": "Feature",
  "tags": [
    {
      "line": 1,
      "name": "@capec29"
    }
  ]
});
formatter.scenario({
  "comments": [
    {
      "line": 3,
      "value": "#1. Explore"
    }
  ],
  "line": 4,
  "name": "Step1.1",
  "description": "",
  "id": "capec-29:-leveraging-time-of-check-and-time-of-use-(toctou)-race-conditions;step1.1",
  "type": "scenario",
  "keyword": "Scenario"
});
formatter.step({
  "line": 5,
  "name": "prepare to",
  "keyword": "Given "
});
formatter.step({
  "line": 6,
  "name": "Try to",
  "keyword": "When "
});
formatter.step({
  "comments": [
    {
      "line": 7,
      "value": "# assertion for attack step success"
    }
  ],
  "line": 8,
  "name": "Assert the success of",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 9,
      "value": "#assertions for security pattern testing (checker whether the pattern consequences are observed)"
    }
  ],
  "line": 10,
  "name": "assert the consequences of the pattern",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 11,
      "value": "#"
    }
  ],
  "line": 12,
  "name": "assert the consequences of the pattern audit interceptor",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 13,
      "value": "# depends secure logger"
    }
  ],
  "line": 14,
  "name": "assert the consequences of the pattern secure logger",
  "keyword": "Then "
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({
  "location": "PatternSteps.assauditinterceptor()"
});
formatter.result({
  "status": "skipped"
});
formatter.match({
  "location": "PatternSteps.asssecurelogger()"
});
formatter.result({
  "status": "skipped"
});
formatter.uri("CAPEC_29_Step_2_1.feature");
formatter.feature({
  "line": 2,
  "name": "CAPEC-29: Leveraging Time-of-Check and Time-of-Use (TOCTOU) Race Conditions",
  "description": "",
  "id": "capec-29:-leveraging-time-of-check-and-time-of-use-(toctou)-race-conditions",
  "keyword": "Feature",
  "tags": [
    {
      "line": 1,
      "name": "@capec29"
    }
  ]
});
formatter.scenario({
  "comments": [
    {
      "line": 3,
      "value": "#2. Experiment"
    }
  ],
  "line": 4,
  "name": "Step2.1",
  "description": "",
  "id": "capec-29:-leveraging-time-of-check-and-time-of-use-(toctou)-race-conditions;step2.1",
  "type": "scenario",
  "keyword": "Scenario"
});
formatter.step({
  "line": 5,
  "name": "prepare to",
  "keyword": "Given "
});
formatter.step({
  "line": 6,
  "name": "Try to",
  "keyword": "When "
});
formatter.step({
  "comments": [
    {
      "line": 7,
      "value": "# assertion for attack step success"
    }
  ],
  "line": 8,
  "name": "Assert the success of",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 9,
      "value": "#assertions for security pattern testing (checker whether the pattern consequences are observed)"
    }
  ],
  "line": 10,
  "name": "assert the consequences of the pattern",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 11,
      "value": "#"
    }
  ],
  "line": 12,
  "name": "assert the consequences of the pattern audit interceptor",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 13,
      "value": "# depends secure logger"
    }
  ],
  "line": 14,
  "name": "assert the consequences of the pattern secure logger",
  "keyword": "Then "
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({
  "location": "PatternSteps.assauditinterceptor()"
});
formatter.result({
  "status": "skipped"
});
formatter.match({
  "location": "PatternSteps.asssecurelogger()"
});
formatter.result({
  "status": "skipped"
});
formatter.uri("CAPEC_29_Step_3_1.feature");
formatter.feature({
  "line": 2,
  "name": "CAPEC-29: Leveraging Time-of-Check and Time-of-Use (TOCTOU) Race Conditions",
  "description": "",
  "id": "capec-29:-leveraging-time-of-check-and-time-of-use-(toctou)-race-conditions",
  "keyword": "Feature",
  "tags": [
    {
      "line": 1,
      "name": "@capec29"
    }
  ]
});
formatter.scenario({
  "comments": [
    {
      "line": 3,
      "value": "#3. Exploit"
    }
  ],
  "line": 4,
  "name": "Step3.1",
  "description": "",
  "id": "capec-29:-leveraging-time-of-check-and-time-of-use-(toctou)-race-conditions;step3.1",
  "type": "scenario",
  "keyword": "Scenario"
});
formatter.step({
  "line": 5,
  "name": "prepare to",
  "keyword": "Given "
});
formatter.step({
  "line": 6,
  "name": "Try to",
  "keyword": "When "
});
formatter.step({
  "comments": [
    {
      "line": 7,
      "value": "# assertion for attack step success"
    }
  ],
  "line": 8,
  "name": "Assert the success of",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 9,
      "value": "#assertions for security pattern testing (checker whether the pattern consequences are observed)"
    }
  ],
  "line": 10,
  "name": "assert the consequences of the pattern",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 11,
      "value": "#"
    }
  ],
  "line": 12,
  "name": "assert the consequences of the pattern audit interceptor",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 13,
      "value": "# depends secure logger"
    }
  ],
  "line": 14,
  "name": "assert the consequences of the pattern secure logger",
  "keyword": "Then "
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({
  "location": "PatternSteps.assauditinterceptor()"
});
formatter.result({
  "status": "skipped"
});
formatter.match({
  "location": "PatternSteps.asssecurelogger()"
});
formatter.result({
  "status": "skipped"
});
formatter.uri("CAPEC_2_Step_1_1.feature");
formatter.feature({
  "line": 2,
  "name": "CAPEC-2: Inducing Account Lockout",
  "description": "",
  "id": "capec-2:-inducing-account-lockout",
  "keyword": "Feature",
  "tags": [
    {
      "line": 1,
      "name": "@capec2"
    }
  ]
});
formatter.scenario({
  "comments": [
    {
      "line": 3,
      "value": "#1. Experiment"
    }
  ],
  "line": 4,
  "name": "Step1.1 Investigate account lockout behavior of system",
  "description": "",
  "id": "capec-2:-inducing-account-lockout;step1.1-investigate-account-lockout-behavior-of-system",
  "type": "scenario",
  "keyword": "Scenario"
});
formatter.step({
  "line": 5,
  "name": "prepare to Investigate account lockout behavior of system",
  "keyword": "Given "
});
formatter.step({
  "line": 6,
  "name": "Try to Investigate account lockout behavior of system",
  "keyword": "When "
});
formatter.step({
  "comments": [
    {
      "line": 7,
      "value": "# assertion for attack step success"
    }
  ],
  "line": 8,
  "name": "Assert the success of Investigate account lockout behavior of system",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 9,
      "value": "#assertions for security pattern testing (checker whether the pattern consequences are observed)"
    }
  ],
  "line": 10,
  "name": "assert the consequences of the pattern",
  "keyword": "Then "
});
formatter.match({
  "location": "investigateaccountlockoutbehaviorofsystem.preinvestigateaccountlockoutbehaviorofsystem()"
});
formatter.result({
  "duration": 62956,
  "status": "passed"
});
formatter.match({
  "location": "investigateaccountlockoutbehaviorofsystem.tryinvestigateaccountlockoutbehaviorofsystem()"
});
formatter.result({
  "duration": 4616,
  "status": "passed"
});
formatter.match({
  "location": "investigateaccountlockoutbehaviorofsystem.assinvestigateaccountlockoutbehaviorofsystem()"
});
formatter.result({
  "duration": 3746,
  "status": "passed"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.uri("CAPEC_2_Step_1_2.feature");
formatter.feature({
  "line": 2,
  "name": "CAPEC-2: Inducing Account Lockout",
  "description": "",
  "id": "capec-2:-inducing-account-lockout",
  "keyword": "Feature",
  "tags": [
    {
      "line": 1,
      "name": "@capec2"
    }
  ]
});
formatter.scenario({
  "comments": [
    {
      "line": 3,
      "value": "#1. Experiment"
    }
  ],
  "line": 4,
  "name": "Step1.2 Obtain list of user accounts to lock out",
  "description": "",
  "id": "capec-2:-inducing-account-lockout;step1.2-obtain-list-of-user-accounts-to-lock-out",
  "type": "scenario",
  "keyword": "Scenario"
});
formatter.step({
  "line": 5,
  "name": "prepare to Obtain list of user accounts to lock out",
  "keyword": "Given "
});
formatter.step({
  "line": 6,
  "name": "Try to Obtain list of user accounts to lock out",
  "keyword": "When "
});
formatter.step({
  "comments": [
    {
      "line": 7,
      "value": "# assertion for attack step success"
    }
  ],
  "line": 8,
  "name": "Assert the success of Obtain list of user accounts to lock out",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 9,
      "value": "#assertions for security pattern testing (checker whether the pattern consequences are observed)"
    }
  ],
  "line": 10,
  "name": "assert the consequences of the pattern",
  "keyword": "Then "
});
formatter.match({
  "location": "obtainlistofuseraccountstolockout.preobtainlistofuseraccountstolockout()"
});
formatter.result({
  "duration": 45865,
  "status": "passed"
});
formatter.match({
  "location": "obtainlistofuseraccountstolockout.tryobtainlistofuseraccountstolockout()"
});
formatter.result({
  "duration": 4201,
  "status": "passed"
});
formatter.match({
  "location": "obtainlistofuseraccountstolockout.assobtainlistofuseraccountstolockout()"
});
formatter.result({
  "duration": 3888,
  "status": "passed"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.uri("CAPEC_2_Step_2_1.feature");
formatter.feature({
  "line": 2,
  "name": "CAPEC-2: Inducing Account Lockout",
  "description": "",
  "id": "capec-2:-inducing-account-lockout",
  "keyword": "Feature",
  "tags": [
    {
      "line": 1,
      "name": "@capec2"
    }
  ]
});
formatter.scenario({
  "comments": [
    {
      "line": 3,
      "value": "#2. Exploit"
    }
  ],
  "line": 4,
  "name": "Step2.1 Lock Out Accounts",
  "description": "",
  "id": "capec-2:-inducing-account-lockout;step2.1-lock-out-accounts",
  "type": "scenario",
  "keyword": "Scenario"
});
formatter.step({
  "line": 5,
  "name": "prepare to Lock Out Accounts",
  "keyword": "Given "
});
formatter.step({
  "line": 6,
  "name": "Try to Lock Out Accounts",
  "keyword": "When "
});
formatter.step({
  "comments": [
    {
      "line": 7,
      "value": "# assertion for attack step success"
    }
  ],
  "line": 8,
  "name": "Assert the success of Lock Out Accounts",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 9,
      "value": "#assertions for security pattern testing (checker whether the pattern consequences are observed)"
    }
  ],
  "line": 10,
  "name": "assert the consequences of the pattern",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 11,
      "value": "#"
    }
  ],
  "line": 12,
  "name": "assert the consequences of the pattern audit interceptor",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 13,
      "value": "# depends secure logger"
    }
  ],
  "line": 14,
  "name": "assert the consequences of the pattern secure logger",
  "keyword": "Then "
});
formatter.match({
  "location": "lockoutaccounts.prelockoutaccounts()"
});
formatter.result({
  "duration": 52911,
  "status": "passed"
});
formatter.match({
  "location": "lockoutaccounts.trylockoutaccounts()"
});
formatter.result({
  "duration": 4476,
  "status": "passed"
});
formatter.match({
  "location": "lockoutaccounts.asslockoutaccounts()"
});
formatter.result({
  "duration": 3769,
  "status": "passed"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({
  "location": "PatternSteps.assauditinterceptor()"
});
formatter.result({
  "status": "skipped"
});
formatter.match({
  "location": "PatternSteps.asssecurelogger()"
});
formatter.result({
  "status": "skipped"
});
formatter.uri("CAPEC_30_Step_1_1.feature");
formatter.feature({
  "line": 2,
  "name": "CAPEC-30: Hijacking a Privileged Thread of Execution",
  "description": "",
  "id": "capec-30:-hijacking-a-privileged-thread-of-execution",
  "keyword": "Feature",
  "tags": [
    {
      "line": 1,
      "name": "@capec30"
    }
  ]
});
formatter.scenario({
  "comments": [
    {
      "line": 3,
      "value": "#1. Explore"
    }
  ],
  "line": 4,
  "name": "Step1.1",
  "description": "",
  "id": "capec-30:-hijacking-a-privileged-thread-of-execution;step1.1",
  "type": "scenario",
  "keyword": "Scenario"
});
formatter.step({
  "line": 5,
  "name": "prepare to",
  "keyword": "Given "
});
formatter.step({
  "line": 6,
  "name": "Try to",
  "keyword": "When "
});
formatter.step({
  "comments": [
    {
      "line": 7,
      "value": "# assertion for attack step success"
    }
  ],
  "line": 8,
  "name": "Assert the success of",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 9,
      "value": "#assertions for security pattern testing (checker whether the pattern consequences are observed)"
    }
  ],
  "line": 10,
  "name": "assert the consequences of the pattern",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 11,
      "value": "#"
    }
  ],
  "line": 12,
  "name": "assert the consequences of the pattern audit interceptor",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 13,
      "value": "# depends secure logger"
    }
  ],
  "line": 14,
  "name": "assert the consequences of the pattern secure logger",
  "keyword": "Then "
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({
  "location": "PatternSteps.assauditinterceptor()"
});
formatter.result({
  "status": "skipped"
});
formatter.match({
  "location": "PatternSteps.asssecurelogger()"
});
formatter.result({
  "status": "skipped"
});
formatter.uri("CAPEC_30_Step_2_1.feature");
formatter.feature({
  "line": 2,
  "name": "CAPEC-30: Hijacking a Privileged Thread of Execution",
  "description": "",
  "id": "capec-30:-hijacking-a-privileged-thread-of-execution",
  "keyword": "Feature",
  "tags": [
    {
      "line": 1,
      "name": "@capec30"
    }
  ]
});
formatter.scenario({
  "comments": [
    {
      "line": 3,
      "value": "#2. Experiment"
    }
  ],
  "line": 4,
  "name": "Step2.1",
  "description": "",
  "id": "capec-30:-hijacking-a-privileged-thread-of-execution;step2.1",
  "type": "scenario",
  "keyword": "Scenario"
});
formatter.step({
  "line": 5,
  "name": "prepare to",
  "keyword": "Given "
});
formatter.step({
  "line": 6,
  "name": "Try to",
  "keyword": "When "
});
formatter.step({
  "comments": [
    {
      "line": 7,
      "value": "# assertion for attack step success"
    }
  ],
  "line": 8,
  "name": "Assert the success of",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 9,
      "value": "#assertions for security pattern testing (checker whether the pattern consequences are observed)"
    }
  ],
  "line": 10,
  "name": "assert the consequences of the pattern",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 11,
      "value": "#"
    }
  ],
  "line": 12,
  "name": "assert the consequences of the pattern audit interceptor",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 13,
      "value": "# depends secure logger"
    }
  ],
  "line": 14,
  "name": "assert the consequences of the pattern secure logger",
  "keyword": "Then "
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({
  "location": "PatternSteps.assauditinterceptor()"
});
formatter.result({
  "status": "skipped"
});
formatter.match({
  "location": "PatternSteps.asssecurelogger()"
});
formatter.result({
  "status": "skipped"
});
formatter.uri("CAPEC_30_Step_3_1.feature");
formatter.feature({
  "line": 2,
  "name": "CAPEC-30: Hijacking a Privileged Thread of Execution",
  "description": "",
  "id": "capec-30:-hijacking-a-privileged-thread-of-execution",
  "keyword": "Feature",
  "tags": [
    {
      "line": 1,
      "name": "@capec30"
    }
  ]
});
formatter.scenario({
  "comments": [
    {
      "line": 3,
      "value": "#3. Exploit"
    }
  ],
  "line": 4,
  "name": "Step3.1",
  "description": "",
  "id": "capec-30:-hijacking-a-privileged-thread-of-execution;step3.1",
  "type": "scenario",
  "keyword": "Scenario"
});
formatter.step({
  "line": 5,
  "name": "prepare to",
  "keyword": "Given "
});
formatter.step({
  "line": 6,
  "name": "Try to",
  "keyword": "When "
});
formatter.step({
  "comments": [
    {
      "line": 7,
      "value": "# assertion for attack step success"
    }
  ],
  "line": 8,
  "name": "Assert the success of",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 9,
      "value": "#assertions for security pattern testing (checker whether the pattern consequences are observed)"
    }
  ],
  "line": 10,
  "name": "assert the consequences of the pattern",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 11,
      "value": "#"
    }
  ],
  "line": 12,
  "name": "assert the consequences of the pattern audit interceptor",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 13,
      "value": "# depends secure logger"
    }
  ],
  "line": 14,
  "name": "assert the consequences of the pattern secure logger",
  "keyword": "Then "
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({
  "location": "PatternSteps.assauditinterceptor()"
});
formatter.result({
  "status": "skipped"
});
formatter.match({
  "location": "PatternSteps.asssecurelogger()"
});
formatter.result({
  "status": "skipped"
});
formatter.uri("CAPEC_31_Step_1_1.feature");
formatter.feature({
  "line": 2,
  "name": "CAPEC-31: Accessing/Intercepting/Modifying HTTP Cookies",
  "description": "",
  "id": "capec-31:-accessing/intercepting/modifying-http-cookies",
  "keyword": "Feature",
  "tags": [
    {
      "line": 1,
      "name": "@capec31"
    }
  ]
});
formatter.scenario({
  "comments": [
    {
      "line": 3,
      "value": "#1. Explore"
    }
  ],
  "line": 4,
  "name": "Step1.1 Obtain copy of cookie",
  "description": "",
  "id": "capec-31:-accessing/intercepting/modifying-http-cookies;step1.1-obtain-copy-of-cookie",
  "type": "scenario",
  "keyword": "Scenario"
});
formatter.step({
  "line": 5,
  "name": "prepare to Obtain copy of cookie",
  "keyword": "Given "
});
formatter.step({
  "line": 6,
  "name": "Try to Obtain copy of cookie",
  "keyword": "When "
});
formatter.step({
  "comments": [
    {
      "line": 7,
      "value": "# assertion for attack step success"
    }
  ],
  "line": 8,
  "name": "Assert the success of Obtain copy of cookie",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 9,
      "value": "#assertions for security pattern testing (checker whether the pattern consequences are observed)"
    }
  ],
  "line": 10,
  "name": "assert the consequences of the pattern secure logger",
  "keyword": "Then "
});
formatter.match({
  "location": "obtaincopyofcookie.preobtaincopyofcookie()"
});
formatter.result({
  "duration": 67315,
  "status": "passed"
});
formatter.match({
  "location": "obtaincopyofcookie.tryobtaincopyofcookie()"
});
formatter.result({
  "duration": 4238,
  "status": "passed"
});
formatter.match({
  "location": "obtaincopyofcookie.assobtaincopyofcookie()"
});
formatter.result({
  "duration": 3789,
  "status": "passed"
});
formatter.match({
  "location": "PatternSteps.asssecurelogger()"
});
formatter.result({
  "duration": 16356,
  "status": "passed"
});
formatter.uri("CAPEC_31_Step_2_1.feature");
formatter.feature({
  "line": 2,
  "name": "CAPEC-31: Accessing/Intercepting/Modifying HTTP Cookies",
  "description": "",
  "id": "capec-31:-accessing/intercepting/modifying-http-cookies",
  "keyword": "Feature",
  "tags": [
    {
      "line": 1,
      "name": "@capec31"
    }
  ]
});
formatter.scenario({
  "comments": [
    {
      "line": 3,
      "value": "#2. Experiment"
    }
  ],
  "line": 4,
  "name": "Step2.1 Obtain sensitive information from cookie",
  "description": "",
  "id": "capec-31:-accessing/intercepting/modifying-http-cookies;step2.1-obtain-sensitive-information-from-cookie",
  "type": "scenario",
  "keyword": "Scenario"
});
formatter.step({
  "line": 5,
  "name": "prepare to Obtain sensitive information from cookie",
  "keyword": "Given "
});
formatter.step({
  "line": 6,
  "name": "Try to Obtain sensitive information from cookie",
  "keyword": "When "
});
formatter.step({
  "comments": [
    {
      "line": 7,
      "value": "# assertion for attack step success"
    }
  ],
  "line": 8,
  "name": "Assert the success of Obtain sensitive information from cookie",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 9,
      "value": "#assertions for security pattern testing (checker whether the pattern consequences are observed)"
    }
  ],
  "line": 10,
  "name": "assert the consequences of the pattern",
  "keyword": "Then "
});
formatter.match({
  "location": "obtainsensitiveinformationfromcookie.preobtainsensitiveinformationfromcookie()"
});
formatter.result({
  "duration": 60079,
  "status": "passed"
});
formatter.match({
  "location": "obtainsensitiveinformationfromcookie.tryobtainsensitiveinformationfromcookie()"
});
formatter.result({
  "duration": 4136,
  "status": "passed"
});
formatter.match({
  "location": "obtainsensitiveinformationfromcookie.assobtainsensitiveinformationfromcookie()"
});
formatter.result({
  "duration": 4086,
  "status": "passed"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.uri("CAPEC_31_Step_2_2.feature");
formatter.feature({
  "line": 2,
  "name": "CAPEC-31: Accessing/Intercepting/Modifying HTTP Cookies",
  "description": "",
  "id": "capec-31:-accessing/intercepting/modifying-http-cookies",
  "keyword": "Feature",
  "tags": [
    {
      "line": 1,
      "name": "@capec31"
    }
  ]
});
formatter.scenario({
  "comments": [
    {
      "line": 3,
      "value": "#2. Experiment"
    }
  ],
  "line": 4,
  "name": "Step2.2 Modify cookie to subvert security controls.",
  "description": "",
  "id": "capec-31:-accessing/intercepting/modifying-http-cookies;step2.2-modify-cookie-to-subvert-security-controls.",
  "type": "scenario",
  "keyword": "Scenario"
});
formatter.step({
  "line": 5,
  "name": "prepare to Modify cookie to subvert security controls.",
  "keyword": "Given "
});
formatter.step({
  "line": 6,
  "name": "Try to Modify cookie to subvert security controls.",
  "keyword": "When "
});
formatter.step({
  "comments": [
    {
      "line": 7,
      "value": "# assertion for attack step success"
    }
  ],
  "line": 8,
  "name": "Assert the success of Modify cookie to subvert security controls.",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 9,
      "value": "#assertions for security pattern testing (checker whether the pattern consequences are observed)"
    }
  ],
  "line": 10,
  "name": "assert the consequences of the pattern",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 11,
      "value": "#"
    }
  ],
  "line": 12,
  "name": "assert the consequences of the pattern secure logger",
  "keyword": "Then "
});
formatter.match({
  "location": "modifycookietosubvertsecuritycontrols.premodifycookietosubvertsecuritycontrols()"
});
formatter.result({
  "duration": 58859,
  "status": "passed"
});
formatter.match({
  "location": "modifycookietosubvertsecuritycontrols.trymodifycookietosubvertsecuritycontrols()"
});
formatter.result({
  "duration": 4132,
  "status": "passed"
});
formatter.match({
  "location": "modifycookietosubvertsecuritycontrols.assmodifycookietosubvertsecuritycontrols()"
});
formatter.result({
  "duration": 5002,
  "status": "passed"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({
  "location": "PatternSteps.asssecurelogger()"
});
formatter.result({
  "status": "skipped"
});
formatter.uri("CAPEC_32_Step_1_1.feature");
formatter.feature({
  "line": 2,
  "name": "CAPEC-32: Embedding Scripts in HTTP Query Strings",
  "description": "",
  "id": "capec-32:-embedding-scripts-in-http-query-strings",
  "keyword": "Feature",
  "tags": [
    {
      "line": 1,
      "name": "@capec32"
    }
  ]
});
formatter.scenario({
  "comments": [
    {
      "line": 3,
      "value": "#1. Explore"
    }
  ],
  "line": 4,
  "name": "Step1.1 Spider",
  "description": "",
  "id": "capec-32:-embedding-scripts-in-http-query-strings;step1.1-spider",
  "type": "scenario",
  "keyword": "Scenario"
});
formatter.step({
  "line": 5,
  "name": "prepare to Spider",
  "keyword": "Given "
});
formatter.step({
  "line": 6,
  "name": "Try to Spider",
  "keyword": "When "
});
formatter.step({
  "comments": [
    {
      "line": 7,
      "value": "# assertion for attack step success"
    }
  ],
  "line": 8,
  "name": "Assert the success of Spider",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 9,
      "value": "#assertions for security pattern testing (checker whether the pattern consequences are observed)"
    }
  ],
  "line": 10,
  "name": "assert the consequences of the pattern",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 11,
      "value": "#"
    }
  ],
  "line": 12,
  "name": "assert the consequences of the pattern audit interceptor",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 13,
      "value": "# depends secure logger"
    }
  ],
  "line": 14,
  "name": "assert the consequences of the pattern secure logger",
  "keyword": "Then "
});
formatter.match({
  "location": "spider.prespider()"
});
formatter.result({
  "duration": 3002248,
  "error_message": "net.continuumsecurity.proxy.ProxyException: org.zaproxy.clientapi.core.ClientApiException: java.net.ConnectException: Connection refused\n\tat net.continuumsecurity.proxy.ZAProxyScanner.validateMinimumRequiredZapVersion(ZAProxyScanner.java:96)\n\tat net.continuumsecurity.proxy.ZAProxyScanner.\u003cinit\u003e(ZAProxyScanner.java:38)\n\tat steps.spider.prespider(spider.java:17)\n\tat ✽.Given prepare to Spider(CAPEC_32_Step_1_1.feature:5)\nCaused by: org.zaproxy.clientapi.core.ClientApiException: java.net.ConnectException: Connection refused\n\tat org.zaproxy.clientapi.core.ClientApi.callApiDom(ClientApi.java:307)\n\tat org.zaproxy.clientapi.core.ClientApi.callApi(ClientApi.java:289)\n\tat org.zaproxy.clientapi.gen.Core.version(Core.java:158)\n\tat net.continuumsecurity.proxy.ZAProxyScanner.validateMinimumRequiredZapVersion(ZAProxyScanner.java:85)\n\tat net.continuumsecurity.proxy.ZAProxyScanner.\u003cinit\u003e(ZAProxyScanner.java:38)\n\tat steps.spider.prespider(spider.java:17)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.lang.reflect.Method.invoke(Method.java:498)\n\tat cucumber.runtime.Utils$1.call(Utils.java:37)\n\tat cucumber.runtime.Timeout.timeout(Timeout.java:13)\n\tat cucumber.runtime.Utils.invoke(Utils.java:31)\n\tat cucumber.runtime.java.JavaStepDefinition.execute(JavaStepDefinition.java:37)\n\tat cucumber.runtime.StepDefinitionMatch.runStep(StepDefinitionMatch.java:37)\n\tat cucumber.runtime.Runtime.runStep(Runtime.java:298)\n\tat cucumber.runtime.model.StepContainer.runStep(StepContainer.java:44)\n\tat cucumber.runtime.model.StepContainer.runSteps(StepContainer.java:39)\n\tat cucumber.runtime.model.CucumberScenario.run(CucumberScenario.java:48)\n\tat cucumber.runtime.junit.ExecutionUnitRunner.run(ExecutionUnitRunner.java:91)\n\tat cucumber.runtime.junit.FeatureRunner.runChild(FeatureRunner.java:63)\n\tat cucumber.runtime.junit.FeatureRunner.runChild(FeatureRunner.java:18)\n\tat org.junit.runners.ParentRunner$3.run(ParentRunner.java:238)\n\tat org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:63)\n\tat org.junit.runners.ParentRunner.runChildren(ParentRunner.java:236)\n\tat org.junit.runners.ParentRunner.access$000(ParentRunner.java:53)\n\tat org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:229)\n\tat org.junit.runners.ParentRunner.run(ParentRunner.java:309)\n\tat cucumber.runtime.junit.FeatureRunner.run(FeatureRunner.java:70)\n\tat cucumber.api.junit.Cucumber.runChild(Cucumber.java:93)\n\tat cucumber.api.junit.Cucumber.runChild(Cucumber.java:37)\n\tat org.junit.runners.ParentRunner$3.run(ParentRunner.java:238)\n\tat org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:63)\n\tat org.junit.runners.ParentRunner.runChildren(ParentRunner.java:236)\n\tat org.junit.runners.ParentRunner.access$000(ParentRunner.java:53)\n\tat org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:229)\n\tat org.junit.internal.runners.statements.RunAfters.evaluate(RunAfters.java:27)\n\tat org.junit.runners.ParentRunner.run(ParentRunner.java:309)\n\tat cucumber.api.junit.Cucumber.run(Cucumber.java:98)\n\tat org.eclipse.jdt.internal.junit4.runner.JUnit4TestReference.run(JUnit4TestReference.java:86)\n\tat org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:459)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:678)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:382)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:192)\nCaused by: java.net.ConnectException: Connection refused\n\tat java.net.PlainSocketImpl.socketConnect(Native Method)\n\tat java.net.AbstractPlainSocketImpl.doConnect(AbstractPlainSocketImpl.java:350)\n\tat java.net.AbstractPlainSocketImpl.connectToAddress(AbstractPlainSocketImpl.java:206)\n\tat java.net.AbstractPlainSocketImpl.connect(AbstractPlainSocketImpl.java:188)\n\tat java.net.Socket.connect(Socket.java:589)\n\tat java.net.Socket.connect(Socket.java:538)\n\tat sun.net.NetworkClient.doConnect(NetworkClient.java:180)\n\tat sun.net.www.http.HttpClient.openServer(HttpClient.java:432)\n\tat sun.net.www.http.HttpClient$1.run(HttpClient.java:484)\n\tat sun.net.www.http.HttpClient$1.run(HttpClient.java:482)\n\tat java.security.AccessController.doPrivileged(Native Method)\n\tat sun.net.www.http.HttpClient.privilegedOpenServer(HttpClient.java:481)\n\tat sun.net.www.http.HttpClient.openServer(HttpClient.java:522)\n\tat sun.net.www.http.HttpClient.\u003cinit\u003e(HttpClient.java:211)\n\tat sun.net.www.http.HttpClient.New(HttpClient.java:308)\n\tat sun.net.www.http.HttpClient.New(HttpClient.java:326)\n\tat sun.net.www.protocol.http.HttpURLConnection.getNewHttpClient(HttpURLConnection.java:1169)\n\tat sun.net.www.protocol.http.HttpURLConnection.plainConnect0(HttpURLConnection.java:1148)\n\tat sun.net.www.protocol.http.HttpURLConnection.plainConnect(HttpURLConnection.java:999)\n\tat sun.net.www.protocol.http.HttpURLConnection.connect(HttpURLConnection.java:933)\n\tat org.zaproxy.clientapi.core.ClientApi.getConnectionInputStream(ClientApi.java:313)\n\tat org.zaproxy.clientapi.core.ClientApi.callApiDom(ClientApi.java:305)\n\t... 44 more\n",
  "status": "failed"
});
formatter.match({
  "location": "spider.tryspider()"
});
formatter.result({
  "status": "skipped"
});
formatter.match({
  "location": "spider.assspider()"
});
formatter.result({
  "status": "skipped"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({
  "location": "PatternSteps.assauditinterceptor()"
});
formatter.result({
  "status": "skipped"
});
formatter.match({
  "location": "PatternSteps.asssecurelogger()"
});
formatter.result({
  "status": "skipped"
});
formatter.uri("CAPEC_32_Step_2_1.feature");
formatter.feature({
  "line": 2,
  "name": "CAPEC-32: Embedding Scripts in HTTP Query Strings",
  "description": "",
  "id": "capec-32:-embedding-scripts-in-http-query-strings",
  "keyword": "Feature",
  "tags": [
    {
      "line": 1,
      "name": "@capec32"
    }
  ]
});
formatter.scenario({
  "comments": [
    {
      "line": 3,
      "value": "#2. Experiment"
    }
  ],
  "line": 4,
  "name": "Step2.1 Attempt variations on input parameters",
  "description": "",
  "id": "capec-32:-embedding-scripts-in-http-query-strings;step2.1-attempt-variations-on-input-parameters",
  "type": "scenario",
  "keyword": "Scenario"
});
formatter.step({
  "line": 5,
  "name": "prepare to Attempt variations on input parameters",
  "keyword": "Given "
});
formatter.step({
  "line": 6,
  "name": "Try to Attempt variations on input parameters",
  "keyword": "When "
});
formatter.step({
  "comments": [
    {
      "line": 7,
      "value": "# assertion for attack step success"
    }
  ],
  "line": 8,
  "name": "Assert the success of Attempt variations on input parameters",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 9,
      "value": "#assertions for security pattern testing (checker whether the pattern consequences are observed)"
    }
  ],
  "line": 10,
  "name": "assert the consequences of the pattern audit interceptor",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 11,
      "value": "# depends secure logger"
    }
  ],
  "line": 12,
  "name": "assert the consequences of the pattern secure logger",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 13,
      "value": "# benifits audit interceptor"
    }
  ],
  "line": 14,
  "name": "assert the consequences of the pattern application firewall",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 15,
      "value": "# alternative input guard"
    }
  ],
  "line": 16,
  "name": "assert the consequences of the pattern input guard",
  "keyword": "Then "
});
formatter.match({
  "location": "attemptvariationsoninputparameters.preattemptvariationsoninputparameters()"
});
formatter.result({
  "duration": 3385617,
  "error_message": "net.continuumsecurity.proxy.ProxyException: org.zaproxy.clientapi.core.ClientApiException: java.net.ConnectException: Connection refused\n\tat net.continuumsecurity.proxy.ZAProxyScanner.validateMinimumRequiredZapVersion(ZAProxyScanner.java:96)\n\tat net.continuumsecurity.proxy.ZAProxyScanner.\u003cinit\u003e(ZAProxyScanner.java:38)\n\tat steps.attemptvariationsoninputparameters.preattemptvariationsoninputparameters(attemptvariationsoninputparameters.java:19)\n\tat ✽.Given prepare to Attempt variations on input parameters(CAPEC_32_Step_2_1.feature:5)\nCaused by: org.zaproxy.clientapi.core.ClientApiException: java.net.ConnectException: Connection refused\n\tat org.zaproxy.clientapi.core.ClientApi.callApiDom(ClientApi.java:307)\n\tat org.zaproxy.clientapi.core.ClientApi.callApi(ClientApi.java:289)\n\tat org.zaproxy.clientapi.gen.Core.version(Core.java:158)\n\tat net.continuumsecurity.proxy.ZAProxyScanner.validateMinimumRequiredZapVersion(ZAProxyScanner.java:85)\n\tat net.continuumsecurity.proxy.ZAProxyScanner.\u003cinit\u003e(ZAProxyScanner.java:38)\n\tat steps.attemptvariationsoninputparameters.preattemptvariationsoninputparameters(attemptvariationsoninputparameters.java:19)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.lang.reflect.Method.invoke(Method.java:498)\n\tat cucumber.runtime.Utils$1.call(Utils.java:37)\n\tat cucumber.runtime.Timeout.timeout(Timeout.java:13)\n\tat cucumber.runtime.Utils.invoke(Utils.java:31)\n\tat cucumber.runtime.java.JavaStepDefinition.execute(JavaStepDefinition.java:37)\n\tat cucumber.runtime.StepDefinitionMatch.runStep(StepDefinitionMatch.java:37)\n\tat cucumber.runtime.Runtime.runStep(Runtime.java:298)\n\tat cucumber.runtime.model.StepContainer.runStep(StepContainer.java:44)\n\tat cucumber.runtime.model.StepContainer.runSteps(StepContainer.java:39)\n\tat cucumber.runtime.model.CucumberScenario.run(CucumberScenario.java:48)\n\tat cucumber.runtime.junit.ExecutionUnitRunner.run(ExecutionUnitRunner.java:91)\n\tat cucumber.runtime.junit.FeatureRunner.runChild(FeatureRunner.java:63)\n\tat cucumber.runtime.junit.FeatureRunner.runChild(FeatureRunner.java:18)\n\tat org.junit.runners.ParentRunner$3.run(ParentRunner.java:238)\n\tat org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:63)\n\tat org.junit.runners.ParentRunner.runChildren(ParentRunner.java:236)\n\tat org.junit.runners.ParentRunner.access$000(ParentRunner.java:53)\n\tat org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:229)\n\tat org.junit.runners.ParentRunner.run(ParentRunner.java:309)\n\tat cucumber.runtime.junit.FeatureRunner.run(FeatureRunner.java:70)\n\tat cucumber.api.junit.Cucumber.runChild(Cucumber.java:93)\n\tat cucumber.api.junit.Cucumber.runChild(Cucumber.java:37)\n\tat org.junit.runners.ParentRunner$3.run(ParentRunner.java:238)\n\tat org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:63)\n\tat org.junit.runners.ParentRunner.runChildren(ParentRunner.java:236)\n\tat org.junit.runners.ParentRunner.access$000(ParentRunner.java:53)\n\tat org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:229)\n\tat org.junit.internal.runners.statements.RunAfters.evaluate(RunAfters.java:27)\n\tat org.junit.runners.ParentRunner.run(ParentRunner.java:309)\n\tat cucumber.api.junit.Cucumber.run(Cucumber.java:98)\n\tat org.eclipse.jdt.internal.junit4.runner.JUnit4TestReference.run(JUnit4TestReference.java:86)\n\tat org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:459)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:678)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:382)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:192)\nCaused by: java.net.ConnectException: Connection refused\n\tat java.net.PlainSocketImpl.socketConnect(Native Method)\n\tat java.net.AbstractPlainSocketImpl.doConnect(AbstractPlainSocketImpl.java:350)\n\tat java.net.AbstractPlainSocketImpl.connectToAddress(AbstractPlainSocketImpl.java:206)\n\tat java.net.AbstractPlainSocketImpl.connect(AbstractPlainSocketImpl.java:188)\n\tat java.net.Socket.connect(Socket.java:589)\n\tat java.net.Socket.connect(Socket.java:538)\n\tat sun.net.NetworkClient.doConnect(NetworkClient.java:180)\n\tat sun.net.www.http.HttpClient.openServer(HttpClient.java:432)\n\tat sun.net.www.http.HttpClient$1.run(HttpClient.java:484)\n\tat sun.net.www.http.HttpClient$1.run(HttpClient.java:482)\n\tat java.security.AccessController.doPrivileged(Native Method)\n\tat sun.net.www.http.HttpClient.privilegedOpenServer(HttpClient.java:481)\n\tat sun.net.www.http.HttpClient.openServer(HttpClient.java:522)\n\tat sun.net.www.http.HttpClient.\u003cinit\u003e(HttpClient.java:211)\n\tat sun.net.www.http.HttpClient.New(HttpClient.java:308)\n\tat sun.net.www.http.HttpClient.New(HttpClient.java:326)\n\tat sun.net.www.protocol.http.HttpURLConnection.getNewHttpClient(HttpURLConnection.java:1169)\n\tat sun.net.www.protocol.http.HttpURLConnection.plainConnect0(HttpURLConnection.java:1148)\n\tat sun.net.www.protocol.http.HttpURLConnection.plainConnect(HttpURLConnection.java:999)\n\tat sun.net.www.protocol.http.HttpURLConnection.connect(HttpURLConnection.java:933)\n\tat org.zaproxy.clientapi.core.ClientApi.getConnectionInputStream(ClientApi.java:313)\n\tat org.zaproxy.clientapi.core.ClientApi.callApiDom(ClientApi.java:305)\n\t... 44 more\n",
  "status": "failed"
});
formatter.match({
  "location": "attemptvariationsoninputparameters.tryattemptvariationsoninputparameters()"
});
formatter.result({
  "status": "skipped"
});
formatter.match({
  "location": "attemptvariationsoninputparameters.assattemptvariationsoninputparameters()"
});
formatter.result({
  "status": "skipped"
});
formatter.match({
  "location": "PatternSteps.assauditinterceptor()"
});
formatter.result({
  "status": "skipped"
});
formatter.match({
  "location": "PatternSteps.asssecurelogger()"
});
formatter.result({
  "status": "skipped"
});
formatter.match({
  "location": "PatternSteps.assapplicationfirewall()"
});
formatter.result({
  "status": "skipped"
});
formatter.match({
  "location": "PatternSteps.assinputguard()"
});
formatter.result({
  "status": "skipped"
});
formatter.uri("CAPEC_32_Step_3_1.feature");
formatter.feature({
  "line": 2,
  "name": "CAPEC-32: Embedding Scripts in HTTP Query Strings",
  "description": "",
  "id": "capec-32:-embedding-scripts-in-http-query-strings",
  "keyword": "Feature",
  "tags": [
    {
      "line": 1,
      "name": "@capec32"
    }
  ]
});
formatter.scenario({
  "comments": [
    {
      "line": 3,
      "value": "#3. Exploit"
    }
  ],
  "line": 4,
  "name": "Step3.1 Steal session IDs, credentials, page content, etc.",
  "description": "",
  "id": "capec-32:-embedding-scripts-in-http-query-strings;step3.1-steal-session-ids,-credentials,-page-content,-etc.",
  "type": "scenario",
  "keyword": "Scenario"
});
formatter.step({
  "line": 5,
  "name": "prepare to Steal session IDs, credentials, page content, etc.",
  "keyword": "Given "
});
formatter.step({
  "line": 6,
  "name": "Try to Steal session IDs, credentials, page content, etc.",
  "keyword": "When "
});
formatter.step({
  "comments": [
    {
      "line": 7,
      "value": "# assertion for attack step success"
    }
  ],
  "line": 8,
  "name": "Assert the success of Steal session IDs, credentials, page content, etc.",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 9,
      "value": "#assertions for security pattern testing (checker whether the pattern consequences are observed)"
    }
  ],
  "line": 10,
  "name": "assert the consequences of the pattern audit interceptor",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 11,
      "value": "# depends secure logger"
    }
  ],
  "line": 12,
  "name": "assert the consequences of the pattern secure logger",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 13,
      "value": "# benifits audit interceptor"
    }
  ],
  "line": 14,
  "name": "assert the consequences of the pattern application firewall",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 15,
      "value": "# alternative output guard"
    },
    {
      "line": 16,
      "value": "# alternative input guard"
    }
  ],
  "line": 17,
  "name": "assert the consequences of the pattern input guard",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 18,
      "value": "# alternative application firewall"
    },
    {
      "line": 19,
      "value": "# benifits output guard"
    }
  ],
  "line": 20,
  "name": "assert the consequences of the pattern output guard",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 21,
      "value": "# alternative application firewall"
    },
    {
      "line": 22,
      "value": "# benifits input guard"
    }
  ],
  "line": 23,
  "name": "assert the consequences of the pattern comparator checked fault tolerant system",
  "keyword": "Then "
});
formatter.match({
  "location": "stealsessionidscredentialspagecontentetc.prestealsessionidscredentialspagecontentetc()"
});
formatter.result({
  "duration": 32619,
  "status": "passed"
});
formatter.match({
  "location": "stealsessionidscredentialspagecontentetc.trystealsessionidscredentialspagecontentetc()"
});
formatter.result({
  "duration": 4162,
  "status": "passed"
});
formatter.match({
  "location": "stealsessionidscredentialspagecontentetc.assstealsessionidscredentialspagecontentetc()"
});
formatter.result({
  "duration": 4094,
  "status": "passed"
});
formatter.match({
  "location": "PatternSteps.assauditinterceptor()"
});
formatter.result({
  "duration": 410566,
  "status": "passed"
});
formatter.match({
  "location": "PatternSteps.asssecurelogger()"
});
formatter.result({
  "duration": 8210,
  "status": "passed"
});
formatter.match({
  "location": "PatternSteps.assapplicationfirewall()"
});
formatter.result({
  "duration": 4045,
  "status": "passed"
});
formatter.match({
  "location": "PatternSteps.assinputguard()"
});
formatter.result({
  "duration": 3580,
  "status": "passed"
});
formatter.match({
  "location": "PatternSteps.assoutputguard()"
});
formatter.result({
  "duration": 4287,
  "status": "passed"
});
formatter.match({
  "location": "PatternSteps.asscomparatorcheckedfaulttolerantsystem()"
});
formatter.result({
  "duration": 3498,
  "status": "passed"
});
formatter.uri("CAPEC_32_Step_3_2.feature");
formatter.feature({
  "line": 2,
  "name": "CAPEC-32: Embedding Scripts in HTTP Query Strings",
  "description": "",
  "id": "capec-32:-embedding-scripts-in-http-query-strings",
  "keyword": "Feature",
  "tags": [
    {
      "line": 1,
      "name": "@capec32"
    }
  ]
});
formatter.scenario({
  "comments": [
    {
      "line": 3,
      "value": "#3. Exploit"
    }
  ],
  "line": 4,
  "name": "Step3.2 Forceful browsing",
  "description": "",
  "id": "capec-32:-embedding-scripts-in-http-query-strings;step3.2-forceful-browsing",
  "type": "scenario",
  "keyword": "Scenario"
});
formatter.step({
  "line": 5,
  "name": "prepare to Forceful browsing",
  "keyword": "Given "
});
formatter.step({
  "line": 6,
  "name": "Try to Forceful browsing",
  "keyword": "When "
});
formatter.step({
  "comments": [
    {
      "line": 7,
      "value": "# assertion for attack step success"
    }
  ],
  "line": 8,
  "name": "Assert the success of Forceful browsing",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 9,
      "value": "#assertions for security pattern testing (checker whether the pattern consequences are observed)"
    }
  ],
  "line": 10,
  "name": "assert the consequences of the pattern audit interceptor",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 11,
      "value": "# depends secure logger"
    }
  ],
  "line": 12,
  "name": "assert the consequences of the pattern secure logger",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 13,
      "value": "# benifits audit interceptor"
    }
  ],
  "line": 14,
  "name": "assert the consequences of the pattern application firewall",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 15,
      "value": "# alternative output guard"
    },
    {
      "line": 16,
      "value": "# alternative input guard"
    }
  ],
  "line": 17,
  "name": "assert the consequences of the pattern input guard",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 18,
      "value": "# alternative application firewall"
    },
    {
      "line": 19,
      "value": "# benifits output guard"
    }
  ],
  "line": 20,
  "name": "assert the consequences of the pattern output guard",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 21,
      "value": "# alternative application firewall"
    },
    {
      "line": 22,
      "value": "# benifits input guard"
    }
  ],
  "line": 23,
  "name": "assert the consequences of the pattern comparator checked fault tolerant system",
  "keyword": "Then "
});
formatter.match({
  "location": "forcefulbrowsing.preforcefulbrowsing()"
});
formatter.result({
  "duration": 30031,
  "status": "passed"
});
formatter.match({
  "location": "forcefulbrowsing.tryforcefulbrowsing()"
});
formatter.result({
  "duration": 6144,
  "status": "passed"
});
formatter.match({
  "location": "forcefulbrowsing.assforcefulbrowsing()"
});
formatter.result({
  "duration": 5249,
  "status": "passed"
});
formatter.match({
  "location": "PatternSteps.assauditinterceptor()"
});
formatter.result({
  "duration": 39885,
  "status": "passed"
});
formatter.match({
  "location": "PatternSteps.asssecurelogger()"
});
formatter.result({
  "duration": 7627,
  "status": "passed"
});
formatter.match({
  "location": "PatternSteps.assapplicationfirewall()"
});
formatter.result({
  "duration": 4958,
  "status": "passed"
});
formatter.match({
  "location": "PatternSteps.assinputguard()"
});
formatter.result({
  "duration": 5193,
  "status": "passed"
});
formatter.match({
  "location": "PatternSteps.assoutputguard()"
});
formatter.result({
  "duration": 4972,
  "status": "passed"
});
formatter.match({
  "location": "PatternSteps.asscomparatorcheckedfaulttolerantsystem()"
});
formatter.result({
  "duration": 5894,
  "status": "passed"
});
formatter.uri("CAPEC_32_Step_3_3.feature");
formatter.feature({
  "line": 2,
  "name": "CAPEC-32: Embedding Scripts in HTTP Query Strings",
  "description": "",
  "id": "capec-32:-embedding-scripts-in-http-query-strings",
  "keyword": "Feature",
  "tags": [
    {
      "line": 1,
      "name": "@capec32"
    }
  ]
});
formatter.scenario({
  "comments": [
    {
      "line": 3,
      "value": "#3. Exploit"
    }
  ],
  "line": 4,
  "name": "Step3.3 Content spoofing",
  "description": "",
  "id": "capec-32:-embedding-scripts-in-http-query-strings;step3.3-content-spoofing",
  "type": "scenario",
  "keyword": "Scenario"
});
formatter.step({
  "line": 5,
  "name": "prepare to Content spoofing",
  "keyword": "Given "
});
formatter.step({
  "line": 6,
  "name": "Try to Content spoofing",
  "keyword": "When "
});
formatter.step({
  "comments": [
    {
      "line": 7,
      "value": "# assertion for attack step success"
    }
  ],
  "line": 8,
  "name": "Assert the success of Content spoofing",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 9,
      "value": "#assertions for security pattern testing (checker whether the pattern consequences are observed)"
    }
  ],
  "line": 10,
  "name": "assert the consequences of the pattern audit interceptor",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 11,
      "value": "# depends secure logger"
    }
  ],
  "line": 12,
  "name": "assert the consequences of the pattern secure logger",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 13,
      "value": "# benifits audit interceptor"
    }
  ],
  "line": 14,
  "name": "assert the consequences of the pattern application firewall",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 15,
      "value": "# alternative output guard"
    },
    {
      "line": 16,
      "value": "# alternative input guard"
    }
  ],
  "line": 17,
  "name": "assert the consequences of the pattern input guard",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 18,
      "value": "# alternative application firewall"
    },
    {
      "line": 19,
      "value": "# benifits output guard"
    }
  ],
  "line": 20,
  "name": "assert the consequences of the pattern output guard",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 21,
      "value": "# alternative application firewall"
    },
    {
      "line": 22,
      "value": "# benifits input guard"
    }
  ],
  "line": 23,
  "name": "assert the consequences of the pattern comparator checked fault tolerant system",
  "keyword": "Then "
});
formatter.match({
  "location": "contentspoofing.precontentspoofing()"
});
formatter.result({
  "duration": 28647,
  "status": "passed"
});
formatter.match({
  "location": "contentspoofing.trycontentspoofing()"
});
formatter.result({
  "duration": 5628,
  "status": "passed"
});
formatter.match({
  "location": "contentspoofing.asscontentspoofing()"
});
formatter.result({
  "duration": 5646,
  "status": "passed"
});
formatter.match({
  "location": "PatternSteps.assauditinterceptor()"
});
formatter.result({
  "duration": 19721,
  "status": "passed"
});
formatter.match({
  "location": "PatternSteps.asssecurelogger()"
});
formatter.result({
  "duration": 5356,
  "status": "passed"
});
formatter.match({
  "location": "PatternSteps.assapplicationfirewall()"
});
formatter.result({
  "duration": 5112,
  "status": "passed"
});
formatter.match({
  "location": "PatternSteps.assinputguard()"
});
formatter.result({
  "duration": 4925,
  "status": "passed"
});
formatter.match({
  "location": "PatternSteps.assoutputguard()"
});
formatter.result({
  "duration": 4765,
  "status": "passed"
});
formatter.match({
  "location": "PatternSteps.asscomparatorcheckedfaulttolerantsystem()"
});
formatter.result({
  "duration": 4992,
  "status": "passed"
});
formatter.uri("CAPEC_33_Step_1_1.feature");
formatter.feature({
  "line": 2,
  "name": "CAPEC-33: HTTP Request Smuggling",
  "description": "",
  "id": "capec-33:-http-request-smuggling",
  "keyword": "Feature",
  "tags": [
    {
      "line": 1,
      "name": "@capec33"
    }
  ]
});
formatter.scenario({
  "comments": [
    {
      "line": 3,
      "value": "#1. Explore"
    }
  ],
  "line": 4,
  "name": "Step1.1 Identify HTTP parsing chain",
  "description": "",
  "id": "capec-33:-http-request-smuggling;step1.1-identify-http-parsing-chain",
  "type": "scenario",
  "keyword": "Scenario"
});
formatter.step({
  "line": 5,
  "name": "prepare to Identify HTTP parsing chain",
  "keyword": "Given "
});
formatter.step({
  "line": 6,
  "name": "Try to Identify HTTP parsing chain",
  "keyword": "When "
});
formatter.step({
  "comments": [
    {
      "line": 7,
      "value": "# assertion for attack step success"
    }
  ],
  "line": 8,
  "name": "Assert the success of Identify HTTP parsing chain",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 9,
      "value": "#assertions for security pattern testing (checker whether the pattern consequences are observed)"
    }
  ],
  "line": 10,
  "name": "assert the consequences of the pattern",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 11,
      "value": "#"
    }
  ],
  "line": 12,
  "name": "assert the consequences of the pattern audit interceptor",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 13,
      "value": "# depends secure logger"
    }
  ],
  "line": 14,
  "name": "assert the consequences of the pattern secure logger",
  "keyword": "Then "
});
formatter.match({
  "location": "identifyhttpparsingchain.preidentifyhttpparsingchain()"
});
formatter.result({
  "duration": 68726,
  "status": "passed"
});
formatter.match({
  "location": "identifyhttpparsingchain.tryidentifyhttpparsingchain()"
});
formatter.result({
  "duration": 7216,
  "status": "passed"
});
formatter.match({
  "location": "identifyhttpparsingchain.assidentifyhttpparsingchain()"
});
formatter.result({
  "duration": 6475,
  "status": "passed"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({
  "location": "PatternSteps.assauditinterceptor()"
});
formatter.result({
  "status": "skipped"
});
formatter.match({
  "location": "PatternSteps.asssecurelogger()"
});
formatter.result({
  "status": "skipped"
});
formatter.uri("CAPEC_33_Step_2_1.feature");
formatter.feature({
  "line": 2,
  "name": "CAPEC-33: HTTP Request Smuggling",
  "description": "",
  "id": "capec-33:-http-request-smuggling",
  "keyword": "Feature",
  "tags": [
    {
      "line": 1,
      "name": "@capec33"
    }
  ]
});
formatter.scenario({
  "comments": [
    {
      "line": 3,
      "value": "#2. Experiment"
    }
  ],
  "line": 4,
  "name": "Step2.1 Probe for vulnerable differences in HTTP parsing chain",
  "description": "",
  "id": "capec-33:-http-request-smuggling;step2.1-probe-for-vulnerable-differences-in-http-parsing-chain",
  "type": "scenario",
  "keyword": "Scenario"
});
formatter.step({
  "line": 5,
  "name": "prepare to Probe for vulnerable differences in HTTP parsing chain",
  "keyword": "Given "
});
formatter.step({
  "line": 6,
  "name": "Try to Probe for vulnerable differences in HTTP parsing chain",
  "keyword": "When "
});
formatter.step({
  "comments": [
    {
      "line": 7,
      "value": "# assertion for attack step success"
    }
  ],
  "line": 8,
  "name": "Assert the success of Probe for vulnerable differences in HTTP parsing chain",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 9,
      "value": "#assertions for security pattern testing (checker whether the pattern consequences are observed)"
    }
  ],
  "line": 10,
  "name": "assert the consequences of the pattern audit interceptor",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 11,
      "value": "# depends secure logger"
    }
  ],
  "line": 12,
  "name": "assert the consequences of the pattern secure logger",
  "keyword": "Then "
});
formatter.match({
  "location": "probeforvulnerabledifferencesinhttpparsingchain.preprobeforvulnerabledifferencesinhttpparsingchain()"
});
formatter.result({
  "duration": 71538,
  "status": "passed"
});
formatter.match({
  "location": "probeforvulnerabledifferencesinhttpparsingchain.tryprobeforvulnerabledifferencesinhttpparsingchain()"
});
formatter.result({
  "duration": 6391,
  "status": "passed"
});
formatter.match({
  "location": "probeforvulnerabledifferencesinhttpparsingchain.assprobeforvulnerabledifferencesinhttpparsingchain()"
});
formatter.result({
  "duration": 6683,
  "status": "passed"
});
formatter.match({
  "location": "PatternSteps.assauditinterceptor()"
});
formatter.result({
  "duration": 21073,
  "status": "passed"
});
formatter.match({
  "location": "PatternSteps.asssecurelogger()"
});
formatter.result({
  "duration": 5876,
  "status": "passed"
});
formatter.uri("CAPEC_33_Step_3_1.feature");
formatter.feature({
  "line": 2,
  "name": "CAPEC-33: HTTP Request Smuggling",
  "description": "",
  "id": "capec-33:-http-request-smuggling",
  "keyword": "Feature",
  "tags": [
    {
      "line": 1,
      "name": "@capec33"
    }
  ]
});
formatter.scenario({
  "comments": [
    {
      "line": 3,
      "value": "#3. Exploit"
    }
  ],
  "line": 4,
  "name": "Step3.1 Cache poisoning",
  "description": "",
  "id": "capec-33:-http-request-smuggling;step3.1-cache-poisoning",
  "type": "scenario",
  "keyword": "Scenario"
});
formatter.step({
  "line": 5,
  "name": "prepare to Cache poisoning",
  "keyword": "Given "
});
formatter.step({
  "line": 6,
  "name": "Try to Cache poisoning",
  "keyword": "When "
});
formatter.step({
  "comments": [
    {
      "line": 7,
      "value": "# assertion for attack step success"
    }
  ],
  "line": 8,
  "name": "Assert the success of Cache poisoning",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 9,
      "value": "#assertions for security pattern testing (checker whether the pattern consequences are observed)"
    }
  ],
  "line": 10,
  "name": "assert the consequences of the pattern audit interceptor",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 11,
      "value": "# depends secure logger"
    }
  ],
  "line": 12,
  "name": "assert the consequences of the pattern secure logger",
  "keyword": "Then "
});
formatter.match({
  "location": "cachepoisoning.precachepoisoning()"
});
formatter.result({
  "duration": 76220,
  "status": "passed"
});
formatter.match({
  "location": "cachepoisoning.trycachepoisoning()"
});
formatter.result({
  "duration": 6255,
  "status": "passed"
});
formatter.match({
  "location": "cachepoisoning.asscachepoisoning()"
});
formatter.result({
  "duration": 5075,
  "status": "passed"
});
formatter.match({
  "location": "PatternSteps.assauditinterceptor()"
});
formatter.result({
  "duration": 20119,
  "status": "passed"
});
formatter.match({
  "location": "PatternSteps.asssecurelogger()"
});
formatter.result({
  "duration": 5216,
  "status": "passed"
});
formatter.uri("CAPEC_33_Step_3_2.feature");
formatter.feature({
  "line": 2,
  "name": "CAPEC-33: HTTP Request Smuggling",
  "description": "",
  "id": "capec-33:-http-request-smuggling",
  "keyword": "Feature",
  "tags": [
    {
      "line": 1,
      "name": "@capec33"
    }
  ]
});
formatter.scenario({
  "comments": [
    {
      "line": 3,
      "value": "#3. Exploit"
    }
  ],
  "line": 4,
  "name": "Step3.2 Session Hijacking",
  "description": "",
  "id": "capec-33:-http-request-smuggling;step3.2-session-hijacking",
  "type": "scenario",
  "keyword": "Scenario"
});
formatter.step({
  "line": 5,
  "name": "prepare to Session Hijacking",
  "keyword": "Given "
});
formatter.step({
  "line": 6,
  "name": "Try to Session Hijacking",
  "keyword": "When "
});
formatter.step({
  "comments": [
    {
      "line": 7,
      "value": "# assertion for attack step success"
    }
  ],
  "line": 8,
  "name": "Assert the success of Session Hijacking",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 9,
      "value": "#assertions for security pattern testing (checker whether the pattern consequences are observed)"
    }
  ],
  "line": 10,
  "name": "assert the consequences of the pattern audit interceptor",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 11,
      "value": "# depends secure logger"
    }
  ],
  "line": 12,
  "name": "assert the consequences of the pattern secure logger",
  "keyword": "Then "
});
formatter.match({
  "location": "sessionhijacking.presessionhijacking()"
});
formatter.result({
  "duration": 54050,
  "status": "passed"
});
formatter.match({
  "location": "sessionhijacking.trysessionhijacking()"
});
formatter.result({
  "duration": 5670,
  "status": "passed"
});
formatter.match({
  "location": "sessionhijacking.asssessionhijacking()"
});
formatter.result({
  "duration": 5397,
  "status": "passed"
});
formatter.match({
  "location": "PatternSteps.assauditinterceptor()"
});
formatter.result({
  "duration": 29729,
  "status": "passed"
});
formatter.match({
  "location": "PatternSteps.asssecurelogger()"
});
formatter.result({
  "duration": 17017,
  "status": "passed"
});
formatter.uri("CAPEC_34_Step_1_1.feature");
formatter.feature({
  "line": 2,
  "name": "CAPEC-34: HTTP Response Splitting",
  "description": "",
  "id": "capec-34:-http-response-splitting",
  "keyword": "Feature",
  "tags": [
    {
      "line": 1,
      "name": "@capec34"
    }
  ]
});
formatter.scenario({
  "comments": [
    {
      "line": 3,
      "value": "#1. Explore"
    }
  ],
  "line": 4,
  "name": "Step1.1 Spider",
  "description": "",
  "id": "capec-34:-http-response-splitting;step1.1-spider",
  "type": "scenario",
  "keyword": "Scenario"
});
formatter.step({
  "line": 5,
  "name": "prepare to Spider",
  "keyword": "Given "
});
formatter.step({
  "line": 6,
  "name": "Try to Spider",
  "keyword": "When "
});
formatter.step({
  "comments": [
    {
      "line": 7,
      "value": "# assertion for attack step success"
    }
  ],
  "line": 8,
  "name": "Assert the success of Spider",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 9,
      "value": "#assertions for security pattern testing (checker whether the pattern consequences are observed)"
    }
  ],
  "line": 10,
  "name": "assert the consequences of the pattern",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 11,
      "value": "#"
    }
  ],
  "line": 12,
  "name": "assert the consequences of the pattern audit interceptor",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 13,
      "value": "# depends secure logger"
    }
  ],
  "line": 14,
  "name": "assert the consequences of the pattern secure logger",
  "keyword": "Then "
});
formatter.match({
  "location": "spider.prespider()"
});
formatter.result({
  "duration": 14377108,
  "error_message": "net.continuumsecurity.proxy.ProxyException: org.zaproxy.clientapi.core.ClientApiException: java.net.ConnectException: Connection refused\n\tat net.continuumsecurity.proxy.ZAProxyScanner.validateMinimumRequiredZapVersion(ZAProxyScanner.java:96)\n\tat net.continuumsecurity.proxy.ZAProxyScanner.\u003cinit\u003e(ZAProxyScanner.java:38)\n\tat steps.spider.prespider(spider.java:17)\n\tat ✽.Given prepare to Spider(CAPEC_34_Step_1_1.feature:5)\nCaused by: org.zaproxy.clientapi.core.ClientApiException: java.net.ConnectException: Connection refused\n\tat org.zaproxy.clientapi.core.ClientApi.callApiDom(ClientApi.java:307)\n\tat org.zaproxy.clientapi.core.ClientApi.callApi(ClientApi.java:289)\n\tat org.zaproxy.clientapi.gen.Core.version(Core.java:158)\n\tat net.continuumsecurity.proxy.ZAProxyScanner.validateMinimumRequiredZapVersion(ZAProxyScanner.java:85)\n\tat net.continuumsecurity.proxy.ZAProxyScanner.\u003cinit\u003e(ZAProxyScanner.java:38)\n\tat steps.spider.prespider(spider.java:17)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.lang.reflect.Method.invoke(Method.java:498)\n\tat cucumber.runtime.Utils$1.call(Utils.java:37)\n\tat cucumber.runtime.Timeout.timeout(Timeout.java:13)\n\tat cucumber.runtime.Utils.invoke(Utils.java:31)\n\tat cucumber.runtime.java.JavaStepDefinition.execute(JavaStepDefinition.java:37)\n\tat cucumber.runtime.StepDefinitionMatch.runStep(StepDefinitionMatch.java:37)\n\tat cucumber.runtime.Runtime.runStep(Runtime.java:298)\n\tat cucumber.runtime.model.StepContainer.runStep(StepContainer.java:44)\n\tat cucumber.runtime.model.StepContainer.runSteps(StepContainer.java:39)\n\tat cucumber.runtime.model.CucumberScenario.run(CucumberScenario.java:48)\n\tat cucumber.runtime.junit.ExecutionUnitRunner.run(ExecutionUnitRunner.java:91)\n\tat cucumber.runtime.junit.FeatureRunner.runChild(FeatureRunner.java:63)\n\tat cucumber.runtime.junit.FeatureRunner.runChild(FeatureRunner.java:18)\n\tat org.junit.runners.ParentRunner$3.run(ParentRunner.java:238)\n\tat org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:63)\n\tat org.junit.runners.ParentRunner.runChildren(ParentRunner.java:236)\n\tat org.junit.runners.ParentRunner.access$000(ParentRunner.java:53)\n\tat org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:229)\n\tat org.junit.runners.ParentRunner.run(ParentRunner.java:309)\n\tat cucumber.runtime.junit.FeatureRunner.run(FeatureRunner.java:70)\n\tat cucumber.api.junit.Cucumber.runChild(Cucumber.java:93)\n\tat cucumber.api.junit.Cucumber.runChild(Cucumber.java:37)\n\tat org.junit.runners.ParentRunner$3.run(ParentRunner.java:238)\n\tat org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:63)\n\tat org.junit.runners.ParentRunner.runChildren(ParentRunner.java:236)\n\tat org.junit.runners.ParentRunner.access$000(ParentRunner.java:53)\n\tat org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:229)\n\tat org.junit.internal.runners.statements.RunAfters.evaluate(RunAfters.java:27)\n\tat org.junit.runners.ParentRunner.run(ParentRunner.java:309)\n\tat cucumber.api.junit.Cucumber.run(Cucumber.java:98)\n\tat org.eclipse.jdt.internal.junit4.runner.JUnit4TestReference.run(JUnit4TestReference.java:86)\n\tat org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:459)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:678)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:382)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:192)\nCaused by: java.net.ConnectException: Connection refused\n\tat java.net.PlainSocketImpl.socketConnect(Native Method)\n\tat java.net.AbstractPlainSocketImpl.doConnect(AbstractPlainSocketImpl.java:350)\n\tat java.net.AbstractPlainSocketImpl.connectToAddress(AbstractPlainSocketImpl.java:206)\n\tat java.net.AbstractPlainSocketImpl.connect(AbstractPlainSocketImpl.java:188)\n\tat java.net.Socket.connect(Socket.java:589)\n\tat java.net.Socket.connect(Socket.java:538)\n\tat sun.net.NetworkClient.doConnect(NetworkClient.java:180)\n\tat sun.net.www.http.HttpClient.openServer(HttpClient.java:432)\n\tat sun.net.www.http.HttpClient$1.run(HttpClient.java:484)\n\tat sun.net.www.http.HttpClient$1.run(HttpClient.java:482)\n\tat java.security.AccessController.doPrivileged(Native Method)\n\tat sun.net.www.http.HttpClient.privilegedOpenServer(HttpClient.java:481)\n\tat sun.net.www.http.HttpClient.openServer(HttpClient.java:522)\n\tat sun.net.www.http.HttpClient.\u003cinit\u003e(HttpClient.java:211)\n\tat sun.net.www.http.HttpClient.New(HttpClient.java:308)\n\tat sun.net.www.http.HttpClient.New(HttpClient.java:326)\n\tat sun.net.www.protocol.http.HttpURLConnection.getNewHttpClient(HttpURLConnection.java:1169)\n\tat sun.net.www.protocol.http.HttpURLConnection.plainConnect0(HttpURLConnection.java:1148)\n\tat sun.net.www.protocol.http.HttpURLConnection.plainConnect(HttpURLConnection.java:999)\n\tat sun.net.www.protocol.http.HttpURLConnection.connect(HttpURLConnection.java:933)\n\tat org.zaproxy.clientapi.core.ClientApi.getConnectionInputStream(ClientApi.java:313)\n\tat org.zaproxy.clientapi.core.ClientApi.callApiDom(ClientApi.java:305)\n\t... 44 more\n",
  "status": "failed"
});
formatter.match({
  "location": "spider.tryspider()"
});
formatter.result({
  "status": "skipped"
});
formatter.match({
  "location": "spider.assspider()"
});
formatter.result({
  "status": "skipped"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({
  "location": "PatternSteps.assauditinterceptor()"
});
formatter.result({
  "status": "skipped"
});
formatter.match({
  "location": "PatternSteps.asssecurelogger()"
});
formatter.result({
  "status": "skipped"
});
formatter.uri("CAPEC_34_Step_2_1.feature");
formatter.feature({
  "line": 2,
  "name": "CAPEC-34: HTTP Response Splitting",
  "description": "",
  "id": "capec-34:-http-response-splitting",
  "keyword": "Feature",
  "tags": [
    {
      "line": 1,
      "name": "@capec34"
    }
  ]
});
formatter.scenario({
  "comments": [
    {
      "line": 3,
      "value": "#2. Experiment"
    }
  ],
  "line": 4,
  "name": "Step2.1 Attempt variations on input parameters",
  "description": "",
  "id": "capec-34:-http-response-splitting;step2.1-attempt-variations-on-input-parameters",
  "type": "scenario",
  "keyword": "Scenario"
});
formatter.step({
  "line": 5,
  "name": "prepare to Attempt variations on input parameters",
  "keyword": "Given "
});
formatter.step({
  "line": 6,
  "name": "Try to Attempt variations on input parameters",
  "keyword": "When "
});
formatter.step({
  "comments": [
    {
      "line": 7,
      "value": "# assertion for attack step success"
    }
  ],
  "line": 8,
  "name": "Assert the success of Attempt variations on input parameters",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 9,
      "value": "#assertions for security pattern testing (checker whether the pattern consequences are observed)"
    }
  ],
  "line": 10,
  "name": "assert the consequences of the pattern audit interceptor",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 11,
      "value": "# depends secure logger"
    }
  ],
  "line": 12,
  "name": "assert the consequences of the pattern secure logger",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 13,
      "value": "# benifits audit interceptor"
    }
  ],
  "line": 14,
  "name": "assert the consequences of the pattern application firewall",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 15,
      "value": "# alternative input guard"
    }
  ],
  "line": 16,
  "name": "assert the consequences of the pattern input guard",
  "keyword": "Then "
});
formatter.match({
  "location": "attemptvariationsoninputparameters.preattemptvariationsoninputparameters()"
});
formatter.result({
  "duration": 1635613,
  "error_message": "net.continuumsecurity.proxy.ProxyException: org.zaproxy.clientapi.core.ClientApiException: java.net.ConnectException: Connection refused\n\tat net.continuumsecurity.proxy.ZAProxyScanner.validateMinimumRequiredZapVersion(ZAProxyScanner.java:96)\n\tat net.continuumsecurity.proxy.ZAProxyScanner.\u003cinit\u003e(ZAProxyScanner.java:38)\n\tat steps.attemptvariationsoninputparameters.preattemptvariationsoninputparameters(attemptvariationsoninputparameters.java:19)\n\tat ✽.Given prepare to Attempt variations on input parameters(CAPEC_34_Step_2_1.feature:5)\nCaused by: org.zaproxy.clientapi.core.ClientApiException: java.net.ConnectException: Connection refused\n\tat org.zaproxy.clientapi.core.ClientApi.callApiDom(ClientApi.java:307)\n\tat org.zaproxy.clientapi.core.ClientApi.callApi(ClientApi.java:289)\n\tat org.zaproxy.clientapi.gen.Core.version(Core.java:158)\n\tat net.continuumsecurity.proxy.ZAProxyScanner.validateMinimumRequiredZapVersion(ZAProxyScanner.java:85)\n\tat net.continuumsecurity.proxy.ZAProxyScanner.\u003cinit\u003e(ZAProxyScanner.java:38)\n\tat steps.attemptvariationsoninputparameters.preattemptvariationsoninputparameters(attemptvariationsoninputparameters.java:19)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.lang.reflect.Method.invoke(Method.java:498)\n\tat cucumber.runtime.Utils$1.call(Utils.java:37)\n\tat cucumber.runtime.Timeout.timeout(Timeout.java:13)\n\tat cucumber.runtime.Utils.invoke(Utils.java:31)\n\tat cucumber.runtime.java.JavaStepDefinition.execute(JavaStepDefinition.java:37)\n\tat cucumber.runtime.StepDefinitionMatch.runStep(StepDefinitionMatch.java:37)\n\tat cucumber.runtime.Runtime.runStep(Runtime.java:298)\n\tat cucumber.runtime.model.StepContainer.runStep(StepContainer.java:44)\n\tat cucumber.runtime.model.StepContainer.runSteps(StepContainer.java:39)\n\tat cucumber.runtime.model.CucumberScenario.run(CucumberScenario.java:48)\n\tat cucumber.runtime.junit.ExecutionUnitRunner.run(ExecutionUnitRunner.java:91)\n\tat cucumber.runtime.junit.FeatureRunner.runChild(FeatureRunner.java:63)\n\tat cucumber.runtime.junit.FeatureRunner.runChild(FeatureRunner.java:18)\n\tat org.junit.runners.ParentRunner$3.run(ParentRunner.java:238)\n\tat org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:63)\n\tat org.junit.runners.ParentRunner.runChildren(ParentRunner.java:236)\n\tat org.junit.runners.ParentRunner.access$000(ParentRunner.java:53)\n\tat org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:229)\n\tat org.junit.runners.ParentRunner.run(ParentRunner.java:309)\n\tat cucumber.runtime.junit.FeatureRunner.run(FeatureRunner.java:70)\n\tat cucumber.api.junit.Cucumber.runChild(Cucumber.java:93)\n\tat cucumber.api.junit.Cucumber.runChild(Cucumber.java:37)\n\tat org.junit.runners.ParentRunner$3.run(ParentRunner.java:238)\n\tat org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:63)\n\tat org.junit.runners.ParentRunner.runChildren(ParentRunner.java:236)\n\tat org.junit.runners.ParentRunner.access$000(ParentRunner.java:53)\n\tat org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:229)\n\tat org.junit.internal.runners.statements.RunAfters.evaluate(RunAfters.java:27)\n\tat org.junit.runners.ParentRunner.run(ParentRunner.java:309)\n\tat cucumber.api.junit.Cucumber.run(Cucumber.java:98)\n\tat org.eclipse.jdt.internal.junit4.runner.JUnit4TestReference.run(JUnit4TestReference.java:86)\n\tat org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:459)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:678)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:382)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:192)\nCaused by: java.net.ConnectException: Connection refused\n\tat java.net.PlainSocketImpl.socketConnect(Native Method)\n\tat java.net.AbstractPlainSocketImpl.doConnect(AbstractPlainSocketImpl.java:350)\n\tat java.net.AbstractPlainSocketImpl.connectToAddress(AbstractPlainSocketImpl.java:206)\n\tat java.net.AbstractPlainSocketImpl.connect(AbstractPlainSocketImpl.java:188)\n\tat java.net.Socket.connect(Socket.java:589)\n\tat java.net.Socket.connect(Socket.java:538)\n\tat sun.net.NetworkClient.doConnect(NetworkClient.java:180)\n\tat sun.net.www.http.HttpClient.openServer(HttpClient.java:432)\n\tat sun.net.www.http.HttpClient$1.run(HttpClient.java:484)\n\tat sun.net.www.http.HttpClient$1.run(HttpClient.java:482)\n\tat java.security.AccessController.doPrivileged(Native Method)\n\tat sun.net.www.http.HttpClient.privilegedOpenServer(HttpClient.java:481)\n\tat sun.net.www.http.HttpClient.openServer(HttpClient.java:522)\n\tat sun.net.www.http.HttpClient.\u003cinit\u003e(HttpClient.java:211)\n\tat sun.net.www.http.HttpClient.New(HttpClient.java:308)\n\tat sun.net.www.http.HttpClient.New(HttpClient.java:326)\n\tat sun.net.www.protocol.http.HttpURLConnection.getNewHttpClient(HttpURLConnection.java:1169)\n\tat sun.net.www.protocol.http.HttpURLConnection.plainConnect0(HttpURLConnection.java:1148)\n\tat sun.net.www.protocol.http.HttpURLConnection.plainConnect(HttpURLConnection.java:999)\n\tat sun.net.www.protocol.http.HttpURLConnection.connect(HttpURLConnection.java:933)\n\tat org.zaproxy.clientapi.core.ClientApi.getConnectionInputStream(ClientApi.java:313)\n\tat org.zaproxy.clientapi.core.ClientApi.callApiDom(ClientApi.java:305)\n\t... 44 more\n",
  "status": "failed"
});
formatter.match({
  "location": "attemptvariationsoninputparameters.tryattemptvariationsoninputparameters()"
});
formatter.result({
  "status": "skipped"
});
formatter.match({
  "location": "attemptvariationsoninputparameters.assattemptvariationsoninputparameters()"
});
formatter.result({
  "status": "skipped"
});
formatter.match({
  "location": "PatternSteps.assauditinterceptor()"
});
formatter.result({
  "status": "skipped"
});
formatter.match({
  "location": "PatternSteps.asssecurelogger()"
});
formatter.result({
  "status": "skipped"
});
formatter.match({
  "location": "PatternSteps.assapplicationfirewall()"
});
formatter.result({
  "status": "skipped"
});
formatter.match({
  "location": "PatternSteps.assinputguard()"
});
formatter.result({
  "status": "skipped"
});
formatter.uri("CAPEC_34_Step_3_1.feature");
formatter.feature({
  "line": 2,
  "name": "CAPEC-34: HTTP Response Splitting",
  "description": "",
  "id": "capec-34:-http-response-splitting",
  "keyword": "Feature",
  "tags": [
    {
      "line": 1,
      "name": "@capec34"
    }
  ]
});
formatter.scenario({
  "comments": [
    {
      "line": 3,
      "value": "#3. Exploit"
    }
  ],
  "line": 4,
  "name": "Step3.1 Cross-Site Scripting",
  "description": "",
  "id": "capec-34:-http-response-splitting;step3.1-cross-site-scripting",
  "type": "scenario",
  "keyword": "Scenario"
});
formatter.step({
  "line": 5,
  "name": "prepare to Cross-Site Scripting",
  "keyword": "Given "
});
formatter.step({
  "line": 6,
  "name": "Try to Cross-Site Scripting",
  "keyword": "When "
});
formatter.step({
  "comments": [
    {
      "line": 7,
      "value": "# assertion for attack step success"
    }
  ],
  "line": 8,
  "name": "Assert the success of Cross-Site Scripting",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 9,
      "value": "#assertions for security pattern testing (checker whether the pattern consequences are observed)"
    }
  ],
  "line": 10,
  "name": "assert the consequences of the pattern audit interceptor",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 11,
      "value": "# depends secure logger"
    }
  ],
  "line": 12,
  "name": "assert the consequences of the pattern secure logger",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 13,
      "value": "# benifits audit interceptor"
    }
  ],
  "line": 14,
  "name": "assert the consequences of the pattern application firewall",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 15,
      "value": "# alternative output guard"
    },
    {
      "line": 16,
      "value": "# alternative input guard"
    }
  ],
  "line": 17,
  "name": "assert the consequences of the pattern input guard",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 18,
      "value": "# alternative application firewall"
    },
    {
      "line": 19,
      "value": "# benifits output guard"
    }
  ],
  "line": 20,
  "name": "assert the consequences of the pattern output guard",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 21,
      "value": "# alternative application firewall"
    },
    {
      "line": 22,
      "value": "# benifits input guard"
    }
  ],
  "line": 23,
  "name": "assert the consequences of the pattern comparator checked fault tolerant system",
  "keyword": "Then "
});
formatter.match({
  "location": "crosssitescripting.precrosssitescripting()"
});
formatter.result({
  "duration": 1417274,
  "error_message": "net.continuumsecurity.proxy.ProxyException: org.zaproxy.clientapi.core.ClientApiException: java.net.ConnectException: Connection refused\n\tat net.continuumsecurity.proxy.ZAProxyScanner.validateMinimumRequiredZapVersion(ZAProxyScanner.java:96)\n\tat net.continuumsecurity.proxy.ZAProxyScanner.\u003cinit\u003e(ZAProxyScanner.java:38)\n\tat steps.crosssitescripting.precrosssitescripting(crosssitescripting.java:15)\n\tat ✽.Given prepare to Cross-Site Scripting(CAPEC_34_Step_3_1.feature:5)\nCaused by: org.zaproxy.clientapi.core.ClientApiException: java.net.ConnectException: Connection refused\n\tat org.zaproxy.clientapi.core.ClientApi.callApiDom(ClientApi.java:307)\n\tat org.zaproxy.clientapi.core.ClientApi.callApi(ClientApi.java:289)\n\tat org.zaproxy.clientapi.gen.Core.version(Core.java:158)\n\tat net.continuumsecurity.proxy.ZAProxyScanner.validateMinimumRequiredZapVersion(ZAProxyScanner.java:85)\n\tat net.continuumsecurity.proxy.ZAProxyScanner.\u003cinit\u003e(ZAProxyScanner.java:38)\n\tat steps.crosssitescripting.precrosssitescripting(crosssitescripting.java:15)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.lang.reflect.Method.invoke(Method.java:498)\n\tat cucumber.runtime.Utils$1.call(Utils.java:37)\n\tat cucumber.runtime.Timeout.timeout(Timeout.java:13)\n\tat cucumber.runtime.Utils.invoke(Utils.java:31)\n\tat cucumber.runtime.java.JavaStepDefinition.execute(JavaStepDefinition.java:37)\n\tat cucumber.runtime.StepDefinitionMatch.runStep(StepDefinitionMatch.java:37)\n\tat cucumber.runtime.Runtime.runStep(Runtime.java:298)\n\tat cucumber.runtime.model.StepContainer.runStep(StepContainer.java:44)\n\tat cucumber.runtime.model.StepContainer.runSteps(StepContainer.java:39)\n\tat cucumber.runtime.model.CucumberScenario.run(CucumberScenario.java:48)\n\tat cucumber.runtime.junit.ExecutionUnitRunner.run(ExecutionUnitRunner.java:91)\n\tat cucumber.runtime.junit.FeatureRunner.runChild(FeatureRunner.java:63)\n\tat cucumber.runtime.junit.FeatureRunner.runChild(FeatureRunner.java:18)\n\tat org.junit.runners.ParentRunner$3.run(ParentRunner.java:238)\n\tat org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:63)\n\tat org.junit.runners.ParentRunner.runChildren(ParentRunner.java:236)\n\tat org.junit.runners.ParentRunner.access$000(ParentRunner.java:53)\n\tat org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:229)\n\tat org.junit.runners.ParentRunner.run(ParentRunner.java:309)\n\tat cucumber.runtime.junit.FeatureRunner.run(FeatureRunner.java:70)\n\tat cucumber.api.junit.Cucumber.runChild(Cucumber.java:93)\n\tat cucumber.api.junit.Cucumber.runChild(Cucumber.java:37)\n\tat org.junit.runners.ParentRunner$3.run(ParentRunner.java:238)\n\tat org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:63)\n\tat org.junit.runners.ParentRunner.runChildren(ParentRunner.java:236)\n\tat org.junit.runners.ParentRunner.access$000(ParentRunner.java:53)\n\tat org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:229)\n\tat org.junit.internal.runners.statements.RunAfters.evaluate(RunAfters.java:27)\n\tat org.junit.runners.ParentRunner.run(ParentRunner.java:309)\n\tat cucumber.api.junit.Cucumber.run(Cucumber.java:98)\n\tat org.eclipse.jdt.internal.junit4.runner.JUnit4TestReference.run(JUnit4TestReference.java:86)\n\tat org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:459)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:678)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:382)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:192)\nCaused by: java.net.ConnectException: Connection refused\n\tat java.net.PlainSocketImpl.socketConnect(Native Method)\n\tat java.net.AbstractPlainSocketImpl.doConnect(AbstractPlainSocketImpl.java:350)\n\tat java.net.AbstractPlainSocketImpl.connectToAddress(AbstractPlainSocketImpl.java:206)\n\tat java.net.AbstractPlainSocketImpl.connect(AbstractPlainSocketImpl.java:188)\n\tat java.net.Socket.connect(Socket.java:589)\n\tat java.net.Socket.connect(Socket.java:538)\n\tat sun.net.NetworkClient.doConnect(NetworkClient.java:180)\n\tat sun.net.www.http.HttpClient.openServer(HttpClient.java:432)\n\tat sun.net.www.http.HttpClient$1.run(HttpClient.java:484)\n\tat sun.net.www.http.HttpClient$1.run(HttpClient.java:482)\n\tat java.security.AccessController.doPrivileged(Native Method)\n\tat sun.net.www.http.HttpClient.privilegedOpenServer(HttpClient.java:481)\n\tat sun.net.www.http.HttpClient.openServer(HttpClient.java:522)\n\tat sun.net.www.http.HttpClient.\u003cinit\u003e(HttpClient.java:211)\n\tat sun.net.www.http.HttpClient.New(HttpClient.java:308)\n\tat sun.net.www.http.HttpClient.New(HttpClient.java:326)\n\tat sun.net.www.protocol.http.HttpURLConnection.getNewHttpClient(HttpURLConnection.java:1169)\n\tat sun.net.www.protocol.http.HttpURLConnection.plainConnect0(HttpURLConnection.java:1148)\n\tat sun.net.www.protocol.http.HttpURLConnection.plainConnect(HttpURLConnection.java:999)\n\tat sun.net.www.protocol.http.HttpURLConnection.connect(HttpURLConnection.java:933)\n\tat org.zaproxy.clientapi.core.ClientApi.getConnectionInputStream(ClientApi.java:313)\n\tat org.zaproxy.clientapi.core.ClientApi.callApiDom(ClientApi.java:305)\n\t... 44 more\n",
  "status": "failed"
});
formatter.match({
  "location": "crosssitescripting.trycrosssitescripting()"
});
formatter.result({
  "status": "skipped"
});
formatter.match({
  "location": "crosssitescripting.asscrosssitescripting()"
});
formatter.result({
  "status": "skipped"
});
formatter.match({
  "location": "PatternSteps.assauditinterceptor()"
});
formatter.result({
  "status": "skipped"
});
formatter.match({
  "location": "PatternSteps.asssecurelogger()"
});
formatter.result({
  "status": "skipped"
});
formatter.match({
  "location": "PatternSteps.assapplicationfirewall()"
});
formatter.result({
  "status": "skipped"
});
formatter.match({
  "location": "PatternSteps.assinputguard()"
});
formatter.result({
  "status": "skipped"
});
formatter.match({
  "location": "PatternSteps.assoutputguard()"
});
formatter.result({
  "status": "skipped"
});
formatter.match({
  "location": "PatternSteps.asscomparatorcheckedfaulttolerantsystem()"
});
formatter.result({
  "status": "skipped"
});
formatter.uri("CAPEC_34_Step_3_2.feature");
formatter.feature({
  "line": 2,
  "name": "CAPEC-34: HTTP Response Splitting",
  "description": "",
  "id": "capec-34:-http-response-splitting",
  "keyword": "Feature",
  "tags": [
    {
      "line": 1,
      "name": "@capec34"
    }
  ]
});
formatter.scenario({
  "comments": [
    {
      "line": 3,
      "value": "#3. Exploit"
    }
  ],
  "line": 4,
  "name": "Step3.2 Cache poisoning",
  "description": "",
  "id": "capec-34:-http-response-splitting;step3.2-cache-poisoning",
  "type": "scenario",
  "keyword": "Scenario"
});
formatter.step({
  "line": 5,
  "name": "prepare to Cache poisoning",
  "keyword": "Given "
});
formatter.step({
  "line": 6,
  "name": "Try to Cache poisoning",
  "keyword": "When "
});
formatter.step({
  "comments": [
    {
      "line": 7,
      "value": "# assertion for attack step success"
    }
  ],
  "line": 8,
  "name": "Assert the success of Cache poisoning",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 9,
      "value": "#assertions for security pattern testing (checker whether the pattern consequences are observed)"
    }
  ],
  "line": 10,
  "name": "assert the consequences of the pattern audit interceptor",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 11,
      "value": "# depends secure logger"
    }
  ],
  "line": 12,
  "name": "assert the consequences of the pattern secure logger",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 13,
      "value": "# benifits audit interceptor"
    }
  ],
  "line": 14,
  "name": "assert the consequences of the pattern application firewall",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 15,
      "value": "# alternative output guard"
    },
    {
      "line": 16,
      "value": "# alternative input guard"
    }
  ],
  "line": 17,
  "name": "assert the consequences of the pattern input guard",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 18,
      "value": "# alternative application firewall"
    },
    {
      "line": 19,
      "value": "# benifits output guard"
    }
  ],
  "line": 20,
  "name": "assert the consequences of the pattern output guard",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 21,
      "value": "# alternative application firewall"
    },
    {
      "line": 22,
      "value": "# benifits input guard"
    }
  ],
  "line": 23,
  "name": "assert the consequences of the pattern comparator checked fault tolerant system",
  "keyword": "Then "
});
formatter.match({
  "location": "cachepoisoning.precachepoisoning()"
});
formatter.result({
  "duration": 27773,
  "status": "passed"
});
formatter.match({
  "location": "cachepoisoning.trycachepoisoning()"
});
formatter.result({
  "duration": 3458,
  "status": "passed"
});
formatter.match({
  "location": "cachepoisoning.asscachepoisoning()"
});
formatter.result({
  "duration": 2934,
  "status": "passed"
});
formatter.match({
  "location": "PatternSteps.assauditinterceptor()"
});
formatter.result({
  "duration": 13071,
  "status": "passed"
});
formatter.match({
  "location": "PatternSteps.asssecurelogger()"
});
formatter.result({
  "duration": 3934,
  "status": "passed"
});
formatter.match({
  "location": "PatternSteps.assapplicationfirewall()"
});
formatter.result({
  "duration": 3537,
  "status": "passed"
});
formatter.match({
  "location": "PatternSteps.assinputguard()"
});
formatter.result({
  "duration": 16404,
  "status": "passed"
});
formatter.match({
  "location": "PatternSteps.assoutputguard()"
});
formatter.result({
  "duration": 7266,
  "status": "passed"
});
formatter.match({
  "location": "PatternSteps.asscomparatorcheckedfaulttolerantsystem()"
});
formatter.result({
  "duration": 6651,
  "status": "passed"
});
formatter.uri("CAPEC_36_Step_1_1.feature");
formatter.feature({
  "line": 2,
  "name": "CAPEC-36: Using Unpublished APIs",
  "description": "",
  "id": "capec-36:-using-unpublished-apis",
  "keyword": "Feature",
  "tags": [
    {
      "line": 1,
      "name": "@capec36"
    }
  ]
});
formatter.scenario({
  "comments": [
    {
      "line": 3,
      "value": "#1. Explore"
    }
  ],
  "line": 4,
  "name": "Step1.1",
  "description": "",
  "id": "capec-36:-using-unpublished-apis;step1.1",
  "type": "scenario",
  "keyword": "Scenario"
});
formatter.step({
  "line": 5,
  "name": "prepare to",
  "keyword": "Given "
});
formatter.step({
  "line": 6,
  "name": "Try to",
  "keyword": "When "
});
formatter.step({
  "comments": [
    {
      "line": 7,
      "value": "# assertion for attack step success"
    }
  ],
  "line": 8,
  "name": "Assert the success of",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 9,
      "value": "#assertions for security pattern testing (checker whether the pattern consequences are observed)"
    }
  ],
  "line": 10,
  "name": "assert the consequences of the pattern",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 11,
      "value": "#"
    }
  ],
  "line": 12,
  "name": "assert the consequences of the pattern audit interceptor",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 13,
      "value": "# depends secure logger"
    }
  ],
  "line": 14,
  "name": "assert the consequences of the pattern secure logger",
  "keyword": "Then "
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({
  "location": "PatternSteps.assauditinterceptor()"
});
formatter.result({
  "status": "skipped"
});
formatter.match({
  "location": "PatternSteps.asssecurelogger()"
});
formatter.result({
  "status": "skipped"
});
formatter.uri("CAPEC_37_Step_1_1.feature");
formatter.feature({
  "line": 2,
  "name": "CAPEC-37: Retrieve Embedded Sensitive Data",
  "description": "",
  "id": "capec-37:-retrieve-embedded-sensitive-data",
  "keyword": "Feature",
  "tags": [
    {
      "line": 1,
      "name": "@capec37"
    }
  ]
});
formatter.scenario({
  "comments": [
    {
      "line": 3,
      "value": "#1. Explore"
    }
  ],
  "line": 4,
  "name": "Step1.1 Identify Target",
  "description": "",
  "id": "capec-37:-retrieve-embedded-sensitive-data;step1.1-identify-target",
  "type": "scenario",
  "keyword": "Scenario"
});
formatter.step({
  "line": 5,
  "name": "prepare to Identify Target",
  "keyword": "Given "
});
formatter.step({
  "line": 6,
  "name": "Try to Identify Target",
  "keyword": "When "
});
formatter.step({
  "comments": [
    {
      "line": 7,
      "value": "# assertion for attack step success"
    }
  ],
  "line": 8,
  "name": "Assert the success of Identify Target",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 9,
      "value": "#assertions for security pattern testing (checker whether the pattern consequences are observed)"
    }
  ],
  "line": 10,
  "name": "assert the consequences of the pattern secure logger",
  "keyword": "Then "
});
formatter.match({
  "location": "identifytarget.preidentifytarget()"
});
formatter.result({
  "duration": 39768,
  "status": "passed"
});
formatter.match({
  "location": "identifytarget.tryidentifytarget()"
});
formatter.result({
  "duration": 6128,
  "status": "passed"
});
formatter.match({
  "location": "identifytarget.assidentifytarget()"
});
formatter.result({
  "duration": 7027,
  "status": "passed"
});
formatter.match({
  "location": "PatternSteps.asssecurelogger()"
});
formatter.result({
  "duration": 26481,
  "status": "passed"
});
formatter.uri("CAPEC_37_Step_2_1.feature");
formatter.feature({
  "line": 2,
  "name": "CAPEC-37: Retrieve Embedded Sensitive Data",
  "description": "",
  "id": "capec-37:-retrieve-embedded-sensitive-data",
  "keyword": "Feature",
  "tags": [
    {
      "line": 1,
      "name": "@capec37"
    }
  ]
});
formatter.scenario({
  "comments": [
    {
      "line": 3,
      "value": "#2. Experiment"
    }
  ],
  "line": 4,
  "name": "Step2.1 Apply mining techniques",
  "description": "",
  "id": "capec-37:-retrieve-embedded-sensitive-data;step2.1-apply-mining-techniques",
  "type": "scenario",
  "keyword": "Scenario"
});
formatter.step({
  "line": 5,
  "name": "prepare to Apply mining techniques",
  "keyword": "Given "
});
formatter.step({
  "line": 6,
  "name": "Try to Apply mining techniques",
  "keyword": "When "
});
formatter.step({
  "comments": [
    {
      "line": 7,
      "value": "# assertion for attack step success"
    }
  ],
  "line": 8,
  "name": "Assert the success of Apply mining techniques",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 9,
      "value": "#assertions for security pattern testing (checker whether the pattern consequences are observed)"
    }
  ],
  "line": 10,
  "name": "assert the consequences of the pattern secure logger",
  "keyword": "Then "
});
formatter.match({
  "location": "applyminingtechniques.preapplyminingtechniques()"
});
formatter.result({
  "duration": 34213,
  "status": "passed"
});
formatter.match({
  "location": "applyminingtechniques.tryapplyminingtechniques()"
});
formatter.result({
  "duration": 4128,
  "status": "passed"
});
formatter.match({
  "location": "applyminingtechniques.assapplyminingtechniques()"
});
formatter.result({
  "duration": 3449,
  "status": "passed"
});
formatter.match({
  "location": "PatternSteps.asssecurelogger()"
});
formatter.result({
  "duration": 23653,
  "status": "passed"
});
formatter.uri("CAPEC_39_Step_1_1.feature");
formatter.feature({
  "line": 2,
  "name": "CAPEC-39: Manipulating Opaque Client-based Data Tokens",
  "description": "",
  "id": "capec-39:-manipulating-opaque-client-based-data-tokens",
  "keyword": "Feature",
  "tags": [
    {
      "line": 1,
      "name": "@capec39"
    }
  ]
});
formatter.scenario({
  "comments": [
    {
      "line": 3,
      "value": "#1. Explore"
    }
  ],
  "line": 4,
  "name": "Step1.1 Enumerate information passed to client side",
  "description": "",
  "id": "capec-39:-manipulating-opaque-client-based-data-tokens;step1.1-enumerate-information-passed-to-client-side",
  "type": "scenario",
  "keyword": "Scenario"
});
formatter.step({
  "line": 5,
  "name": "prepare to Enumerate information passed to client side",
  "keyword": "Given "
});
formatter.step({
  "line": 6,
  "name": "Try to Enumerate information passed to client side",
  "keyword": "When "
});
formatter.step({
  "comments": [
    {
      "line": 7,
      "value": "# assertion for attack step success"
    }
  ],
  "line": 8,
  "name": "Assert the success of Enumerate information passed to client side",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 9,
      "value": "#assertions for security pattern testing (checker whether the pattern consequences are observed)"
    }
  ],
  "line": 10,
  "name": "assert the consequences of the pattern",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 11,
      "value": "#"
    }
  ],
  "line": 12,
  "name": "assert the consequences of the pattern audit interceptor",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 13,
      "value": "# depends secure logger"
    }
  ],
  "line": 14,
  "name": "assert the consequences of the pattern secure logger",
  "keyword": "Then "
});
formatter.match({
  "location": "enumerateinformationpassedtoclientside.preenumerateinformationpassedtoclientside()"
});
formatter.result({
  "duration": 55459,
  "status": "passed"
});
formatter.match({
  "location": "enumerateinformationpassedtoclientside.tryenumerateinformationpassedtoclientside()"
});
formatter.result({
  "duration": 3921,
  "status": "passed"
});
formatter.match({
  "location": "enumerateinformationpassedtoclientside.assenumerateinformationpassedtoclientside()"
});
formatter.result({
  "duration": 3563,
  "status": "passed"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({
  "location": "PatternSteps.assauditinterceptor()"
});
formatter.result({
  "status": "skipped"
});
formatter.match({
  "location": "PatternSteps.asssecurelogger()"
});
formatter.result({
  "status": "skipped"
});
formatter.uri("CAPEC_39_Step_1_2.feature");
formatter.feature({
  "line": 2,
  "name": "CAPEC-39: Manipulating Opaque Client-based Data Tokens",
  "description": "",
  "id": "capec-39:-manipulating-opaque-client-based-data-tokens",
  "keyword": "Feature",
  "tags": [
    {
      "line": 1,
      "name": "@capec39"
    }
  ]
});
formatter.scenario({
  "comments": [
    {
      "line": 3,
      "value": "#1. Explore"
    }
  ],
  "line": 4,
  "name": "Step1.2 Determine protection mechanism for opaque token",
  "description": "",
  "id": "capec-39:-manipulating-opaque-client-based-data-tokens;step1.2-determine-protection-mechanism-for-opaque-token",
  "type": "scenario",
  "keyword": "Scenario"
});
formatter.step({
  "line": 5,
  "name": "prepare to Determine protection mechanism for opaque token",
  "keyword": "Given "
});
formatter.step({
  "line": 6,
  "name": "Try to Determine protection mechanism for opaque token",
  "keyword": "When "
});
formatter.step({
  "comments": [
    {
      "line": 7,
      "value": "# assertion for attack step success"
    }
  ],
  "line": 8,
  "name": "Assert the success of Determine protection mechanism for opaque token",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 9,
      "value": "#assertions for security pattern testing (checker whether the pattern consequences are observed)"
    }
  ],
  "line": 10,
  "name": "assert the consequences of the pattern",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 11,
      "value": "#"
    }
  ],
  "line": 12,
  "name": "assert the consequences of the pattern audit interceptor",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 13,
      "value": "# depends secure logger"
    }
  ],
  "line": 14,
  "name": "assert the consequences of the pattern secure logger",
  "keyword": "Then "
});
formatter.match({
  "location": "determineprotectionmechanismforopaquetoken.predetermineprotectionmechanismforopaquetoken()"
});
formatter.result({
  "duration": 54680,
  "status": "passed"
});
formatter.match({
  "location": "determineprotectionmechanismforopaquetoken.trydetermineprotectionmechanismforopaquetoken()"
});
formatter.result({
  "duration": 3605,
  "status": "passed"
});
formatter.match({
  "location": "determineprotectionmechanismforopaquetoken.assdetermineprotectionmechanismforopaquetoken()"
});
formatter.result({
  "duration": 3352,
  "status": "passed"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({
  "location": "PatternSteps.assauditinterceptor()"
});
formatter.result({
  "status": "skipped"
});
formatter.match({
  "location": "PatternSteps.asssecurelogger()"
});
formatter.result({
  "status": "skipped"
});
formatter.uri("CAPEC_39_Step_2_1.feature");
formatter.feature({
  "line": 2,
  "name": "CAPEC-39: Manipulating Opaque Client-based Data Tokens",
  "description": "",
  "id": "capec-39:-manipulating-opaque-client-based-data-tokens",
  "keyword": "Feature",
  "tags": [
    {
      "line": 1,
      "name": "@capec39"
    }
  ]
});
formatter.scenario({
  "comments": [
    {
      "line": 3,
      "value": "#2. Experiment"
    }
  ],
  "line": 4,
  "name": "Step2.1 Modify parameter/token values",
  "description": "",
  "id": "capec-39:-manipulating-opaque-client-based-data-tokens;step2.1-modify-parameter/token-values",
  "type": "scenario",
  "keyword": "Scenario"
});
formatter.step({
  "line": 5,
  "name": "prepare to Modify parameter/token values",
  "keyword": "Given "
});
formatter.step({
  "line": 6,
  "name": "Try to Modify parameter/token values",
  "keyword": "When "
});
formatter.step({
  "comments": [
    {
      "line": 7,
      "value": "# assertion for attack step success"
    }
  ],
  "line": 8,
  "name": "Assert the success of Modify parameter/token values",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 9,
      "value": "#assertions for security pattern testing (checker whether the pattern consequences are observed)"
    }
  ],
  "line": 10,
  "name": "assert the consequences of the pattern",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 11,
      "value": "#"
    }
  ],
  "line": 12,
  "name": "assert the consequences of the pattern audit interceptor",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 13,
      "value": "# depends secure logger"
    }
  ],
  "line": 14,
  "name": "assert the consequences of the pattern secure logger",
  "keyword": "Then "
});
formatter.match({
  "location": "modifyparametertokenvalues.premodifyparametertokenvalues()"
});
formatter.result({
  "duration": 59501,
  "status": "passed"
});
formatter.match({
  "location": "modifyparametertokenvalues.trymodifyparametertokenvalues()"
});
formatter.result({
  "duration": 3723,
  "status": "passed"
});
formatter.match({
  "location": "modifyparametertokenvalues.assmodifyparametertokenvalues()"
});
formatter.result({
  "duration": 3614,
  "status": "passed"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({
  "location": "PatternSteps.assauditinterceptor()"
});
formatter.result({
  "status": "skipped"
});
formatter.match({
  "location": "PatternSteps.asssecurelogger()"
});
formatter.result({
  "status": "skipped"
});
formatter.uri("CAPEC_39_Step_2_2.feature");
formatter.feature({
  "line": 2,
  "name": "CAPEC-39: Manipulating Opaque Client-based Data Tokens",
  "description": "",
  "id": "capec-39:-manipulating-opaque-client-based-data-tokens",
  "keyword": "Feature",
  "tags": [
    {
      "line": 1,
      "name": "@capec39"
    }
  ]
});
formatter.scenario({
  "comments": [
    {
      "line": 3,
      "value": "#2. Experiment"
    }
  ],
  "line": 4,
  "name": "Step2.2 Cycle through values for each parameter.",
  "description": "",
  "id": "capec-39:-manipulating-opaque-client-based-data-tokens;step2.2-cycle-through-values-for-each-parameter.",
  "type": "scenario",
  "keyword": "Scenario"
});
formatter.step({
  "line": 5,
  "name": "prepare to Cycle through values for each parameter.",
  "keyword": "Given "
});
formatter.step({
  "line": 6,
  "name": "Try to Cycle through values for each parameter.",
  "keyword": "When "
});
formatter.step({
  "comments": [
    {
      "line": 7,
      "value": "# assertion for attack step success"
    }
  ],
  "line": 8,
  "name": "Assert the success of Cycle through values for each parameter.",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 9,
      "value": "#assertions for security pattern testing (checker whether the pattern consequences are observed)"
    }
  ],
  "line": 10,
  "name": "assert the consequences of the pattern",
  "keyword": "Then "
});
formatter.match({
  "location": "cyclethroughvaluesforeachparameter.precyclethroughvaluesforeachparameter()"
});
formatter.result({
  "duration": 52433,
  "status": "passed"
});
formatter.match({
  "location": "cyclethroughvaluesforeachparameter.trycyclethroughvaluesforeachparameter()"
});
formatter.result({
  "duration": 3481,
  "status": "passed"
});
formatter.match({
  "location": "cyclethroughvaluesforeachparameter.asscyclethroughvaluesforeachparameter()"
});
formatter.result({
  "duration": 3887,
  "status": "passed"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.uri("CAPEC_3_Step_1_1.feature");
formatter.feature({
  "line": 2,
  "name": "CAPEC-3: Using Leading \u0027Ghost\u0027 Character Sequences to Bypass Input Filters",
  "description": "",
  "id": "capec-3:-using-leading-\u0027ghost\u0027-character-sequences-to-bypass-input-filters",
  "keyword": "Feature",
  "tags": [
    {
      "line": 1,
      "name": "@capec3"
    }
  ]
});
formatter.scenario({
  "comments": [
    {
      "line": 3,
      "value": "#1. Experiment"
    }
  ],
  "line": 4,
  "name": "Step1.1",
  "description": "",
  "id": "capec-3:-using-leading-\u0027ghost\u0027-character-sequences-to-bypass-input-filters;step1.1",
  "type": "scenario",
  "keyword": "Scenario"
});
formatter.step({
  "line": 5,
  "name": "prepare to",
  "keyword": "Given "
});
formatter.step({
  "line": 6,
  "name": "Try to",
  "keyword": "When "
});
formatter.step({
  "comments": [
    {
      "line": 7,
      "value": "# assertion for attack step success"
    }
  ],
  "line": 8,
  "name": "Assert the success of",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 9,
      "value": "#assertions for security pattern testing (checker whether the pattern consequences are observed)"
    }
  ],
  "line": 10,
  "name": "assert the consequences of the pattern",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 11,
      "value": "#"
    }
  ],
  "line": 12,
  "name": "assert the consequences of the pattern audit interceptor",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 13,
      "value": "# depends secure logger"
    }
  ],
  "line": 14,
  "name": "assert the consequences of the pattern secure logger",
  "keyword": "Then "
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({
  "location": "PatternSteps.assauditinterceptor()"
});
formatter.result({
  "status": "skipped"
});
formatter.match({
  "location": "PatternSteps.asssecurelogger()"
});
formatter.result({
  "status": "skipped"
});
formatter.uri("CAPEC_3_Step_3_1.feature");
formatter.feature({
  "line": 2,
  "name": "CAPEC-3: Using Leading \u0027Ghost\u0027 Character Sequences to Bypass Input Filters",
  "description": "",
  "id": "capec-3:-using-leading-\u0027ghost\u0027-character-sequences-to-bypass-input-filters",
  "keyword": "Feature",
  "tags": [
    {
      "line": 1,
      "name": "@capec3"
    }
  ]
});
formatter.scenario({
  "comments": [
    {
      "line": 3,
      "value": "#3. Exploit"
    }
  ],
  "line": 4,
  "name": "Step3.1",
  "description": "",
  "id": "capec-3:-using-leading-\u0027ghost\u0027-character-sequences-to-bypass-input-filters;step3.1",
  "type": "scenario",
  "keyword": "Scenario"
});
formatter.step({
  "line": 5,
  "name": "prepare to",
  "keyword": "Given "
});
formatter.step({
  "line": 6,
  "name": "Try to",
  "keyword": "When "
});
formatter.step({
  "comments": [
    {
      "line": 7,
      "value": "# assertion for attack step success"
    }
  ],
  "line": 8,
  "name": "Assert the success of",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 9,
      "value": "#assertions for security pattern testing (checker whether the pattern consequences are observed)"
    }
  ],
  "line": 10,
  "name": "assert the consequences of the pattern",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 11,
      "value": "#"
    }
  ],
  "line": 12,
  "name": "assert the consequences of the pattern audit interceptor",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 13,
      "value": "# depends secure logger"
    }
  ],
  "line": 14,
  "name": "assert the consequences of the pattern secure logger",
  "keyword": "Then "
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({
  "location": "PatternSteps.assauditinterceptor()"
});
formatter.result({
  "status": "skipped"
});
formatter.match({
  "location": "PatternSteps.asssecurelogger()"
});
formatter.result({
  "status": "skipped"
});
formatter.uri("CAPEC_41_Step_1_1.feature");
formatter.feature({
  "line": 2,
  "name": "CAPEC-41: Using Meta-characters in E-mail Headers to Inject Malicious Payloads",
  "description": "",
  "id": "capec-41:-using-meta-characters-in-e-mail-headers-to-inject-malicious-payloads",
  "keyword": "Feature",
  "tags": [
    {
      "line": 1,
      "name": "@capec41"
    }
  ]
});
formatter.scenario({
  "comments": [
    {
      "line": 3,
      "value": "#1. Experiment"
    }
  ],
  "line": 4,
  "name": "Step1.1 Identify and characterize metacharacter-processing vulnerabilities in email headers",
  "description": "",
  "id": "capec-41:-using-meta-characters-in-e-mail-headers-to-inject-malicious-payloads;step1.1-identify-and-characterize-metacharacter-processing-vulnerabilities-in-email-headers",
  "type": "scenario",
  "keyword": "Scenario"
});
formatter.step({
  "line": 5,
  "name": "prepare to Identify and characterize metacharacter-processing vulnerabilities in email headers",
  "keyword": "Given "
});
formatter.step({
  "line": 6,
  "name": "Try to Identify and characterize metacharacter-processing vulnerabilities in email headers",
  "keyword": "When "
});
formatter.step({
  "comments": [
    {
      "line": 7,
      "value": "# assertion for attack step success"
    }
  ],
  "line": 8,
  "name": "Assert the success of Identify and characterize metacharacter-processing vulnerabilities in email headers",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 9,
      "value": "#assertions for security pattern testing (checker whether the pattern consequences are observed)"
    }
  ],
  "line": 10,
  "name": "assert the consequences of the pattern application firewall",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 11,
      "value": "# alternative input guard"
    }
  ],
  "line": 12,
  "name": "assert the consequences of the pattern input guard",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 13,
      "value": "# alternative application firewall"
    }
  ],
  "line": 14,
  "name": "assert the consequences of the pattern pathname canonicalization",
  "keyword": "Then "
});
formatter.match({
  "location": "identifyandcharacterizemetacharacterprocessingvulnerabilitiesinemailheaders.preidentifyandcharacterizemetacharacterprocessingvulnerabilitiesinemailheaders()"
});
formatter.result({
  "duration": 55579,
  "status": "passed"
});
formatter.match({
  "location": "identifyandcharacterizemetacharacterprocessingvulnerabilitiesinemailheaders.tryidentifyandcharacterizemetacharacterprocessingvulnerabilitiesinemailheaders()"
});
formatter.result({
  "duration": 14430,
  "status": "passed"
});
formatter.match({
  "location": "identifyandcharacterizemetacharacterprocessingvulnerabilitiesinemailheaders.assidentifyandcharacterizemetacharacterprocessingvulnerabilitiesinemailheaders()"
});
formatter.result({
  "duration": 11181,
  "status": "passed"
});
formatter.match({
  "location": "PatternSteps.assapplicationfirewall()"
});
formatter.result({
  "duration": 19023,
  "status": "passed"
});
formatter.match({
  "location": "PatternSteps.assinputguard()"
});
formatter.result({
  "duration": 3699,
  "status": "passed"
});
formatter.match({
  "location": "PatternSteps.asspathnamecanonicalization()"
});
formatter.result({
  "duration": 3053,
  "status": "passed"
});
formatter.uri("CAPEC_41_Step_2_1.feature");
formatter.feature({
  "line": 2,
  "name": "CAPEC-41: Using Meta-characters in E-mail Headers to Inject Malicious Payloads",
  "description": "",
  "id": "capec-41:-using-meta-characters-in-e-mail-headers-to-inject-malicious-payloads",
  "keyword": "Feature",
  "tags": [
    {
      "line": 1,
      "name": "@capec41"
    }
  ]
});
formatter.scenario({
  "comments": [
    {
      "line": 3,
      "value": "#2. Exploit"
    }
  ],
  "line": 4,
  "name": "Step2.1",
  "description": "",
  "id": "capec-41:-using-meta-characters-in-e-mail-headers-to-inject-malicious-payloads;step2.1",
  "type": "scenario",
  "keyword": "Scenario"
});
formatter.step({
  "line": 5,
  "name": "prepare to",
  "keyword": "Given "
});
formatter.step({
  "line": 6,
  "name": "Try to",
  "keyword": "When "
});
formatter.step({
  "comments": [
    {
      "line": 7,
      "value": "# assertion for attack step success"
    }
  ],
  "line": 8,
  "name": "Assert the success of",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 9,
      "value": "#assertions for security pattern testing (checker whether the pattern consequences are observed)"
    }
  ],
  "line": 10,
  "name": "assert the consequences of the pattern secure logger",
  "keyword": "Then "
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({
  "location": "PatternSteps.asssecurelogger()"
});
formatter.result({
  "status": "skipped"
});
formatter.uri("CAPEC_42_Step_1_1.feature");
formatter.feature({
  "line": 2,
  "name": "CAPEC-42: MIME Conversion",
  "description": "",
  "id": "capec-42:-mime-conversion",
  "keyword": "Feature",
  "tags": [
    {
      "line": 1,
      "name": "@capec42"
    }
  ]
});
formatter.scenario({
  "comments": [
    {
      "line": 3,
      "value": "#1. Explore"
    }
  ],
  "line": 4,
  "name": "Step1.1",
  "description": "",
  "id": "capec-42:-mime-conversion;step1.1",
  "type": "scenario",
  "keyword": "Scenario"
});
formatter.step({
  "line": 5,
  "name": "prepare to",
  "keyword": "Given "
});
formatter.step({
  "line": 6,
  "name": "Try to",
  "keyword": "When "
});
formatter.step({
  "comments": [
    {
      "line": 7,
      "value": "# assertion for attack step success"
    }
  ],
  "line": 8,
  "name": "Assert the success of",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 9,
      "value": "#assertions for security pattern testing (checker whether the pattern consequences are observed)"
    }
  ],
  "line": 10,
  "name": "assert the consequences of the pattern",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 11,
      "value": "#"
    }
  ],
  "line": 12,
  "name": "assert the consequences of the pattern audit interceptor",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 13,
      "value": "# depends secure logger"
    }
  ],
  "line": 14,
  "name": "assert the consequences of the pattern secure logger",
  "keyword": "Then "
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({
  "location": "PatternSteps.assauditinterceptor()"
});
formatter.result({
  "status": "skipped"
});
formatter.match({
  "location": "PatternSteps.asssecurelogger()"
});
formatter.result({
  "status": "skipped"
});
formatter.uri("CAPEC_42_Step_3_1.feature");
formatter.feature({
  "line": 2,
  "name": "CAPEC-42: MIME Conversion",
  "description": "",
  "id": "capec-42:-mime-conversion",
  "keyword": "Feature",
  "tags": [
    {
      "line": 1,
      "name": "@capec42"
    }
  ]
});
formatter.scenario({
  "comments": [
    {
      "line": 3,
      "value": "#3. Exploit"
    }
  ],
  "line": 4,
  "name": "Step3.1",
  "description": "",
  "id": "capec-42:-mime-conversion;step3.1",
  "type": "scenario",
  "keyword": "Scenario"
});
formatter.step({
  "line": 5,
  "name": "prepare to",
  "keyword": "Given "
});
formatter.step({
  "line": 6,
  "name": "Try to",
  "keyword": "When "
});
formatter.step({
  "comments": [
    {
      "line": 7,
      "value": "# assertion for attack step success"
    }
  ],
  "line": 8,
  "name": "Assert the success of",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 9,
      "value": "#assertions for security pattern testing (checker whether the pattern consequences are observed)"
    }
  ],
  "line": 10,
  "name": "assert the consequences of the pattern",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 11,
      "value": "#"
    }
  ],
  "line": 12,
  "name": "assert the consequences of the pattern audit interceptor",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 13,
      "value": "# depends secure logger"
    }
  ],
  "line": 14,
  "name": "assert the consequences of the pattern secure logger",
  "keyword": "Then "
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({
  "location": "PatternSteps.assauditinterceptor()"
});
formatter.result({
  "status": "skipped"
});
formatter.match({
  "location": "PatternSteps.asssecurelogger()"
});
formatter.result({
  "status": "skipped"
});
formatter.uri("CAPEC_43_Step_1_1.feature");
formatter.feature({
  "line": 2,
  "name": "CAPEC-43: Exploiting Multiple Input Interpretation Layers",
  "description": "",
  "id": "capec-43:-exploiting-multiple-input-interpretation-layers",
  "keyword": "Feature",
  "tags": [
    {
      "line": 1,
      "name": "@capec43"
    }
  ]
});
formatter.scenario({
  "comments": [
    {
      "line": 3,
      "value": "#1. Explore"
    }
  ],
  "line": 4,
  "name": "Step1.1 Determine application/system inputs where bypassing input validation is desired",
  "description": "",
  "id": "capec-43:-exploiting-multiple-input-interpretation-layers;step1.1-determine-application/system-inputs-where-bypassing-input-validation-is-desired",
  "type": "scenario",
  "keyword": "Scenario"
});
formatter.step({
  "line": 5,
  "name": "prepare to Determine application/system inputs where bypassing input validation is desired",
  "keyword": "Given "
});
formatter.step({
  "line": 6,
  "name": "Try to Determine application/system inputs where bypassing input validation is desired",
  "keyword": "When "
});
formatter.step({
  "comments": [
    {
      "line": 7,
      "value": "# assertion for attack step success"
    }
  ],
  "line": 8,
  "name": "Assert the success of Determine application/system inputs where bypassing input validation is desired",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 9,
      "value": "#assertions for security pattern testing (checker whether the pattern consequences are observed)"
    }
  ],
  "line": 10,
  "name": "assert the consequences of the pattern",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 11,
      "value": "#"
    }
  ],
  "line": 12,
  "name": "assert the consequences of the pattern audit interceptor",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 13,
      "value": "# depends secure logger"
    }
  ],
  "line": 14,
  "name": "assert the consequences of the pattern secure logger",
  "keyword": "Then "
});
formatter.match({
  "location": "determineapplicationsysteminputswherebypassinginputvalidationisdesired.predetermineapplicationsysteminputswherebypassinginputvalidationisdesired()"
});
formatter.result({
  "duration": 56722,
  "status": "passed"
});
formatter.match({
  "location": "determineapplicationsysteminputswherebypassinginputvalidationisdesired.trydetermineapplicationsysteminputswherebypassinginputvalidationisdesired()"
});
formatter.result({
  "duration": 13424,
  "status": "passed"
});
formatter.match({
  "location": "determineapplicationsysteminputswherebypassinginputvalidationisdesired.assdetermineapplicationsysteminputswherebypassinginputvalidationisdesired()"
});
formatter.result({
  "duration": 3180,
  "status": "passed"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({
  "location": "PatternSteps.assauditinterceptor()"
});
formatter.result({
  "status": "skipped"
});
formatter.match({
  "location": "PatternSteps.asssecurelogger()"
});
formatter.result({
  "status": "skipped"
});
formatter.uri("CAPEC_43_Step_2_1.feature");
formatter.feature({
  "line": 2,
  "name": "CAPEC-43: Exploiting Multiple Input Interpretation Layers",
  "description": "",
  "id": "capec-43:-exploiting-multiple-input-interpretation-layers",
  "keyword": "Feature",
  "tags": [
    {
      "line": 1,
      "name": "@capec43"
    }
  ]
});
formatter.scenario({
  "comments": [
    {
      "line": 3,
      "value": "#2. Experiment"
    }
  ],
  "line": 4,
  "name": "Step2.1 Determine which character encodings are accepted by the application/system",
  "description": "",
  "id": "capec-43:-exploiting-multiple-input-interpretation-layers;step2.1-determine-which-character-encodings-are-accepted-by-the-application/system",
  "type": "scenario",
  "keyword": "Scenario"
});
formatter.step({
  "line": 5,
  "name": "prepare to Determine which character encodings are accepted by the application/system",
  "keyword": "Given "
});
formatter.step({
  "line": 6,
  "name": "Try to Determine which character encodings are accepted by the application/system",
  "keyword": "When "
});
formatter.step({
  "comments": [
    {
      "line": 7,
      "value": "# assertion for attack step success"
    }
  ],
  "line": 8,
  "name": "Assert the success of Determine which character encodings are accepted by the application/system",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 9,
      "value": "#assertions for security pattern testing (checker whether the pattern consequences are observed)"
    }
  ],
  "line": 10,
  "name": "assert the consequences of the pattern audit interceptor",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 11,
      "value": "# depends secure logger"
    }
  ],
  "line": 12,
  "name": "assert the consequences of the pattern secure logger",
  "keyword": "Then "
});
formatter.match({
  "location": "determinewhichcharacterencodingsareacceptedbytheapplicationsystem.predeterminewhichcharacterencodingsareacceptedbytheapplicationsystem()"
});
formatter.result({
  "duration": 62292,
  "status": "passed"
});
formatter.match({
  "location": "determinewhichcharacterencodingsareacceptedbytheapplicationsystem.trydeterminewhichcharacterencodingsareacceptedbytheapplicationsystem()"
});
formatter.result({
  "duration": 3723,
  "status": "passed"
});
formatter.match({
  "location": "determinewhichcharacterencodingsareacceptedbytheapplicationsystem.assdeterminewhichcharacterencodingsareacceptedbytheapplicationsystem()"
});
formatter.result({
  "duration": 3279,
  "status": "passed"
});
formatter.match({
  "location": "PatternSteps.assauditinterceptor()"
});
formatter.result({
  "duration": 18944,
  "status": "passed"
});
formatter.match({
  "location": "PatternSteps.asssecurelogger()"
});
formatter.result({
  "duration": 4287,
  "status": "passed"
});
formatter.uri("CAPEC_43_Step_2_2.feature");
formatter.feature({
  "line": 2,
  "name": "CAPEC-43: Exploiting Multiple Input Interpretation Layers",
  "description": "",
  "id": "capec-43:-exploiting-multiple-input-interpretation-layers",
  "keyword": "Feature",
  "tags": [
    {
      "line": 1,
      "name": "@capec43"
    }
  ]
});
formatter.scenario({
  "comments": [
    {
      "line": 3,
      "value": "#2. Experiment"
    }
  ],
  "line": 4,
  "name": "Step2.2 Combine multiple encodings accepted by the application.",
  "description": "",
  "id": "capec-43:-exploiting-multiple-input-interpretation-layers;step2.2-combine-multiple-encodings-accepted-by-the-application.",
  "type": "scenario",
  "keyword": "Scenario"
});
formatter.step({
  "line": 5,
  "name": "prepare to Combine multiple encodings accepted by the application.",
  "keyword": "Given "
});
formatter.step({
  "line": 6,
  "name": "Try to Combine multiple encodings accepted by the application.",
  "keyword": "When "
});
formatter.step({
  "comments": [
    {
      "line": 7,
      "value": "# assertion for attack step success"
    }
  ],
  "line": 8,
  "name": "Assert the success of Combine multiple encodings accepted by the application.",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 9,
      "value": "#assertions for security pattern testing (checker whether the pattern consequences are observed)"
    }
  ],
  "line": 10,
  "name": "assert the consequences of the pattern secure logger",
  "keyword": "Then "
});
formatter.match({
  "location": "combinemultipleencodingsacceptedbytheapplication.precombinemultipleencodingsacceptedbytheapplication()"
});
formatter.result({
  "duration": 117434,
  "status": "passed"
});
formatter.match({
  "location": "combinemultipleencodingsacceptedbytheapplication.trycombinemultipleencodingsacceptedbytheapplication()"
});
formatter.result({
  "duration": 6950,
  "status": "passed"
});
formatter.match({
  "location": "combinemultipleencodingsacceptedbytheapplication.asscombinemultipleencodingsacceptedbytheapplication()"
});
formatter.result({
  "duration": 4749,
  "status": "passed"
});
formatter.match({
  "location": "PatternSteps.asssecurelogger()"
});
formatter.result({
  "duration": 20007,
  "status": "passed"
});
formatter.uri("CAPEC_43_Step_3_1.feature");
formatter.feature({
  "line": 2,
  "name": "CAPEC-43: Exploiting Multiple Input Interpretation Layers",
  "description": "",
  "id": "capec-43:-exploiting-multiple-input-interpretation-layers",
  "keyword": "Feature",
  "tags": [
    {
      "line": 1,
      "name": "@capec43"
    }
  ]
});
formatter.scenario({
  "comments": [
    {
      "line": 3,
      "value": "#3. Exploit"
    }
  ],
  "line": 4,
  "name": "Step3.1 Leverage ability to bypass input validation",
  "description": "",
  "id": "capec-43:-exploiting-multiple-input-interpretation-layers;step3.1-leverage-ability-to-bypass-input-validation",
  "type": "scenario",
  "keyword": "Scenario"
});
formatter.step({
  "line": 5,
  "name": "prepare to Leverage ability to bypass input validation",
  "keyword": "Given "
});
formatter.step({
  "line": 6,
  "name": "Try to Leverage ability to bypass input validation",
  "keyword": "When "
});
formatter.step({
  "comments": [
    {
      "line": 7,
      "value": "# assertion for attack step success"
    }
  ],
  "line": 8,
  "name": "Assert the success of Leverage ability to bypass input validation",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 9,
      "value": "#assertions for security pattern testing (checker whether the pattern consequences are observed)"
    }
  ],
  "line": 10,
  "name": "assert the consequences of the pattern",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 11,
      "value": "#"
    }
  ],
  "line": 12,
  "name": "assert the consequences of the pattern audit interceptor",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 13,
      "value": "# depends secure logger"
    }
  ],
  "line": 14,
  "name": "assert the consequences of the pattern secure logger",
  "keyword": "Then "
});
formatter.match({
  "location": "leverageabilitytobypassinputvalidation.preleverageabilitytobypassinputvalidation()"
});
formatter.result({
  "duration": 1679097,
  "error_message": "net.continuumsecurity.proxy.ProxyException: org.zaproxy.clientapi.core.ClientApiException: java.net.ConnectException: Connection refused\n\tat net.continuumsecurity.proxy.ZAProxyScanner.validateMinimumRequiredZapVersion(ZAProxyScanner.java:96)\n\tat net.continuumsecurity.proxy.ZAProxyScanner.\u003cinit\u003e(ZAProxyScanner.java:38)\n\tat steps.leverageabilitytobypassinputvalidation.preleverageabilitytobypassinputvalidation(leverageabilitytobypassinputvalidation.java:21)\n\tat ✽.Given prepare to Leverage ability to bypass input validation(CAPEC_43_Step_3_1.feature:5)\nCaused by: org.zaproxy.clientapi.core.ClientApiException: java.net.ConnectException: Connection refused\n\tat org.zaproxy.clientapi.core.ClientApi.callApiDom(ClientApi.java:307)\n\tat org.zaproxy.clientapi.core.ClientApi.callApi(ClientApi.java:289)\n\tat org.zaproxy.clientapi.gen.Core.version(Core.java:158)\n\tat net.continuumsecurity.proxy.ZAProxyScanner.validateMinimumRequiredZapVersion(ZAProxyScanner.java:85)\n\tat net.continuumsecurity.proxy.ZAProxyScanner.\u003cinit\u003e(ZAProxyScanner.java:38)\n\tat steps.leverageabilitytobypassinputvalidation.preleverageabilitytobypassinputvalidation(leverageabilitytobypassinputvalidation.java:21)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.lang.reflect.Method.invoke(Method.java:498)\n\tat cucumber.runtime.Utils$1.call(Utils.java:37)\n\tat cucumber.runtime.Timeout.timeout(Timeout.java:13)\n\tat cucumber.runtime.Utils.invoke(Utils.java:31)\n\tat cucumber.runtime.java.JavaStepDefinition.execute(JavaStepDefinition.java:37)\n\tat cucumber.runtime.StepDefinitionMatch.runStep(StepDefinitionMatch.java:37)\n\tat cucumber.runtime.Runtime.runStep(Runtime.java:298)\n\tat cucumber.runtime.model.StepContainer.runStep(StepContainer.java:44)\n\tat cucumber.runtime.model.StepContainer.runSteps(StepContainer.java:39)\n\tat cucumber.runtime.model.CucumberScenario.run(CucumberScenario.java:48)\n\tat cucumber.runtime.junit.ExecutionUnitRunner.run(ExecutionUnitRunner.java:91)\n\tat cucumber.runtime.junit.FeatureRunner.runChild(FeatureRunner.java:63)\n\tat cucumber.runtime.junit.FeatureRunner.runChild(FeatureRunner.java:18)\n\tat org.junit.runners.ParentRunner$3.run(ParentRunner.java:238)\n\tat org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:63)\n\tat org.junit.runners.ParentRunner.runChildren(ParentRunner.java:236)\n\tat org.junit.runners.ParentRunner.access$000(ParentRunner.java:53)\n\tat org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:229)\n\tat org.junit.runners.ParentRunner.run(ParentRunner.java:309)\n\tat cucumber.runtime.junit.FeatureRunner.run(FeatureRunner.java:70)\n\tat cucumber.api.junit.Cucumber.runChild(Cucumber.java:93)\n\tat cucumber.api.junit.Cucumber.runChild(Cucumber.java:37)\n\tat org.junit.runners.ParentRunner$3.run(ParentRunner.java:238)\n\tat org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:63)\n\tat org.junit.runners.ParentRunner.runChildren(ParentRunner.java:236)\n\tat org.junit.runners.ParentRunner.access$000(ParentRunner.java:53)\n\tat org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:229)\n\tat org.junit.internal.runners.statements.RunAfters.evaluate(RunAfters.java:27)\n\tat org.junit.runners.ParentRunner.run(ParentRunner.java:309)\n\tat cucumber.api.junit.Cucumber.run(Cucumber.java:98)\n\tat org.eclipse.jdt.internal.junit4.runner.JUnit4TestReference.run(JUnit4TestReference.java:86)\n\tat org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:459)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:678)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:382)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:192)\nCaused by: java.net.ConnectException: Connection refused\n\tat java.net.PlainSocketImpl.socketConnect(Native Method)\n\tat java.net.AbstractPlainSocketImpl.doConnect(AbstractPlainSocketImpl.java:350)\n\tat java.net.AbstractPlainSocketImpl.connectToAddress(AbstractPlainSocketImpl.java:206)\n\tat java.net.AbstractPlainSocketImpl.connect(AbstractPlainSocketImpl.java:188)\n\tat java.net.Socket.connect(Socket.java:589)\n\tat java.net.Socket.connect(Socket.java:538)\n\tat sun.net.NetworkClient.doConnect(NetworkClient.java:180)\n\tat sun.net.www.http.HttpClient.openServer(HttpClient.java:432)\n\tat sun.net.www.http.HttpClient$1.run(HttpClient.java:484)\n\tat sun.net.www.http.HttpClient$1.run(HttpClient.java:482)\n\tat java.security.AccessController.doPrivileged(Native Method)\n\tat sun.net.www.http.HttpClient.privilegedOpenServer(HttpClient.java:481)\n\tat sun.net.www.http.HttpClient.openServer(HttpClient.java:522)\n\tat sun.net.www.http.HttpClient.\u003cinit\u003e(HttpClient.java:211)\n\tat sun.net.www.http.HttpClient.New(HttpClient.java:308)\n\tat sun.net.www.http.HttpClient.New(HttpClient.java:326)\n\tat sun.net.www.protocol.http.HttpURLConnection.getNewHttpClient(HttpURLConnection.java:1169)\n\tat sun.net.www.protocol.http.HttpURLConnection.plainConnect0(HttpURLConnection.java:1148)\n\tat sun.net.www.protocol.http.HttpURLConnection.plainConnect(HttpURLConnection.java:999)\n\tat sun.net.www.protocol.http.HttpURLConnection.connect(HttpURLConnection.java:933)\n\tat org.zaproxy.clientapi.core.ClientApi.getConnectionInputStream(ClientApi.java:313)\n\tat org.zaproxy.clientapi.core.ClientApi.callApiDom(ClientApi.java:305)\n\t... 44 more\n",
  "status": "failed"
});
formatter.match({
  "location": "leverageabilitytobypassinputvalidation.tryleverageabilitytobypassinputvalidation()"
});
formatter.result({
  "status": "skipped"
});
formatter.match({
  "location": "leverageabilitytobypassinputvalidation.assleverageabilitytobypassinputvalidation()"
});
formatter.result({
  "status": "skipped"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({
  "location": "PatternSteps.assauditinterceptor()"
});
formatter.result({
  "status": "skipped"
});
formatter.match({
  "location": "PatternSteps.asssecurelogger()"
});
formatter.result({
  "status": "skipped"
});
formatter.uri("CAPEC_45_Step_1_1.feature");
formatter.feature({
  "line": 2,
  "name": "CAPEC-45: Buffer Overflow via Symbolic Links",
  "description": "",
  "id": "capec-45:-buffer-overflow-via-symbolic-links",
  "keyword": "Feature",
  "tags": [
    {
      "line": 1,
      "name": "@capec45"
    }
  ]
});
formatter.scenario({
  "comments": [
    {
      "line": 3,
      "value": "#1. Exploit"
    }
  ],
  "line": 4,
  "name": "Step1.1",
  "description": "",
  "id": "capec-45:-buffer-overflow-via-symbolic-links;step1.1",
  "type": "scenario",
  "keyword": "Scenario"
});
formatter.step({
  "line": 5,
  "name": "prepare to",
  "keyword": "Given "
});
formatter.step({
  "line": 6,
  "name": "Try to",
  "keyword": "When "
});
formatter.step({
  "comments": [
    {
      "line": 7,
      "value": "# assertion for attack step success"
    }
  ],
  "line": 8,
  "name": "Assert the success of",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 9,
      "value": "#assertions for security pattern testing (checker whether the pattern consequences are observed)"
    }
  ],
  "line": 10,
  "name": "assert the consequences of the pattern",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 11,
      "value": "#"
    }
  ],
  "line": 12,
  "name": "assert the consequences of the pattern audit interceptor",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 13,
      "value": "# depends secure logger"
    }
  ],
  "line": 14,
  "name": "assert the consequences of the pattern secure logger",
  "keyword": "Then "
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({
  "location": "PatternSteps.assauditinterceptor()"
});
formatter.result({
  "status": "skipped"
});
formatter.match({
  "location": "PatternSteps.asssecurelogger()"
});
formatter.result({
  "status": "skipped"
});
formatter.uri("CAPEC_46_Step_1_1.feature");
formatter.feature({
  "line": 2,
  "name": "CAPEC-46: Overflow Variables and Tags",
  "description": "",
  "id": "capec-46:-overflow-variables-and-tags",
  "keyword": "Feature",
  "tags": [
    {
      "line": 1,
      "name": "@capec46"
    }
  ]
});
formatter.scenario({
  "comments": [
    {
      "line": 3,
      "value": "#1. Experiment"
    }
  ],
  "line": 4,
  "name": "Step1.1",
  "description": "",
  "id": "capec-46:-overflow-variables-and-tags;step1.1",
  "type": "scenario",
  "keyword": "Scenario"
});
formatter.step({
  "line": 5,
  "name": "prepare to",
  "keyword": "Given "
});
formatter.step({
  "line": 6,
  "name": "Try to",
  "keyword": "When "
});
formatter.step({
  "comments": [
    {
      "line": 7,
      "value": "# assertion for attack step success"
    }
  ],
  "line": 8,
  "name": "Assert the success of",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 9,
      "value": "#assertions for security pattern testing (checker whether the pattern consequences are observed)"
    }
  ],
  "line": 10,
  "name": "assert the consequences of the pattern",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 11,
      "value": "#"
    }
  ],
  "line": 12,
  "name": "assert the consequences of the pattern audit interceptor",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 13,
      "value": "# depends secure logger"
    }
  ],
  "line": 14,
  "name": "assert the consequences of the pattern secure logger",
  "keyword": "Then "
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({
  "location": "PatternSteps.assauditinterceptor()"
});
formatter.result({
  "status": "skipped"
});
formatter.match({
  "location": "PatternSteps.asssecurelogger()"
});
formatter.result({
  "status": "skipped"
});
formatter.uri("CAPEC_46_Step_2_1.feature");
formatter.feature({
  "line": 2,
  "name": "CAPEC-46: Overflow Variables and Tags",
  "description": "",
  "id": "capec-46:-overflow-variables-and-tags",
  "keyword": "Feature",
  "tags": [
    {
      "line": 1,
      "name": "@capec46"
    }
  ]
});
formatter.scenario({
  "comments": [
    {
      "line": 3,
      "value": "#2. Exploit"
    }
  ],
  "line": 4,
  "name": "Step2.1",
  "description": "",
  "id": "capec-46:-overflow-variables-and-tags;step2.1",
  "type": "scenario",
  "keyword": "Scenario"
});
formatter.step({
  "line": 5,
  "name": "prepare to",
  "keyword": "Given "
});
formatter.step({
  "line": 6,
  "name": "Try to",
  "keyword": "When "
});
formatter.step({
  "comments": [
    {
      "line": 7,
      "value": "# assertion for attack step success"
    }
  ],
  "line": 8,
  "name": "Assert the success of",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 9,
      "value": "#assertions for security pattern testing (checker whether the pattern consequences are observed)"
    }
  ],
  "line": 10,
  "name": "assert the consequences of the pattern",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 11,
      "value": "#"
    }
  ],
  "line": 12,
  "name": "assert the consequences of the pattern audit interceptor",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 13,
      "value": "# depends secure logger"
    }
  ],
  "line": 14,
  "name": "assert the consequences of the pattern secure logger",
  "keyword": "Then "
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({
  "location": "PatternSteps.assauditinterceptor()"
});
formatter.result({
  "status": "skipped"
});
formatter.match({
  "location": "PatternSteps.asssecurelogger()"
});
formatter.result({
  "status": "skipped"
});
formatter.uri("CAPEC_47_Step_1_1.feature");
formatter.feature({
  "line": 2,
  "name": "CAPEC-47: Buffer Overflow via Parameter Expansion",
  "description": "",
  "id": "capec-47:-buffer-overflow-via-parameter-expansion",
  "keyword": "Feature",
  "tags": [
    {
      "line": 1,
      "name": "@capec47"
    }
  ]
});
formatter.scenario({
  "comments": [
    {
      "line": 3,
      "value": "#1. Explore"
    }
  ],
  "line": 4,
  "name": "Step1.1",
  "description": "",
  "id": "capec-47:-buffer-overflow-via-parameter-expansion;step1.1",
  "type": "scenario",
  "keyword": "Scenario"
});
formatter.step({
  "line": 5,
  "name": "prepare to",
  "keyword": "Given "
});
formatter.step({
  "line": 6,
  "name": "Try to",
  "keyword": "When "
});
formatter.step({
  "comments": [
    {
      "line": 7,
      "value": "# assertion for attack step success"
    }
  ],
  "line": 8,
  "name": "Assert the success of",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 9,
      "value": "#assertions for security pattern testing (checker whether the pattern consequences are observed)"
    }
  ],
  "line": 10,
  "name": "assert the consequences of the pattern",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 11,
      "value": "#"
    }
  ],
  "line": 12,
  "name": "assert the consequences of the pattern audit interceptor",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 13,
      "value": "# depends secure logger"
    }
  ],
  "line": 14,
  "name": "assert the consequences of the pattern secure logger",
  "keyword": "Then "
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({
  "location": "PatternSteps.assauditinterceptor()"
});
formatter.result({
  "status": "skipped"
});
formatter.match({
  "location": "PatternSteps.asssecurelogger()"
});
formatter.result({
  "status": "skipped"
});
formatter.uri("CAPEC_47_Step_3_1.feature");
formatter.feature({
  "line": 2,
  "name": "CAPEC-47: Buffer Overflow via Parameter Expansion",
  "description": "",
  "id": "capec-47:-buffer-overflow-via-parameter-expansion",
  "keyword": "Feature",
  "tags": [
    {
      "line": 1,
      "name": "@capec47"
    }
  ]
});
formatter.scenario({
  "comments": [
    {
      "line": 3,
      "value": "#3. Exploit"
    }
  ],
  "line": 4,
  "name": "Step3.1",
  "description": "",
  "id": "capec-47:-buffer-overflow-via-parameter-expansion;step3.1",
  "type": "scenario",
  "keyword": "Scenario"
});
formatter.step({
  "line": 5,
  "name": "prepare to",
  "keyword": "Given "
});
formatter.step({
  "line": 6,
  "name": "Try to",
  "keyword": "When "
});
formatter.step({
  "comments": [
    {
      "line": 7,
      "value": "# assertion for attack step success"
    }
  ],
  "line": 8,
  "name": "Assert the success of",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 9,
      "value": "#assertions for security pattern testing (checker whether the pattern consequences are observed)"
    }
  ],
  "line": 10,
  "name": "assert the consequences of the pattern",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 11,
      "value": "#"
    }
  ],
  "line": 12,
  "name": "assert the consequences of the pattern audit interceptor",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 13,
      "value": "# depends secure logger"
    }
  ],
  "line": 14,
  "name": "assert the consequences of the pattern secure logger",
  "keyword": "Then "
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({
  "location": "PatternSteps.assauditinterceptor()"
});
formatter.result({
  "status": "skipped"
});
formatter.match({
  "location": "PatternSteps.asssecurelogger()"
});
formatter.result({
  "status": "skipped"
});
formatter.uri("CAPEC_484_Step_1_1.feature");
formatter.feature({
  "line": 2,
  "name": "CAPEC-484: XML Client-Side Attack",
  "description": "",
  "id": "capec-484:-xml-client-side-attack",
  "keyword": "Feature",
  "tags": [
    {
      "line": 1,
      "name": "@capec484"
    }
  ]
});
formatter.scenario({
  "comments": [
    {
      "line": 3,
      "value": "#1. Explore"
    }
  ],
  "line": 4,
  "name": "Step1.1",
  "description": "",
  "id": "capec-484:-xml-client-side-attack;step1.1",
  "type": "scenario",
  "keyword": "Scenario"
});
formatter.step({
  "line": 5,
  "name": "prepare to",
  "keyword": "Given "
});
formatter.step({
  "line": 6,
  "name": "Try to",
  "keyword": "When "
});
formatter.step({
  "comments": [
    {
      "line": 7,
      "value": "# assertion for attack step success"
    }
  ],
  "line": 8,
  "name": "Assert the success of",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 9,
      "value": "#assertions for security pattern testing (checker whether the pattern consequences are observed)"
    }
  ],
  "line": 10,
  "name": "assert the consequences of the pattern",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 11,
      "value": "#"
    }
  ],
  "line": 12,
  "name": "assert the consequences of the pattern audit interceptor",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 13,
      "value": "# depends secure logger"
    }
  ],
  "line": 14,
  "name": "assert the consequences of the pattern secure logger",
  "keyword": "Then "
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({
  "location": "PatternSteps.assauditinterceptor()"
});
formatter.result({
  "status": "skipped"
});
formatter.match({
  "location": "PatternSteps.asssecurelogger()"
});
formatter.result({
  "status": "skipped"
});
formatter.uri("CAPEC_484_Step_2_1.feature");
formatter.feature({
  "line": 2,
  "name": "CAPEC-484: XML Client-Side Attack",
  "description": "",
  "id": "capec-484:-xml-client-side-attack",
  "keyword": "Feature",
  "tags": [
    {
      "line": 1,
      "name": "@capec484"
    }
  ]
});
formatter.scenario({
  "comments": [
    {
      "line": 3,
      "value": "#2. Experiment"
    }
  ],
  "line": 4,
  "name": "Step2.1",
  "description": "",
  "id": "capec-484:-xml-client-side-attack;step2.1",
  "type": "scenario",
  "keyword": "Scenario"
});
formatter.step({
  "line": 5,
  "name": "prepare to",
  "keyword": "Given "
});
formatter.step({
  "line": 6,
  "name": "Try to",
  "keyword": "When "
});
formatter.step({
  "comments": [
    {
      "line": 7,
      "value": "# assertion for attack step success"
    }
  ],
  "line": 8,
  "name": "Assert the success of",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 9,
      "value": "#assertions for security pattern testing (checker whether the pattern consequences are observed)"
    }
  ],
  "line": 10,
  "name": "assert the consequences of the pattern",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 11,
      "value": "#"
    }
  ],
  "line": 12,
  "name": "assert the consequences of the pattern audit interceptor",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 13,
      "value": "# depends secure logger"
    }
  ],
  "line": 14,
  "name": "assert the consequences of the pattern secure logger",
  "keyword": "Then "
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({
  "location": "PatternSteps.assauditinterceptor()"
});
formatter.result({
  "status": "skipped"
});
formatter.match({
  "location": "PatternSteps.asssecurelogger()"
});
formatter.result({
  "status": "skipped"
});
formatter.uri("CAPEC_49_Step_1_1.feature");
formatter.feature({
  "line": 2,
  "name": "CAPEC-49: Password Brute Forcing",
  "description": "",
  "id": "capec-49:-password-brute-forcing",
  "keyword": "Feature",
  "tags": [
    {
      "line": 1,
      "name": "@capec49"
    }
  ]
});
formatter.scenario({
  "comments": [
    {
      "line": 3,
      "value": "#1. Explore"
    }
  ],
  "line": 4,
  "name": "Step1.1 Determine application\u0027s/system\u0027s password policy",
  "description": "",
  "id": "capec-49:-password-brute-forcing;step1.1-determine-application\u0027s/system\u0027s-password-policy",
  "type": "scenario",
  "keyword": "Scenario"
});
formatter.step({
  "line": 5,
  "name": "prepare to Determine application\u0027s/system\u0027s password policy",
  "keyword": "Given "
});
formatter.step({
  "line": 6,
  "name": "Try to Determine application\u0027s/system\u0027s password policy",
  "keyword": "When "
});
formatter.step({
  "comments": [
    {
      "line": 7,
      "value": "# assertion for attack step success"
    }
  ],
  "line": 8,
  "name": "Assert the success of Determine application\u0027s/system\u0027s password policy",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 9,
      "value": "#assertions for security pattern testing (checker whether the pattern consequences are observed)"
    }
  ],
  "line": 10,
  "name": "assert the consequences of the pattern",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 11,
      "value": "#"
    }
  ],
  "line": 12,
  "name": "assert the consequences of the pattern audit interceptor",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 13,
      "value": "# depends secure logger"
    }
  ],
  "line": 14,
  "name": "assert the consequences of the pattern secure logger",
  "keyword": "Then "
});
formatter.match({
  "location": "determineapplicationssystemspasswordpolicy.predetermineapplicationssystemspasswordpolicy()"
});
formatter.result({
  "duration": 28719,
  "status": "passed"
});
formatter.match({
  "location": "determineapplicationssystemspasswordpolicy.trydetermineapplicationssystemspasswordpolicy()"
});
formatter.result({
  "duration": 3075,
  "status": "passed"
});
formatter.match({
  "location": "determineapplicationssystemspasswordpolicy.assdetermineapplicationssystemspasswordpolicy()"
});
formatter.result({
  "duration": 3185,
  "status": "passed"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({
  "location": "PatternSteps.assauditinterceptor()"
});
formatter.result({
  "status": "skipped"
});
formatter.match({
  "location": "PatternSteps.asssecurelogger()"
});
formatter.result({
  "status": "skipped"
});
formatter.uri("CAPEC_49_Step_2_1.feature");
formatter.feature({
  "line": 2,
  "name": "CAPEC-49: Password Brute Forcing",
  "description": "",
  "id": "capec-49:-password-brute-forcing",
  "keyword": "Feature",
  "tags": [
    {
      "line": 1,
      "name": "@capec49"
    }
  ]
});
formatter.scenario({
  "comments": [
    {
      "line": 3,
      "value": "#2. Exploit"
    }
  ],
  "line": 4,
  "name": "Step2.1 Brute force password",
  "description": "",
  "id": "capec-49:-password-brute-forcing;step2.1-brute-force-password",
  "type": "scenario",
  "keyword": "Scenario"
});
formatter.step({
  "line": 5,
  "name": "prepare to Brute force password",
  "keyword": "Given "
});
formatter.step({
  "line": 6,
  "name": "Try to Brute force password",
  "keyword": "When "
});
formatter.step({
  "comments": [
    {
      "line": 7,
      "value": "# assertion for attack step success"
    }
  ],
  "line": 8,
  "name": "Assert the success of Brute force password",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 9,
      "value": "#assertions for security pattern testing (checker whether the pattern consequences are observed)"
    }
  ],
  "line": 10,
  "name": "assert the consequences of the pattern secure logger",
  "keyword": "Then "
});
formatter.step({
  "line": 11,
  "name": "assert the consequences of the pattern",
  "keyword": "Then "
});
formatter.match({
  "location": "bruteforcepassword.prebruteforcepassword()"
});
formatter.result({
  "duration": 69641,
  "status": "passed"
});
formatter.match({
  "location": "bruteforcepassword.trybruteforcepassword()"
});
formatter.result({
  "duration": 5638,
  "status": "passed"
});
formatter.match({
  "location": "bruteforcepassword.assbruteforcepassword()"
});
formatter.result({
  "duration": 4887,
  "status": "passed"
});
formatter.match({
  "location": "PatternSteps.asssecurelogger()"
});
formatter.result({
  "duration": 26645,
  "status": "passed"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.uri("CAPEC_50_Step_1_1.feature");
formatter.feature({
  "line": 2,
  "name": "CAPEC-50: Password Recovery Exploitation",
  "description": "",
  "id": "capec-50:-password-recovery-exploitation",
  "keyword": "Feature",
  "tags": [
    {
      "line": 1,
      "name": "@capec50"
    }
  ]
});
formatter.scenario({
  "comments": [
    {
      "line": 3,
      "value": "#1. Explore"
    }
  ],
  "line": 4,
  "name": "Step1.1",
  "description": "",
  "id": "capec-50:-password-recovery-exploitation;step1.1",
  "type": "scenario",
  "keyword": "Scenario"
});
formatter.step({
  "line": 5,
  "name": "prepare to",
  "keyword": "Given "
});
formatter.step({
  "line": 6,
  "name": "Try to",
  "keyword": "When "
});
formatter.step({
  "comments": [
    {
      "line": 7,
      "value": "# assertion for attack step success"
    }
  ],
  "line": 8,
  "name": "Assert the success of",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 9,
      "value": "#assertions for security pattern testing (checker whether the pattern consequences are observed)"
    }
  ],
  "line": 10,
  "name": "assert the consequences of the pattern",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 11,
      "value": "#"
    }
  ],
  "line": 12,
  "name": "assert the consequences of the pattern audit interceptor",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 13,
      "value": "# depends secure logger"
    }
  ],
  "line": 14,
  "name": "assert the consequences of the pattern secure logger",
  "keyword": "Then "
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({
  "location": "PatternSteps.assauditinterceptor()"
});
formatter.result({
  "status": "skipped"
});
formatter.match({
  "location": "PatternSteps.asssecurelogger()"
});
formatter.result({
  "status": "skipped"
});
formatter.uri("CAPEC_50_Step_2_1.feature");
formatter.feature({
  "line": 2,
  "name": "CAPEC-50: Password Recovery Exploitation",
  "description": "",
  "id": "capec-50:-password-recovery-exploitation",
  "keyword": "Feature",
  "tags": [
    {
      "line": 1,
      "name": "@capec50"
    }
  ]
});
formatter.scenario({
  "comments": [
    {
      "line": 3,
      "value": "#2. Exploit"
    }
  ],
  "line": 4,
  "name": "Step2.1",
  "description": "",
  "id": "capec-50:-password-recovery-exploitation;step2.1",
  "type": "scenario",
  "keyword": "Scenario"
});
formatter.step({
  "line": 5,
  "name": "prepare to",
  "keyword": "Given "
});
formatter.step({
  "line": 6,
  "name": "Try to",
  "keyword": "When "
});
formatter.step({
  "comments": [
    {
      "line": 7,
      "value": "# assertion for attack step success"
    }
  ],
  "line": 8,
  "name": "Assert the success of",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 9,
      "value": "#assertions for security pattern testing (checker whether the pattern consequences are observed)"
    }
  ],
  "line": 10,
  "name": "assert the consequences of the pattern",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 11,
      "value": "#"
    }
  ],
  "line": 12,
  "name": "assert the consequences of the pattern audit interceptor",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 13,
      "value": "# depends secure logger"
    }
  ],
  "line": 14,
  "name": "assert the consequences of the pattern secure logger",
  "keyword": "Then "
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({
  "location": "PatternSteps.assauditinterceptor()"
});
formatter.result({
  "status": "skipped"
});
formatter.match({
  "location": "PatternSteps.asssecurelogger()"
});
formatter.result({
  "status": "skipped"
});
formatter.uri("CAPEC_52_Step_1_1.feature");
formatter.feature({
  "line": 2,
  "name": "CAPEC-52: Embedding NULL Bytes",
  "description": "",
  "id": "capec-52:-embedding-null-bytes",
  "keyword": "Feature",
  "tags": [
    {
      "line": 1,
      "name": "@capec52"
    }
  ]
});
formatter.scenario({
  "comments": [
    {
      "line": 3,
      "value": "#1. Explore"
    }
  ],
  "line": 4,
  "name": "Step1.1",
  "description": "",
  "id": "capec-52:-embedding-null-bytes;step1.1",
  "type": "scenario",
  "keyword": "Scenario"
});
formatter.step({
  "line": 5,
  "name": "prepare to",
  "keyword": "Given "
});
formatter.step({
  "line": 6,
  "name": "Try to",
  "keyword": "When "
});
formatter.step({
  "comments": [
    {
      "line": 7,
      "value": "# assertion for attack step success"
    }
  ],
  "line": 8,
  "name": "Assert the success of",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 9,
      "value": "#assertions for security pattern testing (checker whether the pattern consequences are observed)"
    }
  ],
  "line": 10,
  "name": "assert the consequences of the pattern",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 11,
      "value": "#"
    }
  ],
  "line": 12,
  "name": "assert the consequences of the pattern audit interceptor",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 13,
      "value": "# depends secure logger"
    }
  ],
  "line": 14,
  "name": "assert the consequences of the pattern secure logger",
  "keyword": "Then "
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({
  "location": "PatternSteps.assauditinterceptor()"
});
formatter.result({
  "status": "skipped"
});
formatter.match({
  "location": "PatternSteps.asssecurelogger()"
});
formatter.result({
  "status": "skipped"
});
formatter.uri("CAPEC_52_Step_2_1.feature");
formatter.feature({
  "line": 2,
  "name": "CAPEC-52: Embedding NULL Bytes",
  "description": "",
  "id": "capec-52:-embedding-null-bytes",
  "keyword": "Feature",
  "tags": [
    {
      "line": 1,
      "name": "@capec52"
    }
  ]
});
formatter.scenario({
  "comments": [
    {
      "line": 3,
      "value": "#2. Exploit"
    }
  ],
  "line": 4,
  "name": "Step2.1",
  "description": "",
  "id": "capec-52:-embedding-null-bytes;step2.1",
  "type": "scenario",
  "keyword": "Scenario"
});
formatter.step({
  "line": 5,
  "name": "prepare to",
  "keyword": "Given "
});
formatter.step({
  "line": 6,
  "name": "Try to",
  "keyword": "When "
});
formatter.step({
  "comments": [
    {
      "line": 7,
      "value": "# assertion for attack step success"
    }
  ],
  "line": 8,
  "name": "Assert the success of",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 9,
      "value": "#assertions for security pattern testing (checker whether the pattern consequences are observed)"
    }
  ],
  "line": 10,
  "name": "assert the consequences of the pattern",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 11,
      "value": "#"
    }
  ],
  "line": 12,
  "name": "assert the consequences of the pattern audit interceptor",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 13,
      "value": "# depends secure logger"
    }
  ],
  "line": 14,
  "name": "assert the consequences of the pattern secure logger",
  "keyword": "Then "
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({
  "location": "PatternSteps.assauditinterceptor()"
});
formatter.result({
  "status": "skipped"
});
formatter.match({
  "location": "PatternSteps.asssecurelogger()"
});
formatter.result({
  "status": "skipped"
});
formatter.uri("CAPEC_53_Step_1_1.feature");
formatter.feature({
  "line": 2,
  "name": "CAPEC-53: Postfix, Null Terminate, and Backslash",
  "description": "",
  "id": "capec-53:-postfix,-null-terminate,-and-backslash",
  "keyword": "Feature",
  "tags": [
    {
      "line": 1,
      "name": "@capec53"
    }
  ]
});
formatter.scenario({
  "comments": [
    {
      "line": 3,
      "value": "#1. Experiment"
    }
  ],
  "line": 4,
  "name": "Step1.1",
  "description": "",
  "id": "capec-53:-postfix,-null-terminate,-and-backslash;step1.1",
  "type": "scenario",
  "keyword": "Scenario"
});
formatter.step({
  "line": 5,
  "name": "prepare to",
  "keyword": "Given "
});
formatter.step({
  "line": 6,
  "name": "Try to",
  "keyword": "When "
});
formatter.step({
  "comments": [
    {
      "line": 7,
      "value": "# assertion for attack step success"
    }
  ],
  "line": 8,
  "name": "Assert the success of",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 9,
      "value": "#assertions for security pattern testing (checker whether the pattern consequences are observed)"
    }
  ],
  "line": 10,
  "name": "assert the consequences of the pattern",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 11,
      "value": "#"
    }
  ],
  "line": 12,
  "name": "assert the consequences of the pattern audit interceptor",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 13,
      "value": "# depends secure logger"
    }
  ],
  "line": 14,
  "name": "assert the consequences of the pattern secure logger",
  "keyword": "Then "
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({
  "location": "PatternSteps.assauditinterceptor()"
});
formatter.result({
  "status": "skipped"
});
formatter.match({
  "location": "PatternSteps.asssecurelogger()"
});
formatter.result({
  "status": "skipped"
});
formatter.uri("CAPEC_53_Step_2_1.feature");
formatter.feature({
  "line": 2,
  "name": "CAPEC-53: Postfix, Null Terminate, and Backslash",
  "description": "",
  "id": "capec-53:-postfix,-null-terminate,-and-backslash",
  "keyword": "Feature",
  "tags": [
    {
      "line": 1,
      "name": "@capec53"
    }
  ]
});
formatter.scenario({
  "comments": [
    {
      "line": 3,
      "value": "#2. Exploit"
    }
  ],
  "line": 4,
  "name": "Step2.1",
  "description": "",
  "id": "capec-53:-postfix,-null-terminate,-and-backslash;step2.1",
  "type": "scenario",
  "keyword": "Scenario"
});
formatter.step({
  "line": 5,
  "name": "prepare to",
  "keyword": "Given "
});
formatter.step({
  "line": 6,
  "name": "Try to",
  "keyword": "When "
});
formatter.step({
  "comments": [
    {
      "line": 7,
      "value": "# assertion for attack step success"
    }
  ],
  "line": 8,
  "name": "Assert the success of",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 9,
      "value": "#assertions for security pattern testing (checker whether the pattern consequences are observed)"
    }
  ],
  "line": 10,
  "name": "assert the consequences of the pattern",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 11,
      "value": "#"
    }
  ],
  "line": 12,
  "name": "assert the consequences of the pattern audit interceptor",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 13,
      "value": "# depends secure logger"
    }
  ],
  "line": 14,
  "name": "assert the consequences of the pattern secure logger",
  "keyword": "Then "
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({
  "location": "PatternSteps.assauditinterceptor()"
});
formatter.result({
  "status": "skipped"
});
formatter.match({
  "location": "PatternSteps.asssecurelogger()"
});
formatter.result({
  "status": "skipped"
});
formatter.uri("CAPEC_54_Step_1_1.feature");
formatter.feature({
  "line": 2,
  "name": "CAPEC-54: Query System for Information",
  "description": "",
  "id": "capec-54:-query-system-for-information",
  "keyword": "Feature",
  "tags": [
    {
      "line": 1,
      "name": "@capec54"
    }
  ]
});
formatter.scenario({
  "comments": [
    {
      "line": 3,
      "value": "#1. Explore"
    }
  ],
  "line": 4,
  "name": "Step1.1",
  "description": "",
  "id": "capec-54:-query-system-for-information;step1.1",
  "type": "scenario",
  "keyword": "Scenario"
});
formatter.step({
  "line": 5,
  "name": "prepare to",
  "keyword": "Given "
});
formatter.step({
  "line": 6,
  "name": "Try to",
  "keyword": "When "
});
formatter.step({
  "comments": [
    {
      "line": 7,
      "value": "# assertion for attack step success"
    }
  ],
  "line": 8,
  "name": "Assert the success of",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 9,
      "value": "#assertions for security pattern testing (checker whether the pattern consequences are observed)"
    }
  ],
  "line": 10,
  "name": "assert the consequences of the pattern",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 11,
      "value": "#"
    }
  ],
  "line": 12,
  "name": "assert the consequences of the pattern audit interceptor",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 13,
      "value": "# depends secure logger"
    }
  ],
  "line": 14,
  "name": "assert the consequences of the pattern secure logger",
  "keyword": "Then "
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({
  "location": "PatternSteps.assauditinterceptor()"
});
formatter.result({
  "status": "skipped"
});
formatter.match({
  "location": "PatternSteps.asssecurelogger()"
});
formatter.result({
  "status": "skipped"
});
formatter.uri("CAPEC_54_Step_2_1.feature");
formatter.feature({
  "line": 2,
  "name": "CAPEC-54: Query System for Information",
  "description": "",
  "id": "capec-54:-query-system-for-information",
  "keyword": "Feature",
  "tags": [
    {
      "line": 1,
      "name": "@capec54"
    }
  ]
});
formatter.scenario({
  "comments": [
    {
      "line": 3,
      "value": "#2. Exploit"
    }
  ],
  "line": 4,
  "name": "Step2.1",
  "description": "",
  "id": "capec-54:-query-system-for-information;step2.1",
  "type": "scenario",
  "keyword": "Scenario"
});
formatter.step({
  "line": 5,
  "name": "prepare to",
  "keyword": "Given "
});
formatter.step({
  "line": 6,
  "name": "Try to",
  "keyword": "When "
});
formatter.step({
  "comments": [
    {
      "line": 7,
      "value": "# assertion for attack step success"
    }
  ],
  "line": 8,
  "name": "Assert the success of",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 9,
      "value": "#assertions for security pattern testing (checker whether the pattern consequences are observed)"
    }
  ],
  "line": 10,
  "name": "assert the consequences of the pattern",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 11,
      "value": "#"
    }
  ],
  "line": 12,
  "name": "assert the consequences of the pattern audit interceptor",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 13,
      "value": "# depends secure logger"
    }
  ],
  "line": 14,
  "name": "assert the consequences of the pattern secure logger",
  "keyword": "Then "
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({
  "location": "PatternSteps.assauditinterceptor()"
});
formatter.result({
  "status": "skipped"
});
formatter.match({
  "location": "PatternSteps.asssecurelogger()"
});
formatter.result({
  "status": "skipped"
});
formatter.uri("CAPEC_55_Step_1_1.feature");
formatter.feature({
  "line": 2,
  "name": "CAPEC-55: Rainbow Table Password Cracking",
  "description": "",
  "id": "capec-55:-rainbow-table-password-cracking",
  "keyword": "Feature",
  "tags": [
    {
      "line": 1,
      "name": "@capec55"
    }
  ]
});
formatter.scenario({
  "comments": [
    {
      "line": 3,
      "value": "#1. Explore"
    }
  ],
  "line": 4,
  "name": "Step1.1 Determine application\u0027s/system\u0027s password policy",
  "description": "",
  "id": "capec-55:-rainbow-table-password-cracking;step1.1-determine-application\u0027s/system\u0027s-password-policy",
  "type": "scenario",
  "keyword": "Scenario"
});
formatter.step({
  "line": 5,
  "name": "prepare to Determine application\u0027s/system\u0027s password policy",
  "keyword": "Given "
});
formatter.step({
  "line": 6,
  "name": "Try to Determine application\u0027s/system\u0027s password policy",
  "keyword": "When "
});
formatter.step({
  "comments": [
    {
      "line": 7,
      "value": "# assertion for attack step success"
    }
  ],
  "line": 8,
  "name": "Assert the success of Determine application\u0027s/system\u0027s password policy",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 9,
      "value": "#assertions for security pattern testing (checker whether the pattern consequences are observed)"
    }
  ],
  "line": 10,
  "name": "assert the consequences of the pattern",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 11,
      "value": "#"
    }
  ],
  "line": 12,
  "name": "assert the consequences of the pattern audit interceptor",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 13,
      "value": "# depends secure logger"
    }
  ],
  "line": 14,
  "name": "assert the consequences of the pattern secure logger",
  "keyword": "Then "
});
formatter.match({
  "location": "determineapplicationssystemspasswordpolicy.predetermineapplicationssystemspasswordpolicy()"
});
formatter.result({
  "duration": 27102,
  "status": "passed"
});
formatter.match({
  "location": "determineapplicationssystemspasswordpolicy.trydetermineapplicationssystemspasswordpolicy()"
});
formatter.result({
  "duration": 3446,
  "status": "passed"
});
formatter.match({
  "location": "determineapplicationssystemspasswordpolicy.assdetermineapplicationssystemspasswordpolicy()"
});
formatter.result({
  "duration": 2833,
  "status": "passed"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({
  "location": "PatternSteps.assauditinterceptor()"
});
formatter.result({
  "status": "skipped"
});
formatter.match({
  "location": "PatternSteps.asssecurelogger()"
});
formatter.result({
  "status": "skipped"
});
formatter.uri("CAPEC_55_Step_1_2.feature");
formatter.feature({
  "line": 2,
  "name": "CAPEC-55: Rainbow Table Password Cracking",
  "description": "",
  "id": "capec-55:-rainbow-table-password-cracking",
  "keyword": "Feature",
  "tags": [
    {
      "line": 1,
      "name": "@capec55"
    }
  ]
});
formatter.scenario({
  "comments": [
    {
      "line": 3,
      "value": "#1. Explore"
    }
  ],
  "line": 4,
  "name": "Step1.2 Obtain password hashes",
  "description": "",
  "id": "capec-55:-rainbow-table-password-cracking;step1.2-obtain-password-hashes",
  "type": "scenario",
  "keyword": "Scenario"
});
formatter.step({
  "line": 5,
  "name": "prepare to Obtain password hashes",
  "keyword": "Given "
});
formatter.step({
  "line": 6,
  "name": "Try to Obtain password hashes",
  "keyword": "When "
});
formatter.step({
  "comments": [
    {
      "line": 7,
      "value": "# assertion for attack step success"
    }
  ],
  "line": 8,
  "name": "Assert the success of Obtain password hashes",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 9,
      "value": "#assertions for security pattern testing (checker whether the pattern consequences are observed)"
    }
  ],
  "line": 10,
  "name": "assert the consequences of the pattern",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 11,
      "value": "#"
    }
  ],
  "line": 12,
  "name": "assert the consequences of the pattern audit interceptor",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 13,
      "value": "# depends secure logger"
    }
  ],
  "line": 14,
  "name": "assert the consequences of the pattern secure logger",
  "keyword": "Then "
});
formatter.match({
  "location": "obtainpasswordhashes.preobtainpasswordhashes()"
});
formatter.result({
  "duration": 52250,
  "status": "passed"
});
formatter.match({
  "location": "obtainpasswordhashes.tryobtainpasswordhashes()"
});
formatter.result({
  "duration": 3836,
  "status": "passed"
});
formatter.match({
  "location": "obtainpasswordhashes.assobtainpasswordhashes()"
});
formatter.result({
  "duration": 3256,
  "status": "passed"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({
  "location": "PatternSteps.assauditinterceptor()"
});
formatter.result({
  "status": "skipped"
});
formatter.match({
  "location": "PatternSteps.asssecurelogger()"
});
formatter.result({
  "status": "skipped"
});
formatter.uri("CAPEC_55_Step_2_1.feature");
formatter.feature({
  "line": 2,
  "name": "CAPEC-55: Rainbow Table Password Cracking",
  "description": "",
  "id": "capec-55:-rainbow-table-password-cracking",
  "keyword": "Feature",
  "tags": [
    {
      "line": 1,
      "name": "@capec55"
    }
  ]
});
formatter.scenario({
  "comments": [
    {
      "line": 3,
      "value": "#2. Exploit"
    }
  ],
  "line": 4,
  "name": "Step2.1 Run rainbow table-based password cracking tool",
  "description": "",
  "id": "capec-55:-rainbow-table-password-cracking;step2.1-run-rainbow-table-based-password-cracking-tool",
  "type": "scenario",
  "keyword": "Scenario"
});
formatter.step({
  "line": 5,
  "name": "prepare to Run rainbow table-based password cracking tool",
  "keyword": "Given "
});
formatter.step({
  "line": 6,
  "name": "Try to Run rainbow table-based password cracking tool",
  "keyword": "When "
});
formatter.step({
  "comments": [
    {
      "line": 7,
      "value": "# assertion for attack step success"
    }
  ],
  "line": 8,
  "name": "Assert the success of Run rainbow table-based password cracking tool",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 9,
      "value": "#assertions for security pattern testing (checker whether the pattern consequences are observed)"
    }
  ],
  "line": 10,
  "name": "assert the consequences of the pattern secure logger",
  "keyword": "Then "
});
formatter.match({
  "location": "runrainbowtablebasedpasswordcrackingtool.prerunrainbowtablebasedpasswordcrackingtool()"
});
formatter.result({
  "duration": 80656,
  "status": "passed"
});
formatter.match({
  "location": "runrainbowtablebasedpasswordcrackingtool.tryrunrainbowtablebasedpasswordcrackingtool()"
});
formatter.result({
  "duration": 3511,
  "status": "passed"
});
formatter.match({
  "location": "runrainbowtablebasedpasswordcrackingtool.assrunrainbowtablebasedpasswordcrackingtool()"
});
formatter.result({
  "duration": 3527,
  "status": "passed"
});
formatter.match({
  "location": "PatternSteps.asssecurelogger()"
});
formatter.result({
  "duration": 13268,
  "status": "passed"
});
formatter.uri("CAPEC_56_Step_1_1.feature");
formatter.feature({
  "line": 2,
  "name": "CAPEC-56: Removing/short-circuiting \u0027guard logic\u0027",
  "description": "",
  "id": "capec-56:-removing/short-circuiting-\u0027guard-logic\u0027",
  "keyword": "Feature",
  "tags": [
    {
      "line": 1,
      "name": "@capec56"
    }
  ]
});
formatter.scenario({
  "comments": [
    {
      "line": 3,
      "value": "#1. Explore"
    }
  ],
  "line": 4,
  "name": "Step1.1",
  "description": "",
  "id": "capec-56:-removing/short-circuiting-\u0027guard-logic\u0027;step1.1",
  "type": "scenario",
  "keyword": "Scenario"
});
formatter.step({
  "line": 5,
  "name": "prepare to",
  "keyword": "Given "
});
formatter.step({
  "line": 6,
  "name": "Try to",
  "keyword": "When "
});
formatter.step({
  "comments": [
    {
      "line": 7,
      "value": "# assertion for attack step success"
    }
  ],
  "line": 8,
  "name": "Assert the success of",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 9,
      "value": "#assertions for security pattern testing (checker whether the pattern consequences are observed)"
    }
  ],
  "line": 10,
  "name": "assert the consequences of the pattern",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 11,
      "value": "#"
    }
  ],
  "line": 12,
  "name": "assert the consequences of the pattern audit interceptor",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 13,
      "value": "# depends secure logger"
    }
  ],
  "line": 14,
  "name": "assert the consequences of the pattern secure logger",
  "keyword": "Then "
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({
  "location": "PatternSteps.assauditinterceptor()"
});
formatter.result({
  "status": "skipped"
});
formatter.match({
  "location": "PatternSteps.asssecurelogger()"
});
formatter.result({
  "status": "skipped"
});
formatter.uri("CAPEC_56_Step_2_1.feature");
formatter.feature({
  "line": 2,
  "name": "CAPEC-56: Removing/short-circuiting \u0027guard logic\u0027",
  "description": "",
  "id": "capec-56:-removing/short-circuiting-\u0027guard-logic\u0027",
  "keyword": "Feature",
  "tags": [
    {
      "line": 1,
      "name": "@capec56"
    }
  ]
});
formatter.scenario({
  "comments": [
    {
      "line": 3,
      "value": "#2. Experiment"
    }
  ],
  "line": 4,
  "name": "Step2.1",
  "description": "",
  "id": "capec-56:-removing/short-circuiting-\u0027guard-logic\u0027;step2.1",
  "type": "scenario",
  "keyword": "Scenario"
});
formatter.step({
  "line": 5,
  "name": "prepare to",
  "keyword": "Given "
});
formatter.step({
  "line": 6,
  "name": "Try to",
  "keyword": "When "
});
formatter.step({
  "comments": [
    {
      "line": 7,
      "value": "# assertion for attack step success"
    }
  ],
  "line": 8,
  "name": "Assert the success of",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 9,
      "value": "#assertions for security pattern testing (checker whether the pattern consequences are observed)"
    }
  ],
  "line": 10,
  "name": "assert the consequences of the pattern",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 11,
      "value": "#"
    }
  ],
  "line": 12,
  "name": "assert the consequences of the pattern audit interceptor",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 13,
      "value": "# depends secure logger"
    }
  ],
  "line": 14,
  "name": "assert the consequences of the pattern secure logger",
  "keyword": "Then "
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({
  "location": "PatternSteps.assauditinterceptor()"
});
formatter.result({
  "status": "skipped"
});
formatter.match({
  "location": "PatternSteps.asssecurelogger()"
});
formatter.result({
  "status": "skipped"
});
formatter.uri("CAPEC_56_Step_3_1.feature");
formatter.feature({
  "line": 2,
  "name": "CAPEC-56: Removing/short-circuiting \u0027guard logic\u0027",
  "description": "",
  "id": "capec-56:-removing/short-circuiting-\u0027guard-logic\u0027",
  "keyword": "Feature",
  "tags": [
    {
      "line": 1,
      "name": "@capec56"
    }
  ]
});
formatter.scenario({
  "comments": [
    {
      "line": 3,
      "value": "#3. Exploit"
    }
  ],
  "line": 4,
  "name": "Step3.1",
  "description": "",
  "id": "capec-56:-removing/short-circuiting-\u0027guard-logic\u0027;step3.1",
  "type": "scenario",
  "keyword": "Scenario"
});
formatter.step({
  "line": 5,
  "name": "prepare to",
  "keyword": "Given "
});
formatter.step({
  "line": 6,
  "name": "Try to",
  "keyword": "When "
});
formatter.step({
  "comments": [
    {
      "line": 7,
      "value": "# assertion for attack step success"
    }
  ],
  "line": 8,
  "name": "Assert the success of",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 9,
      "value": "#assertions for security pattern testing (checker whether the pattern consequences are observed)"
    }
  ],
  "line": 10,
  "name": "assert the consequences of the pattern",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 11,
      "value": "#"
    }
  ],
  "line": 12,
  "name": "assert the consequences of the pattern audit interceptor",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 13,
      "value": "# depends secure logger"
    }
  ],
  "line": 14,
  "name": "assert the consequences of the pattern secure logger",
  "keyword": "Then "
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({
  "location": "PatternSteps.assauditinterceptor()"
});
formatter.result({
  "status": "skipped"
});
formatter.match({
  "location": "PatternSteps.asssecurelogger()"
});
formatter.result({
  "status": "skipped"
});
formatter.uri("CAPEC_59_Step_1_1.feature");
formatter.feature({
  "line": 2,
  "name": "CAPEC-59: Session Credential Falsification through Prediction",
  "description": "",
  "id": "capec-59:-session-credential-falsification-through-prediction",
  "keyword": "Feature",
  "tags": [
    {
      "line": 1,
      "name": "@capec59"
    }
  ]
});
formatter.scenario({
  "comments": [
    {
      "line": 3,
      "value": "#1. Explore"
    }
  ],
  "line": 4,
  "name": "Step1.1 Find Session IDs",
  "description": "",
  "id": "capec-59:-session-credential-falsification-through-prediction;step1.1-find-session-ids",
  "type": "scenario",
  "keyword": "Scenario"
});
formatter.step({
  "line": 5,
  "name": "prepare to Find Session IDs",
  "keyword": "Given "
});
formatter.step({
  "line": 6,
  "name": "Try to Find Session IDs",
  "keyword": "When "
});
formatter.step({
  "comments": [
    {
      "line": 7,
      "value": "# assertion for attack step success"
    }
  ],
  "line": 8,
  "name": "Assert the success of Find Session IDs",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 9,
      "value": "#assertions for security pattern testing (checker whether the pattern consequences are observed)"
    }
  ],
  "line": 10,
  "name": "assert the consequences of the pattern",
  "keyword": "Then "
});
formatter.match({
  "location": "findsessionids.prefindsessionids()"
});
formatter.result({
  "duration": 59269,
  "status": "passed"
});
formatter.match({
  "location": "findsessionids.tryfindsessionids()"
});
formatter.result({
  "duration": 3762,
  "status": "passed"
});
formatter.match({
  "location": "findsessionids.assfindsessionids()"
});
formatter.result({
  "duration": 2653,
  "status": "passed"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.uri("CAPEC_59_Step_1_2.feature");
formatter.feature({
  "line": 2,
  "name": "CAPEC-59: Session Credential Falsification through Prediction",
  "description": "",
  "id": "capec-59:-session-credential-falsification-through-prediction",
  "keyword": "Feature",
  "tags": [
    {
      "line": 1,
      "name": "@capec59"
    }
  ]
});
formatter.scenario({
  "comments": [
    {
      "line": 3,
      "value": "#1. Explore"
    }
  ],
  "line": 4,
  "name": "Step1.2 Characterize IDs",
  "description": "",
  "id": "capec-59:-session-credential-falsification-through-prediction;step1.2-characterize-ids",
  "type": "scenario",
  "keyword": "Scenario"
});
formatter.step({
  "line": 5,
  "name": "prepare to Characterize IDs",
  "keyword": "Given "
});
formatter.step({
  "line": 6,
  "name": "Try to Characterize IDs",
  "keyword": "When "
});
formatter.step({
  "comments": [
    {
      "line": 7,
      "value": "# assertion for attack step success"
    }
  ],
  "line": 8,
  "name": "Assert the success of Characterize IDs",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 9,
      "value": "#assertions for security pattern testing (checker whether the pattern consequences are observed)"
    }
  ],
  "line": 10,
  "name": "assert the consequences of the pattern",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 11,
      "value": "#"
    }
  ],
  "line": 12,
  "name": "assert the consequences of the pattern audit interceptor",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 13,
      "value": "# depends secure logger"
    }
  ],
  "line": 14,
  "name": "assert the consequences of the pattern secure logger",
  "keyword": "Then "
});
formatter.match({
  "location": "characterizeids.precharacterizeids()"
});
formatter.result({
  "duration": 74809,
  "status": "passed"
});
formatter.match({
  "location": "characterizeids.trycharacterizeids()"
});
formatter.result({
  "duration": 3765,
  "status": "passed"
});
formatter.match({
  "location": "characterizeids.asscharacterizeids()"
});
formatter.result({
  "duration": 2694,
  "status": "passed"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({
  "location": "PatternSteps.assauditinterceptor()"
});
formatter.result({
  "status": "skipped"
});
formatter.match({
  "location": "PatternSteps.asssecurelogger()"
});
formatter.result({
  "status": "skipped"
});
formatter.uri("CAPEC_59_Step_2_1.feature");
formatter.feature({
  "line": 2,
  "name": "CAPEC-59: Session Credential Falsification through Prediction",
  "description": "",
  "id": "capec-59:-session-credential-falsification-through-prediction",
  "keyword": "Feature",
  "tags": [
    {
      "line": 1,
      "name": "@capec59"
    }
  ]
});
formatter.scenario({
  "comments": [
    {
      "line": 3,
      "value": "#2. Experiment"
    }
  ],
  "line": 4,
  "name": "Step2.1 Match issued IDs",
  "description": "",
  "id": "capec-59:-session-credential-falsification-through-prediction;step2.1-match-issued-ids",
  "type": "scenario",
  "keyword": "Scenario"
});
formatter.step({
  "line": 5,
  "name": "prepare to Match issued IDs",
  "keyword": "Given "
});
formatter.step({
  "line": 6,
  "name": "Try to Match issued IDs",
  "keyword": "When "
});
formatter.step({
  "comments": [
    {
      "line": 7,
      "value": "# assertion for attack step success"
    }
  ],
  "line": 8,
  "name": "Assert the success of Match issued IDs",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 9,
      "value": "#assertions for security pattern testing (checker whether the pattern consequences are observed)"
    }
  ],
  "line": 10,
  "name": "assert the consequences of the pattern",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 11,
      "value": "#"
    }
  ],
  "line": 12,
  "name": "assert the consequences of the pattern audit interceptor",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 13,
      "value": "# depends secure logger"
    }
  ],
  "line": 14,
  "name": "assert the consequences of the pattern secure logger",
  "keyword": "Then "
});
formatter.match({
  "location": "matchissuedids.prematchissuedids()"
});
formatter.result({
  "duration": 57401,
  "status": "passed"
});
formatter.match({
  "location": "matchissuedids.trymatchissuedids()"
});
formatter.result({
  "duration": 5490,
  "status": "passed"
});
formatter.match({
  "location": "matchissuedids.assmatchissuedids()"
});
formatter.result({
  "duration": 3685,
  "status": "passed"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({
  "location": "PatternSteps.assauditinterceptor()"
});
formatter.result({
  "status": "skipped"
});
formatter.match({
  "location": "PatternSteps.asssecurelogger()"
});
formatter.result({
  "status": "skipped"
});
formatter.uri("CAPEC_59_Step_3_1.feature");
formatter.feature({
  "line": 2,
  "name": "CAPEC-59: Session Credential Falsification through Prediction",
  "description": "",
  "id": "capec-59:-session-credential-falsification-through-prediction",
  "keyword": "Feature",
  "tags": [
    {
      "line": 1,
      "name": "@capec59"
    }
  ]
});
formatter.scenario({
  "comments": [
    {
      "line": 3,
      "value": "#3. Exploit"
    }
  ],
  "line": 4,
  "name": "Step3.1 Use matched Session ID",
  "description": "",
  "id": "capec-59:-session-credential-falsification-through-prediction;step3.1-use-matched-session-id",
  "type": "scenario",
  "keyword": "Scenario"
});
formatter.step({
  "line": 5,
  "name": "prepare to Use matched Session ID",
  "keyword": "Given "
});
formatter.step({
  "line": 6,
  "name": "Try to Use matched Session ID",
  "keyword": "When "
});
formatter.step({
  "comments": [
    {
      "line": 7,
      "value": "# assertion for attack step success"
    }
  ],
  "line": 8,
  "name": "Assert the success of Use matched Session ID",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 9,
      "value": "#assertions for security pattern testing (checker whether the pattern consequences are observed)"
    }
  ],
  "line": 10,
  "name": "assert the consequences of the pattern secure logger",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 11,
      "value": "# benifits audit interceptor"
    }
  ],
  "line": 12,
  "name": "assert the consequences of the pattern audit interceptor",
  "keyword": "Then "
});
formatter.match({
  "location": "usematchedsessionid.preusematchedsessionid()"
});
formatter.result({
  "duration": 58905,
  "status": "passed"
});
formatter.match({
  "location": "usematchedsessionid.tryusematchedsessionid()"
});
formatter.result({
  "duration": 3332,
  "status": "passed"
});
formatter.match({
  "location": "usematchedsessionid.assusematchedsessionid()"
});
formatter.result({
  "duration": 2964,
  "status": "passed"
});
formatter.match({
  "location": "PatternSteps.asssecurelogger()"
});
formatter.result({
  "duration": 15152,
  "status": "passed"
});
formatter.match({
  "location": "PatternSteps.assauditinterceptor()"
});
formatter.result({
  "duration": 3850,
  "status": "passed"
});
formatter.uri("CAPEC_60_Step_1_1.feature");
formatter.feature({
  "line": 2,
  "name": "CAPEC-60: Reusing Session IDs (aka Session Replay)",
  "description": "",
  "id": "capec-60:-reusing-session-ids-(aka-session-replay)",
  "keyword": "Feature",
  "tags": [
    {
      "line": 1,
      "name": "@capec60"
    }
  ]
});
formatter.scenario({
  "comments": [
    {
      "line": 3,
      "value": "#1. Explore"
    }
  ],
  "line": 4,
  "name": "Step1.1",
  "description": "",
  "id": "capec-60:-reusing-session-ids-(aka-session-replay);step1.1",
  "type": "scenario",
  "keyword": "Scenario"
});
formatter.step({
  "line": 5,
  "name": "prepare to",
  "keyword": "Given "
});
formatter.step({
  "line": 6,
  "name": "Try to",
  "keyword": "When "
});
formatter.step({
  "comments": [
    {
      "line": 7,
      "value": "# assertion for attack step success"
    }
  ],
  "line": 8,
  "name": "Assert the success of",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 9,
      "value": "#assertions for security pattern testing (checker whether the pattern consequences are observed)"
    }
  ],
  "line": 10,
  "name": "assert the consequences of the pattern",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 11,
      "value": "#"
    }
  ],
  "line": 12,
  "name": "assert the consequences of the pattern audit interceptor",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 13,
      "value": "# depends secure logger"
    }
  ],
  "line": 14,
  "name": "assert the consequences of the pattern secure logger",
  "keyword": "Then "
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({
  "location": "PatternSteps.assauditinterceptor()"
});
formatter.result({
  "status": "skipped"
});
formatter.match({
  "location": "PatternSteps.asssecurelogger()"
});
formatter.result({
  "status": "skipped"
});
formatter.uri("CAPEC_60_Step_2_1.feature");
formatter.feature({
  "line": 2,
  "name": "CAPEC-60: Reusing Session IDs (aka Session Replay)",
  "description": "",
  "id": "capec-60:-reusing-session-ids-(aka-session-replay)",
  "keyword": "Feature",
  "tags": [
    {
      "line": 1,
      "name": "@capec60"
    }
  ]
});
formatter.scenario({
  "comments": [
    {
      "line": 3,
      "value": "#2. Exploit"
    }
  ],
  "line": 4,
  "name": "Step2.1",
  "description": "",
  "id": "capec-60:-reusing-session-ids-(aka-session-replay);step2.1",
  "type": "scenario",
  "keyword": "Scenario"
});
formatter.step({
  "line": 5,
  "name": "prepare to",
  "keyword": "Given "
});
formatter.step({
  "line": 6,
  "name": "Try to",
  "keyword": "When "
});
formatter.step({
  "comments": [
    {
      "line": 7,
      "value": "# assertion for attack step success"
    }
  ],
  "line": 8,
  "name": "Assert the success of",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 9,
      "value": "#assertions for security pattern testing (checker whether the pattern consequences are observed)"
    }
  ],
  "line": 10,
  "name": "assert the consequences of the pattern",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 11,
      "value": "#"
    }
  ],
  "line": 12,
  "name": "assert the consequences of the pattern audit interceptor",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 13,
      "value": "# depends secure logger"
    }
  ],
  "line": 14,
  "name": "assert the consequences of the pattern secure logger",
  "keyword": "Then "
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({
  "location": "PatternSteps.assauditinterceptor()"
});
formatter.result({
  "status": "skipped"
});
formatter.match({
  "location": "PatternSteps.asssecurelogger()"
});
formatter.result({
  "status": "skipped"
});
formatter.uri("CAPEC_61_Step_1_1.feature");
formatter.feature({
  "line": 2,
  "name": "CAPEC-61: Session Fixation",
  "description": "",
  "id": "capec-61:-session-fixation",
  "keyword": "Feature",
  "tags": [
    {
      "line": 1,
      "name": "@capec61"
    }
  ]
});
formatter.scenario({
  "comments": [
    {
      "line": 3,
      "value": "#1. Explore"
    }
  ],
  "line": 4,
  "name": "Step1.1 Setup the Attack",
  "description": "",
  "id": "capec-61:-session-fixation;step1.1-setup-the-attack",
  "type": "scenario",
  "keyword": "Scenario"
});
formatter.step({
  "line": 5,
  "name": "prepare to Setup the Attack",
  "keyword": "Given "
});
formatter.step({
  "line": 6,
  "name": "Try to Setup the Attack",
  "keyword": "When "
});
formatter.step({
  "comments": [
    {
      "line": 7,
      "value": "# assertion for attack step success"
    }
  ],
  "line": 8,
  "name": "Assert the success of Setup the Attack",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 9,
      "value": "#assertions for security pattern testing (checker whether the pattern consequences are observed)"
    }
  ],
  "line": 10,
  "name": "assert the consequences of the pattern secure logger",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 11,
      "value": "# benifits audit interceptor"
    }
  ],
  "line": 12,
  "name": "assert the consequences of the pattern audit interceptor",
  "keyword": "Then "
});
formatter.match({
  "location": "setuptheattack.presetuptheattack()"
});
formatter.result({
  "duration": 77522,
  "status": "passed"
});
formatter.match({
  "location": "setuptheattack.trysetuptheattack()"
});
formatter.result({
  "duration": 6317,
  "status": "passed"
});
formatter.match({
  "location": "setuptheattack.asssetuptheattack()"
});
formatter.result({
  "duration": 4967,
  "status": "passed"
});
formatter.match({
  "location": "PatternSteps.asssecurelogger()"
});
formatter.result({
  "duration": 18544,
  "status": "passed"
});
formatter.match({
  "location": "PatternSteps.assauditinterceptor()"
});
formatter.result({
  "duration": 5292,
  "status": "passed"
});
formatter.uri("CAPEC_61_Step_2_1.feature");
formatter.feature({
  "line": 2,
  "name": "CAPEC-61: Session Fixation",
  "description": "",
  "id": "capec-61:-session-fixation",
  "keyword": "Feature",
  "tags": [
    {
      "line": 1,
      "name": "@capec61"
    }
  ]
});
formatter.scenario({
  "comments": [
    {
      "line": 3,
      "value": "#2. Experiment"
    }
  ],
  "line": 4,
  "name": "Step2.1 Attract a Victim",
  "description": "",
  "id": "capec-61:-session-fixation;step2.1-attract-a-victim",
  "type": "scenario",
  "keyword": "Scenario"
});
formatter.step({
  "line": 5,
  "name": "prepare to Attract a Victim",
  "keyword": "Given "
});
formatter.step({
  "line": 6,
  "name": "Try to Attract a Victim",
  "keyword": "When "
});
formatter.step({
  "comments": [
    {
      "line": 7,
      "value": "# assertion for attack step success"
    }
  ],
  "line": 8,
  "name": "Assert the success of Attract a Victim",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 9,
      "value": "#assertions for security pattern testing (checker whether the pattern consequences are observed)"
    }
  ],
  "line": 10,
  "name": "assert the consequences of the pattern secure logger",
  "keyword": "Then "
});
formatter.match({
  "location": "attractavictim.preattractavictim()"
});
formatter.result({
  "duration": 76113,
  "status": "passed"
});
formatter.match({
  "location": "attractavictim.tryattractavictim()"
});
formatter.result({
  "duration": 7099,
  "status": "passed"
});
formatter.match({
  "location": "attractavictim.assattractavictim()"
});
formatter.result({
  "duration": 4060,
  "status": "passed"
});
formatter.match({
  "location": "PatternSteps.asssecurelogger()"
});
formatter.result({
  "duration": 19299,
  "status": "passed"
});
formatter.uri("CAPEC_61_Step_3_1.feature");
formatter.feature({
  "line": 2,
  "name": "CAPEC-61: Session Fixation",
  "description": "",
  "id": "capec-61:-session-fixation",
  "keyword": "Feature",
  "tags": [
    {
      "line": 1,
      "name": "@capec61"
    }
  ]
});
formatter.scenario({
  "comments": [
    {
      "line": 3,
      "value": "#3. Exploit"
    }
  ],
  "line": 4,
  "name": "Step3.1 Abuse the Victim\u0027s Session",
  "description": "",
  "id": "capec-61:-session-fixation;step3.1-abuse-the-victim\u0027s-session",
  "type": "scenario",
  "keyword": "Scenario"
});
formatter.step({
  "line": 5,
  "name": "prepare to Abuse the Victim\u0027s Session",
  "keyword": "Given "
});
formatter.step({
  "line": 6,
  "name": "Try to Abuse the Victim\u0027s Session",
  "keyword": "When "
});
formatter.step({
  "comments": [
    {
      "line": 7,
      "value": "# assertion for attack step success"
    }
  ],
  "line": 8,
  "name": "Assert the success of Abuse the Victim\u0027s Session",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 9,
      "value": "#assertions for security pattern testing (checker whether the pattern consequences are observed)"
    }
  ],
  "line": 10,
  "name": "assert the consequences of the pattern audit interceptor",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 11,
      "value": "# depends secure logger"
    }
  ],
  "line": 12,
  "name": "assert the consequences of the pattern secure logger",
  "keyword": "Then "
});
formatter.match({
  "location": "abusethevictimssession.preabusethevictimssession()"
});
formatter.result({
  "duration": 42294,
  "status": "passed"
});
formatter.match({
  "location": "abusethevictimssession.tryabusethevictimssession()"
});
formatter.result({
  "duration": 3727,
  "status": "passed"
});
formatter.match({
  "location": "abusethevictimssession.assabusethevictimssession()"
});
formatter.result({
  "duration": 3095,
  "status": "passed"
});
formatter.match({
  "location": "PatternSteps.assauditinterceptor()"
});
formatter.result({
  "duration": 10743,
  "status": "passed"
});
formatter.match({
  "location": "PatternSteps.asssecurelogger()"
});
formatter.result({
  "duration": 3529,
  "status": "passed"
});
formatter.uri("CAPEC_62_Step_1_1.feature");
formatter.feature({
  "line": 2,
  "name": "CAPEC-62: Cross Site Request Forgery (aka Session Riding)",
  "description": "",
  "id": "capec-62:-cross-site-request-forgery-(aka-session-riding)",
  "keyword": "Feature",
  "tags": [
    {
      "line": 1,
      "name": "@capec62"
    }
  ]
});
formatter.scenario({
  "comments": [
    {
      "line": 3,
      "value": "#1. Explore"
    }
  ],
  "line": 4,
  "name": "Step1.1 Explore target website",
  "description": "",
  "id": "capec-62:-cross-site-request-forgery-(aka-session-riding);step1.1-explore-target-website",
  "type": "scenario",
  "keyword": "Scenario"
});
formatter.step({
  "line": 5,
  "name": "prepare to Explore target website",
  "keyword": "Given "
});
formatter.step({
  "line": 6,
  "name": "Try to Explore target website",
  "keyword": "When "
});
formatter.step({
  "comments": [
    {
      "line": 7,
      "value": "# assertion for attack step success"
    }
  ],
  "line": 8,
  "name": "Assert the success of Explore target website",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 9,
      "value": "#assertions for security pattern testing (checker whether the pattern consequences are observed)"
    }
  ],
  "line": 10,
  "name": "assert the consequences of the pattern",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 11,
      "value": "#"
    }
  ],
  "line": 12,
  "name": "assert the consequences of the pattern audit interceptor",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 13,
      "value": "# depends secure logger"
    }
  ],
  "line": 14,
  "name": "assert the consequences of the pattern secure logger",
  "keyword": "Then "
});
formatter.match({
  "location": "exploretargetwebsite.preexploretargetwebsite()"
});
formatter.result({
  "duration": 30034,
  "status": "passed"
});
formatter.match({
  "location": "exploretargetwebsite.tryexploretargetwebsite()"
});
formatter.result({
  "duration": 72428,
  "status": "passed"
});
formatter.match({
  "location": "exploretargetwebsite.assexploretargetwebsite()"
});
formatter.result({
  "duration": 5135,
  "status": "passed"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({
  "location": "PatternSteps.assauditinterceptor()"
});
formatter.result({
  "status": "skipped"
});
formatter.match({
  "location": "PatternSteps.asssecurelogger()"
});
formatter.result({
  "status": "skipped"
});
formatter.uri("CAPEC_62_Step_2_1.feature");
formatter.feature({
  "line": 2,
  "name": "CAPEC-62: Cross Site Request Forgery (aka Session Riding)",
  "description": "",
  "id": "capec-62:-cross-site-request-forgery-(aka-session-riding)",
  "keyword": "Feature",
  "tags": [
    {
      "line": 1,
      "name": "@capec62"
    }
  ]
});
formatter.scenario({
  "comments": [
    {
      "line": 3,
      "value": "#2. Experiment"
    }
  ],
  "line": 4,
  "name": "Step2.1 Create a link that when clicked on, will execute the interesting functionality.",
  "description": "",
  "id": "capec-62:-cross-site-request-forgery-(aka-session-riding);step2.1-create-a-link-that-when-clicked-on,-will-execute-the-interesting-functionality.",
  "type": "scenario",
  "keyword": "Scenario"
});
formatter.step({
  "line": 5,
  "name": "prepare to Create a link that when clicked on, will execute the interesting functionality.",
  "keyword": "Given "
});
formatter.step({
  "line": 6,
  "name": "Try to Create a link that when clicked on, will execute the interesting functionality.",
  "keyword": "When "
});
formatter.step({
  "comments": [
    {
      "line": 7,
      "value": "# assertion for attack step success"
    }
  ],
  "line": 8,
  "name": "Assert the success of Create a link that when clicked on, will execute the interesting functionality.",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 9,
      "value": "#assertions for security pattern testing (checker whether the pattern consequences are observed)"
    }
  ],
  "line": 10,
  "name": "assert the consequences of the pattern secure logger",
  "keyword": "Then "
});
formatter.step({
  "line": 11,
  "name": "assert the consequences of the pattern",
  "keyword": "Then "
});
formatter.match({
  "location": "createalinkthatwhenclickedonwillexecutetheinterestingfunctionality.precreatealinkthatwhenclickedonwillexecutetheinterestingfunctionality()"
});
formatter.result({
  "duration": 66902,
  "status": "passed"
});
formatter.match({
  "location": "createalinkthatwhenclickedonwillexecutetheinterestingfunctionality.trycreatealinkthatwhenclickedonwillexecutetheinterestingfunctionality()"
});
formatter.result({
  "duration": 7135,
  "status": "passed"
});
formatter.match({
  "location": "createalinkthatwhenclickedonwillexecutetheinterestingfunctionality.asscreatealinkthatwhenclickedonwillexecutetheinterestingfunctionality()"
});
formatter.result({
  "duration": 8315,
  "status": "passed"
});
formatter.match({
  "location": "PatternSteps.asssecurelogger()"
});
formatter.result({
  "duration": 24660,
  "status": "passed"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.uri("CAPEC_62_Step_3_1.feature");
formatter.feature({
  "line": 2,
  "name": "CAPEC-62: Cross Site Request Forgery (aka Session Riding)",
  "description": "",
  "id": "capec-62:-cross-site-request-forgery-(aka-session-riding)",
  "keyword": "Feature",
  "tags": [
    {
      "line": 1,
      "name": "@capec62"
    }
  ]
});
formatter.scenario({
  "comments": [
    {
      "line": 3,
      "value": "#3. Exploit"
    }
  ],
  "line": 4,
  "name": "Step3.1 Convince user to click on link",
  "description": "",
  "id": "capec-62:-cross-site-request-forgery-(aka-session-riding);step3.1-convince-user-to-click-on-link",
  "type": "scenario",
  "keyword": "Scenario"
});
formatter.step({
  "line": 5,
  "name": "prepare to Convince user to click on link",
  "keyword": "Given "
});
formatter.step({
  "line": 6,
  "name": "Try to Convince user to click on link",
  "keyword": "When "
});
formatter.step({
  "comments": [
    {
      "line": 7,
      "value": "# assertion for attack step success"
    }
  ],
  "line": 8,
  "name": "Assert the success of Convince user to click on link",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 9,
      "value": "#assertions for security pattern testing (checker whether the pattern consequences are observed)"
    }
  ],
  "line": 10,
  "name": "assert the consequences of the pattern secure logger",
  "keyword": "Then "
});
formatter.step({
  "line": 11,
  "name": "assert the consequences of the pattern",
  "keyword": "Then "
});
formatter.match({
  "location": "convinceusertoclickonlink.preconvinceusertoclickonlink()"
});
formatter.result({
  "duration": 80788,
  "status": "passed"
});
formatter.match({
  "location": "convinceusertoclickonlink.tryconvinceusertoclickonlink()"
});
formatter.result({
  "duration": 7126,
  "status": "passed"
});
formatter.match({
  "location": "convinceusertoclickonlink.assconvinceusertoclickonlink()"
});
formatter.result({
  "duration": 7467,
  "status": "passed"
});
formatter.match({
  "location": "PatternSteps.asssecurelogger()"
});
formatter.result({
  "duration": 24400,
  "status": "passed"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.uri("CAPEC_63_Step_1_1.feature");
formatter.feature({
  "line": 2,
  "name": "CAPEC-63: Simple Script Injection",
  "description": "",
  "id": "capec-63:-simple-script-injection",
  "keyword": "Feature",
  "tags": [
    {
      "line": 1,
      "name": "@capec63"
    }
  ]
});
formatter.scenario({
  "comments": [
    {
      "line": 3,
      "value": "#1. Explore"
    }
  ],
  "line": 4,
  "name": "Step1.1 Survey the application for user-controllable inputs",
  "description": "",
  "id": "capec-63:-simple-script-injection;step1.1-survey-the-application-for-user-controllable-inputs",
  "type": "scenario",
  "keyword": "Scenario"
});
formatter.step({
  "line": 5,
  "name": "prepare to Survey the application for user-controllable inputs",
  "keyword": "Given "
});
formatter.step({
  "line": 6,
  "name": "Try to Survey the application for user-controllable inputs",
  "keyword": "When "
});
formatter.step({
  "comments": [
    {
      "line": 7,
      "value": "# assertion for attack step success"
    }
  ],
  "line": 8,
  "name": "Assert the success of Survey the application for user-controllable inputs",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 9,
      "value": "#assertions for security pattern testing (checker whether the pattern consequences are observed)"
    }
  ],
  "line": 10,
  "name": "assert the consequences of the pattern",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 11,
      "value": "#"
    }
  ],
  "line": 12,
  "name": "assert the consequences of the pattern audit interceptor",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 13,
      "value": "# depends secure logger"
    }
  ],
  "line": 14,
  "name": "assert the consequences of the pattern secure logger",
  "keyword": "Then "
});
formatter.match({
  "location": "survey.presurvey()"
});
formatter.result({
  "duration": 0,
  "error_message": "cucumber.runtime.AmbiguousStepDefinitionsException: ✽.Given prepare to Survey the application for user-controllable inputs(CAPEC_63_Step_1_1.feature:5) matches more than one step definition:\n  prepare to Survey in survey.presurvey()\n  prepare to Survey the application in surveytheapplication.presurveytheapplication()\n  prepare to Survey the application for user-controllable inputs in surveytheapplicationforusercontrollableinputs.presurveytheapplicationforusercontrollableinputs()\n\n\tat cucumber.runtime.RuntimeGlue.stepDefinitionMatch(RuntimeGlue.java:71)\n\tat cucumber.runtime.Runtime.runStep(Runtime.java:265)\n\tat cucumber.runtime.model.StepContainer.runStep(StepContainer.java:44)\n\tat cucumber.runtime.model.StepContainer.runSteps(StepContainer.java:39)\n\tat cucumber.runtime.model.CucumberScenario.run(CucumberScenario.java:48)\n\tat cucumber.runtime.junit.ExecutionUnitRunner.run(ExecutionUnitRunner.java:91)\n\tat cucumber.runtime.junit.FeatureRunner.runChild(FeatureRunner.java:63)\n\tat cucumber.runtime.junit.FeatureRunner.runChild(FeatureRunner.java:18)\n\tat org.junit.runners.ParentRunner$3.run(ParentRunner.java:238)\n\tat org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:63)\n\tat org.junit.runners.ParentRunner.runChildren(ParentRunner.java:236)\n\tat org.junit.runners.ParentRunner.access$000(ParentRunner.java:53)\n\tat org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:229)\n\tat org.junit.runners.ParentRunner.run(ParentRunner.java:309)\n\tat cucumber.runtime.junit.FeatureRunner.run(FeatureRunner.java:70)\n\tat cucumber.api.junit.Cucumber.runChild(Cucumber.java:93)\n\tat cucumber.api.junit.Cucumber.runChild(Cucumber.java:37)\n\tat org.junit.runners.ParentRunner$3.run(ParentRunner.java:238)\n\tat org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:63)\n\tat org.junit.runners.ParentRunner.runChildren(ParentRunner.java:236)\n\tat org.junit.runners.ParentRunner.access$000(ParentRunner.java:53)\n\tat org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:229)\n\tat org.junit.internal.runners.statements.RunAfters.evaluate(RunAfters.java:27)\n\tat org.junit.runners.ParentRunner.run(ParentRunner.java:309)\n\tat cucumber.api.junit.Cucumber.run(Cucumber.java:98)\n\tat org.eclipse.jdt.internal.junit4.runner.JUnit4TestReference.run(JUnit4TestReference.java:86)\n\tat org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:459)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:678)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:382)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:192)\n",
  "status": "failed"
});
formatter.match({
  "location": "survey.trysurvey()"
});
formatter.result({
  "duration": 0,
  "error_message": "cucumber.runtime.AmbiguousStepDefinitionsException: ✽.When Try to Survey the application for user-controllable inputs(CAPEC_63_Step_1_1.feature:6) matches more than one step definition:\n  Try to Survey in survey.trysurvey()\n  Try to Survey the application in surveytheapplication.trysurveytheapplication()\n  Try to Survey the application for user-controllable inputs in surveytheapplicationforusercontrollableinputs.trysurveytheapplicationforusercontrollableinputs()\n\n\tat cucumber.runtime.RuntimeGlue.stepDefinitionMatch(RuntimeGlue.java:71)\n\tat cucumber.runtime.Runtime.runStep(Runtime.java:265)\n\tat cucumber.runtime.model.StepContainer.runStep(StepContainer.java:44)\n\tat cucumber.runtime.model.StepContainer.runSteps(StepContainer.java:39)\n\tat cucumber.runtime.model.CucumberScenario.run(CucumberScenario.java:48)\n\tat cucumber.runtime.junit.ExecutionUnitRunner.run(ExecutionUnitRunner.java:91)\n\tat cucumber.runtime.junit.FeatureRunner.runChild(FeatureRunner.java:63)\n\tat cucumber.runtime.junit.FeatureRunner.runChild(FeatureRunner.java:18)\n\tat org.junit.runners.ParentRunner$3.run(ParentRunner.java:238)\n\tat org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:63)\n\tat org.junit.runners.ParentRunner.runChildren(ParentRunner.java:236)\n\tat org.junit.runners.ParentRunner.access$000(ParentRunner.java:53)\n\tat org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:229)\n\tat org.junit.runners.ParentRunner.run(ParentRunner.java:309)\n\tat cucumber.runtime.junit.FeatureRunner.run(FeatureRunner.java:70)\n\tat cucumber.api.junit.Cucumber.runChild(Cucumber.java:93)\n\tat cucumber.api.junit.Cucumber.runChild(Cucumber.java:37)\n\tat org.junit.runners.ParentRunner$3.run(ParentRunner.java:238)\n\tat org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:63)\n\tat org.junit.runners.ParentRunner.runChildren(ParentRunner.java:236)\n\tat org.junit.runners.ParentRunner.access$000(ParentRunner.java:53)\n\tat org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:229)\n\tat org.junit.internal.runners.statements.RunAfters.evaluate(RunAfters.java:27)\n\tat org.junit.runners.ParentRunner.run(ParentRunner.java:309)\n\tat cucumber.api.junit.Cucumber.run(Cucumber.java:98)\n\tat org.eclipse.jdt.internal.junit4.runner.JUnit4TestReference.run(JUnit4TestReference.java:86)\n\tat org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:459)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:678)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:382)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:192)\n",
  "status": "failed"
});
formatter.match({
  "location": "survey.asssurvey()"
});
formatter.result({
  "duration": 0,
  "error_message": "cucumber.runtime.AmbiguousStepDefinitionsException: ✽.Then Assert the success of Survey the application for user-controllable inputs(CAPEC_63_Step_1_1.feature:8) matches more than one step definition:\n  Assert the success of Survey in survey.asssurvey()\n  Assert the success of Survey the application in surveytheapplication.asssurveytheapplication()\n  Assert the success of Survey the application for user-controllable inputs in surveytheapplicationforusercontrollableinputs.asssurveytheapplicationforusercontrollableinputs()\n\n\tat cucumber.runtime.RuntimeGlue.stepDefinitionMatch(RuntimeGlue.java:71)\n\tat cucumber.runtime.Runtime.runStep(Runtime.java:265)\n\tat cucumber.runtime.model.StepContainer.runStep(StepContainer.java:44)\n\tat cucumber.runtime.model.StepContainer.runSteps(StepContainer.java:39)\n\tat cucumber.runtime.model.CucumberScenario.run(CucumberScenario.java:48)\n\tat cucumber.runtime.junit.ExecutionUnitRunner.run(ExecutionUnitRunner.java:91)\n\tat cucumber.runtime.junit.FeatureRunner.runChild(FeatureRunner.java:63)\n\tat cucumber.runtime.junit.FeatureRunner.runChild(FeatureRunner.java:18)\n\tat org.junit.runners.ParentRunner$3.run(ParentRunner.java:238)\n\tat org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:63)\n\tat org.junit.runners.ParentRunner.runChildren(ParentRunner.java:236)\n\tat org.junit.runners.ParentRunner.access$000(ParentRunner.java:53)\n\tat org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:229)\n\tat org.junit.runners.ParentRunner.run(ParentRunner.java:309)\n\tat cucumber.runtime.junit.FeatureRunner.run(FeatureRunner.java:70)\n\tat cucumber.api.junit.Cucumber.runChild(Cucumber.java:93)\n\tat cucumber.api.junit.Cucumber.runChild(Cucumber.java:37)\n\tat org.junit.runners.ParentRunner$3.run(ParentRunner.java:238)\n\tat org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:63)\n\tat org.junit.runners.ParentRunner.runChildren(ParentRunner.java:236)\n\tat org.junit.runners.ParentRunner.access$000(ParentRunner.java:53)\n\tat org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:229)\n\tat org.junit.internal.runners.statements.RunAfters.evaluate(RunAfters.java:27)\n\tat org.junit.runners.ParentRunner.run(ParentRunner.java:309)\n\tat cucumber.api.junit.Cucumber.run(Cucumber.java:98)\n\tat org.eclipse.jdt.internal.junit4.runner.JUnit4TestReference.run(JUnit4TestReference.java:86)\n\tat org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:459)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:678)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:382)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:192)\n",
  "status": "failed"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({
  "location": "PatternSteps.assauditinterceptor()"
});
formatter.result({
  "status": "skipped"
});
formatter.match({
  "location": "PatternSteps.asssecurelogger()"
});
formatter.result({
  "status": "skipped"
});
formatter.uri("CAPEC_63_Step_2_1.feature");
formatter.feature({
  "line": 2,
  "name": "CAPEC-63: Simple Script Injection",
  "description": "",
  "id": "capec-63:-simple-script-injection",
  "keyword": "Feature",
  "tags": [
    {
      "line": 1,
      "name": "@capec63"
    }
  ]
});
formatter.scenario({
  "comments": [
    {
      "line": 3,
      "value": "#2. Experiment"
    }
  ],
  "line": 4,
  "name": "Step2.1 Probe identified potential entry points for XSS vulnerability",
  "description": "",
  "id": "capec-63:-simple-script-injection;step2.1-probe-identified-potential-entry-points-for-xss-vulnerability",
  "type": "scenario",
  "keyword": "Scenario"
});
formatter.step({
  "line": 5,
  "name": "prepare to Probe identified potential entry points for XSS vulnerability",
  "keyword": "Given "
});
formatter.step({
  "line": 6,
  "name": "Try to Probe identified potential entry points for XSS vulnerability",
  "keyword": "When "
});
formatter.step({
  "comments": [
    {
      "line": 7,
      "value": "# assertion for attack step success"
    }
  ],
  "line": 8,
  "name": "Assert the success of Probe identified potential entry points for XSS vulnerability",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 9,
      "value": "#assertions for security pattern testing (checker whether the pattern consequences are observed)"
    }
  ],
  "line": 10,
  "name": "assert the consequences of the pattern secure logger",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 11,
      "value": "# benifits audit interceptor"
    }
  ],
  "line": 12,
  "name": "assert the consequences of the pattern application firewall",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 13,
      "value": "# alternative output guard"
    },
    {
      "line": 14,
      "value": "# alternative input guard"
    }
  ],
  "line": 15,
  "name": "assert the consequences of the pattern input guard",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 16,
      "value": "# alternative application firewall"
    },
    {
      "line": 17,
      "value": "# benifits output guard"
    }
  ],
  "line": 18,
  "name": "assert the consequences of the pattern output guard",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 19,
      "value": "# alternative application firewall"
    },
    {
      "line": 20,
      "value": "# benifits input guard"
    }
  ],
  "line": 21,
  "name": "assert the consequences of the pattern comparator checked fault tolerant system",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 22,
      "value": "# alternative output guard"
    },
    {
      "line": 23,
      "value": "# impairs audit interceptor"
    }
  ],
  "line": 24,
  "name": "assert the consequences of the pattern audit interceptor",
  "keyword": "Then "
});
formatter.match({
  "location": "probeidentifiedpotentialentrypointsforxssvulnerability.preprobeidentifiedpotentialentrypointsforxssvulnerability()"
});
formatter.result({
  "duration": 2673417,
  "error_message": "net.continuumsecurity.proxy.ProxyException: org.zaproxy.clientapi.core.ClientApiException: java.net.ConnectException: Connection refused\n\tat net.continuumsecurity.proxy.ZAProxyScanner.validateMinimumRequiredZapVersion(ZAProxyScanner.java:96)\n\tat net.continuumsecurity.proxy.ZAProxyScanner.\u003cinit\u003e(ZAProxyScanner.java:38)\n\tat steps.probeidentifiedpotentialentrypointsforxssvulnerability.preprobeidentifiedpotentialentrypointsforxssvulnerability(probeidentifiedpotentialentrypointsforxssvulnerability.java:15)\n\tat ✽.Given prepare to Probe identified potential entry points for XSS vulnerability(CAPEC_63_Step_2_1.feature:5)\nCaused by: org.zaproxy.clientapi.core.ClientApiException: java.net.ConnectException: Connection refused\n\tat org.zaproxy.clientapi.core.ClientApi.callApiDom(ClientApi.java:307)\n\tat org.zaproxy.clientapi.core.ClientApi.callApi(ClientApi.java:289)\n\tat org.zaproxy.clientapi.gen.Core.version(Core.java:158)\n\tat net.continuumsecurity.proxy.ZAProxyScanner.validateMinimumRequiredZapVersion(ZAProxyScanner.java:85)\n\tat net.continuumsecurity.proxy.ZAProxyScanner.\u003cinit\u003e(ZAProxyScanner.java:38)\n\tat steps.probeidentifiedpotentialentrypointsforxssvulnerability.preprobeidentifiedpotentialentrypointsforxssvulnerability(probeidentifiedpotentialentrypointsforxssvulnerability.java:15)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.lang.reflect.Method.invoke(Method.java:498)\n\tat cucumber.runtime.Utils$1.call(Utils.java:37)\n\tat cucumber.runtime.Timeout.timeout(Timeout.java:13)\n\tat cucumber.runtime.Utils.invoke(Utils.java:31)\n\tat cucumber.runtime.java.JavaStepDefinition.execute(JavaStepDefinition.java:37)\n\tat cucumber.runtime.StepDefinitionMatch.runStep(StepDefinitionMatch.java:37)\n\tat cucumber.runtime.Runtime.runStep(Runtime.java:298)\n\tat cucumber.runtime.model.StepContainer.runStep(StepContainer.java:44)\n\tat cucumber.runtime.model.StepContainer.runSteps(StepContainer.java:39)\n\tat cucumber.runtime.model.CucumberScenario.run(CucumberScenario.java:48)\n\tat cucumber.runtime.junit.ExecutionUnitRunner.run(ExecutionUnitRunner.java:91)\n\tat cucumber.runtime.junit.FeatureRunner.runChild(FeatureRunner.java:63)\n\tat cucumber.runtime.junit.FeatureRunner.runChild(FeatureRunner.java:18)\n\tat org.junit.runners.ParentRunner$3.run(ParentRunner.java:238)\n\tat org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:63)\n\tat org.junit.runners.ParentRunner.runChildren(ParentRunner.java:236)\n\tat org.junit.runners.ParentRunner.access$000(ParentRunner.java:53)\n\tat org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:229)\n\tat org.junit.runners.ParentRunner.run(ParentRunner.java:309)\n\tat cucumber.runtime.junit.FeatureRunner.run(FeatureRunner.java:70)\n\tat cucumber.api.junit.Cucumber.runChild(Cucumber.java:93)\n\tat cucumber.api.junit.Cucumber.runChild(Cucumber.java:37)\n\tat org.junit.runners.ParentRunner$3.run(ParentRunner.java:238)\n\tat org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:63)\n\tat org.junit.runners.ParentRunner.runChildren(ParentRunner.java:236)\n\tat org.junit.runners.ParentRunner.access$000(ParentRunner.java:53)\n\tat org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:229)\n\tat org.junit.internal.runners.statements.RunAfters.evaluate(RunAfters.java:27)\n\tat org.junit.runners.ParentRunner.run(ParentRunner.java:309)\n\tat cucumber.api.junit.Cucumber.run(Cucumber.java:98)\n\tat org.eclipse.jdt.internal.junit4.runner.JUnit4TestReference.run(JUnit4TestReference.java:86)\n\tat org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:459)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:678)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:382)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:192)\nCaused by: java.net.ConnectException: Connection refused\n\tat java.net.PlainSocketImpl.socketConnect(Native Method)\n\tat java.net.AbstractPlainSocketImpl.doConnect(AbstractPlainSocketImpl.java:350)\n\tat java.net.AbstractPlainSocketImpl.connectToAddress(AbstractPlainSocketImpl.java:206)\n\tat java.net.AbstractPlainSocketImpl.connect(AbstractPlainSocketImpl.java:188)\n\tat java.net.Socket.connect(Socket.java:589)\n\tat java.net.Socket.connect(Socket.java:538)\n\tat sun.net.NetworkClient.doConnect(NetworkClient.java:180)\n\tat sun.net.www.http.HttpClient.openServer(HttpClient.java:432)\n\tat sun.net.www.http.HttpClient$1.run(HttpClient.java:484)\n\tat sun.net.www.http.HttpClient$1.run(HttpClient.java:482)\n\tat java.security.AccessController.doPrivileged(Native Method)\n\tat sun.net.www.http.HttpClient.privilegedOpenServer(HttpClient.java:481)\n\tat sun.net.www.http.HttpClient.openServer(HttpClient.java:522)\n\tat sun.net.www.http.HttpClient.\u003cinit\u003e(HttpClient.java:211)\n\tat sun.net.www.http.HttpClient.New(HttpClient.java:308)\n\tat sun.net.www.http.HttpClient.New(HttpClient.java:326)\n\tat sun.net.www.protocol.http.HttpURLConnection.getNewHttpClient(HttpURLConnection.java:1169)\n\tat sun.net.www.protocol.http.HttpURLConnection.plainConnect0(HttpURLConnection.java:1148)\n\tat sun.net.www.protocol.http.HttpURLConnection.plainConnect(HttpURLConnection.java:999)\n\tat sun.net.www.protocol.http.HttpURLConnection.connect(HttpURLConnection.java:933)\n\tat org.zaproxy.clientapi.core.ClientApi.getConnectionInputStream(ClientApi.java:313)\n\tat org.zaproxy.clientapi.core.ClientApi.callApiDom(ClientApi.java:305)\n\t... 44 more\n",
  "status": "failed"
});
formatter.match({
  "location": "probeidentifiedpotentialentrypointsforxssvulnerability.tryprobeidentifiedpotentialentrypointsforxssvulnerability()"
});
formatter.result({
  "status": "skipped"
});
formatter.match({
  "location": "probeidentifiedpotentialentrypointsforxssvulnerability.assprobeidentifiedpotentialentrypointsforxssvulnerability()"
});
formatter.result({
  "status": "skipped"
});
formatter.match({
  "location": "PatternSteps.asssecurelogger()"
});
formatter.result({
  "status": "skipped"
});
formatter.match({
  "location": "PatternSteps.assapplicationfirewall()"
});
formatter.result({
  "status": "skipped"
});
formatter.match({
  "location": "PatternSteps.assinputguard()"
});
formatter.result({
  "status": "skipped"
});
formatter.match({
  "location": "PatternSteps.assoutputguard()"
});
formatter.result({
  "status": "skipped"
});
formatter.match({
  "location": "PatternSteps.asscomparatorcheckedfaulttolerantsystem()"
});
formatter.result({
  "status": "skipped"
});
formatter.match({
  "location": "PatternSteps.assauditinterceptor()"
});
formatter.result({
  "status": "skipped"
});
formatter.uri("CAPEC_63_Step_3_1.feature");
formatter.feature({
  "line": 2,
  "name": "CAPEC-63: Simple Script Injection",
  "description": "",
  "id": "capec-63:-simple-script-injection",
  "keyword": "Feature",
  "tags": [
    {
      "line": 1,
      "name": "@capec63"
    }
  ]
});
formatter.scenario({
  "comments": [
    {
      "line": 3,
      "value": "#3. Exploit"
    }
  ],
  "line": 4,
  "name": "Step3.1 Steal session IDs, credentials, page content, etc.",
  "description": "",
  "id": "capec-63:-simple-script-injection;step3.1-steal-session-ids,-credentials,-page-content,-etc.",
  "type": "scenario",
  "keyword": "Scenario"
});
formatter.step({
  "line": 5,
  "name": "prepare to Steal session IDs, credentials, page content, etc.",
  "keyword": "Given "
});
formatter.step({
  "line": 6,
  "name": "Try to Steal session IDs, credentials, page content, etc.",
  "keyword": "When "
});
formatter.step({
  "comments": [
    {
      "line": 7,
      "value": "# assertion for attack step success"
    }
  ],
  "line": 8,
  "name": "Assert the success of Steal session IDs, credentials, page content, etc.",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 9,
      "value": "#assertions for security pattern testing (checker whether the pattern consequences are observed)"
    }
  ],
  "line": 10,
  "name": "assert the consequences of the pattern audit interceptor",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 11,
      "value": "# depends secure logger"
    }
  ],
  "line": 12,
  "name": "assert the consequences of the pattern secure logger",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 13,
      "value": "# benifits audit interceptor"
    }
  ],
  "line": 14,
  "name": "assert the consequences of the pattern application firewall",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 15,
      "value": "# alternative output guard"
    },
    {
      "line": 16,
      "value": "# alternative input guard"
    }
  ],
  "line": 17,
  "name": "assert the consequences of the pattern input guard",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 18,
      "value": "# alternative application firewall"
    },
    {
      "line": 19,
      "value": "# benifits output guard"
    }
  ],
  "line": 20,
  "name": "assert the consequences of the pattern output guard",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 21,
      "value": "# alternative application firewall"
    },
    {
      "line": 22,
      "value": "# benifits input guard"
    }
  ],
  "line": 23,
  "name": "assert the consequences of the pattern comparator checked fault tolerant system",
  "keyword": "Then "
});
formatter.match({
  "location": "stealsessionidscredentialspagecontentetc.prestealsessionidscredentialspagecontentetc()"
});
formatter.result({
  "duration": 23385,
  "status": "passed"
});
formatter.match({
  "location": "stealsessionidscredentialspagecontentetc.trystealsessionidscredentialspagecontentetc()"
});
formatter.result({
  "duration": 4077,
  "status": "passed"
});
formatter.match({
  "location": "stealsessionidscredentialspagecontentetc.assstealsessionidscredentialspagecontentetc()"
});
formatter.result({
  "duration": 3354,
  "status": "passed"
});
formatter.match({
  "location": "PatternSteps.assauditinterceptor()"
});
formatter.result({
  "duration": 16922,
  "status": "passed"
});
formatter.match({
  "location": "PatternSteps.asssecurelogger()"
});
formatter.result({
  "duration": 4112,
  "status": "passed"
});
formatter.match({
  "location": "PatternSteps.assapplicationfirewall()"
});
formatter.result({
  "duration": 3854,
  "status": "passed"
});
formatter.match({
  "location": "PatternSteps.assinputguard()"
});
formatter.result({
  "duration": 3105,
  "status": "passed"
});
formatter.match({
  "location": "PatternSteps.assoutputguard()"
});
formatter.result({
  "duration": 3690,
  "status": "passed"
});
formatter.match({
  "location": "PatternSteps.asscomparatorcheckedfaulttolerantsystem()"
});
formatter.result({
  "duration": 3424,
  "status": "passed"
});
formatter.uri("CAPEC_63_Step_3_2.feature");
formatter.feature({
  "line": 2,
  "name": "CAPEC-63: Simple Script Injection",
  "description": "",
  "id": "capec-63:-simple-script-injection",
  "keyword": "Feature",
  "tags": [
    {
      "line": 1,
      "name": "@capec63"
    }
  ]
});
formatter.scenario({
  "comments": [
    {
      "line": 3,
      "value": "#3. Exploit"
    }
  ],
  "line": 4,
  "name": "Step3.2 Forceful browsing",
  "description": "",
  "id": "capec-63:-simple-script-injection;step3.2-forceful-browsing",
  "type": "scenario",
  "keyword": "Scenario"
});
formatter.step({
  "line": 5,
  "name": "prepare to Forceful browsing",
  "keyword": "Given "
});
formatter.step({
  "line": 6,
  "name": "Try to Forceful browsing",
  "keyword": "When "
});
formatter.step({
  "comments": [
    {
      "line": 7,
      "value": "# assertion for attack step success"
    }
  ],
  "line": 8,
  "name": "Assert the success of Forceful browsing",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 9,
      "value": "#assertions for security pattern testing (checker whether the pattern consequences are observed)"
    }
  ],
  "line": 10,
  "name": "assert the consequences of the pattern audit interceptor",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 11,
      "value": "# depends secure logger"
    }
  ],
  "line": 12,
  "name": "assert the consequences of the pattern secure logger",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 13,
      "value": "# benifits audit interceptor"
    }
  ],
  "line": 14,
  "name": "assert the consequences of the pattern application firewall",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 15,
      "value": "# alternative output guard"
    },
    {
      "line": 16,
      "value": "# alternative input guard"
    }
  ],
  "line": 17,
  "name": "assert the consequences of the pattern input guard",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 18,
      "value": "# alternative application firewall"
    },
    {
      "line": 19,
      "value": "# benifits output guard"
    }
  ],
  "line": 20,
  "name": "assert the consequences of the pattern output guard",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 21,
      "value": "# alternative application firewall"
    },
    {
      "line": 22,
      "value": "# benifits input guard"
    }
  ],
  "line": 23,
  "name": "assert the consequences of the pattern comparator checked fault tolerant system",
  "keyword": "Then "
});
formatter.match({
  "location": "forcefulbrowsing.preforcefulbrowsing()"
});
formatter.result({
  "duration": 32173,
  "status": "passed"
});
formatter.match({
  "location": "forcefulbrowsing.tryforcefulbrowsing()"
});
formatter.result({
  "duration": 5047,
  "status": "passed"
});
formatter.match({
  "location": "forcefulbrowsing.assforcefulbrowsing()"
});
formatter.result({
  "duration": 4933,
  "status": "passed"
});
formatter.match({
  "location": "PatternSteps.assauditinterceptor()"
});
formatter.result({
  "duration": 14852,
  "status": "passed"
});
formatter.match({
  "location": "PatternSteps.asssecurelogger()"
});
formatter.result({
  "duration": 5678,
  "status": "passed"
});
formatter.match({
  "location": "PatternSteps.assapplicationfirewall()"
});
formatter.result({
  "duration": 6074,
  "status": "passed"
});
formatter.match({
  "location": "PatternSteps.assinputguard()"
});
formatter.result({
  "duration": 5760,
  "status": "passed"
});
formatter.match({
  "location": "PatternSteps.assoutputguard()"
});
formatter.result({
  "duration": 5574,
  "status": "passed"
});
formatter.match({
  "location": "PatternSteps.asscomparatorcheckedfaulttolerantsystem()"
});
formatter.result({
  "duration": 4843,
  "status": "passed"
});
formatter.uri("CAPEC_63_Step_3_3.feature");
formatter.feature({
  "line": 2,
  "name": "CAPEC-63: Simple Script Injection",
  "description": "",
  "id": "capec-63:-simple-script-injection",
  "keyword": "Feature",
  "tags": [
    {
      "line": 1,
      "name": "@capec63"
    }
  ]
});
formatter.scenario({
  "comments": [
    {
      "line": 3,
      "value": "#3. Exploit"
    }
  ],
  "line": 4,
  "name": "Step3.3 Content spoofing",
  "description": "",
  "id": "capec-63:-simple-script-injection;step3.3-content-spoofing",
  "type": "scenario",
  "keyword": "Scenario"
});
formatter.step({
  "line": 5,
  "name": "prepare to Content spoofing",
  "keyword": "Given "
});
formatter.step({
  "line": 6,
  "name": "Try to Content spoofing",
  "keyword": "When "
});
formatter.step({
  "comments": [
    {
      "line": 7,
      "value": "# assertion for attack step success"
    }
  ],
  "line": 8,
  "name": "Assert the success of Content spoofing",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 9,
      "value": "#assertions for security pattern testing (checker whether the pattern consequences are observed)"
    }
  ],
  "line": 10,
  "name": "assert the consequences of the pattern audit interceptor",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 11,
      "value": "# depends secure logger"
    }
  ],
  "line": 12,
  "name": "assert the consequences of the pattern secure logger",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 13,
      "value": "# benifits audit interceptor"
    }
  ],
  "line": 14,
  "name": "assert the consequences of the pattern application firewall",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 15,
      "value": "# alternative output guard"
    },
    {
      "line": 16,
      "value": "# alternative input guard"
    }
  ],
  "line": 17,
  "name": "assert the consequences of the pattern input guard",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 18,
      "value": "# alternative application firewall"
    },
    {
      "line": 19,
      "value": "# benifits output guard"
    }
  ],
  "line": 20,
  "name": "assert the consequences of the pattern output guard",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 21,
      "value": "# alternative application firewall"
    },
    {
      "line": 22,
      "value": "# benifits input guard"
    }
  ],
  "line": 23,
  "name": "assert the consequences of the pattern comparator checked fault tolerant system",
  "keyword": "Then "
});
formatter.match({
  "location": "contentspoofing.precontentspoofing()"
});
formatter.result({
  "duration": 30805,
  "status": "passed"
});
formatter.match({
  "location": "contentspoofing.trycontentspoofing()"
});
formatter.result({
  "duration": 6021,
  "status": "passed"
});
formatter.match({
  "location": "contentspoofing.asscontentspoofing()"
});
formatter.result({
  "duration": 3938,
  "status": "passed"
});
formatter.match({
  "location": "PatternSteps.assauditinterceptor()"
});
formatter.result({
  "duration": 14916,
  "status": "passed"
});
formatter.match({
  "location": "PatternSteps.asssecurelogger()"
});
formatter.result({
  "duration": 3962,
  "status": "passed"
});
formatter.match({
  "location": "PatternSteps.assapplicationfirewall()"
});
formatter.result({
  "duration": 4087,
  "status": "passed"
});
formatter.match({
  "location": "PatternSteps.assinputguard()"
});
formatter.result({
  "duration": 3324,
  "status": "passed"
});
formatter.match({
  "location": "PatternSteps.assoutputguard()"
});
formatter.result({
  "duration": 3365,
  "status": "passed"
});
formatter.match({
  "location": "PatternSteps.asscomparatorcheckedfaulttolerantsystem()"
});
formatter.result({
  "duration": 3647,
  "status": "passed"
});
formatter.uri("CAPEC_64_Step_1_1.feature");
formatter.feature({
  "line": 2,
  "name": "CAPEC-64: Using Slashes and URL Encoding Combined to Bypass Validation Logic",
  "description": "",
  "id": "capec-64:-using-slashes-and-url-encoding-combined-to-bypass-validation-logic",
  "keyword": "Feature",
  "tags": [
    {
      "line": 1,
      "name": "@capec64"
    }
  ]
});
formatter.scenario({
  "comments": [
    {
      "line": 3,
      "value": "#1. Explore"
    }
  ],
  "line": 4,
  "name": "Step1.1",
  "description": "",
  "id": "capec-64:-using-slashes-and-url-encoding-combined-to-bypass-validation-logic;step1.1",
  "type": "scenario",
  "keyword": "Scenario"
});
formatter.step({
  "line": 5,
  "name": "prepare to",
  "keyword": "Given "
});
formatter.step({
  "line": 6,
  "name": "Try to",
  "keyword": "When "
});
formatter.step({
  "comments": [
    {
      "line": 7,
      "value": "# assertion for attack step success"
    }
  ],
  "line": 8,
  "name": "Assert the success of",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 9,
      "value": "#assertions for security pattern testing (checker whether the pattern consequences are observed)"
    }
  ],
  "line": 10,
  "name": "assert the consequences of the pattern",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 11,
      "value": "#"
    }
  ],
  "line": 12,
  "name": "assert the consequences of the pattern audit interceptor",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 13,
      "value": "# depends secure logger"
    }
  ],
  "line": 14,
  "name": "assert the consequences of the pattern secure logger",
  "keyword": "Then "
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({
  "location": "PatternSteps.assauditinterceptor()"
});
formatter.result({
  "status": "skipped"
});
formatter.match({
  "location": "PatternSteps.asssecurelogger()"
});
formatter.result({
  "status": "skipped"
});
formatter.uri("CAPEC_64_Step_2_1.feature");
formatter.feature({
  "line": 2,
  "name": "CAPEC-64: Using Slashes and URL Encoding Combined to Bypass Validation Logic",
  "description": "",
  "id": "capec-64:-using-slashes-and-url-encoding-combined-to-bypass-validation-logic",
  "keyword": "Feature",
  "tags": [
    {
      "line": 1,
      "name": "@capec64"
    }
  ]
});
formatter.scenario({
  "comments": [
    {
      "line": 3,
      "value": "#2. Experiment"
    }
  ],
  "line": 4,
  "name": "Step2.1",
  "description": "",
  "id": "capec-64:-using-slashes-and-url-encoding-combined-to-bypass-validation-logic;step2.1",
  "type": "scenario",
  "keyword": "Scenario"
});
formatter.step({
  "line": 5,
  "name": "prepare to",
  "keyword": "Given "
});
formatter.step({
  "line": 6,
  "name": "Try to",
  "keyword": "When "
});
formatter.step({
  "comments": [
    {
      "line": 7,
      "value": "# assertion for attack step success"
    }
  ],
  "line": 8,
  "name": "Assert the success of",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 9,
      "value": "#assertions for security pattern testing (checker whether the pattern consequences are observed)"
    }
  ],
  "line": 10,
  "name": "assert the consequences of the pattern",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 11,
      "value": "#"
    }
  ],
  "line": 12,
  "name": "assert the consequences of the pattern audit interceptor",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 13,
      "value": "# depends secure logger"
    }
  ],
  "line": 14,
  "name": "assert the consequences of the pattern secure logger",
  "keyword": "Then "
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({
  "location": "PatternSteps.assauditinterceptor()"
});
formatter.result({
  "status": "skipped"
});
formatter.match({
  "location": "PatternSteps.asssecurelogger()"
});
formatter.result({
  "status": "skipped"
});
formatter.uri("CAPEC_64_Step_3_1.feature");
formatter.feature({
  "line": 2,
  "name": "CAPEC-64: Using Slashes and URL Encoding Combined to Bypass Validation Logic",
  "description": "",
  "id": "capec-64:-using-slashes-and-url-encoding-combined-to-bypass-validation-logic",
  "keyword": "Feature",
  "tags": [
    {
      "line": 1,
      "name": "@capec64"
    }
  ]
});
formatter.scenario({
  "comments": [
    {
      "line": 3,
      "value": "#3. Exploit"
    }
  ],
  "line": 4,
  "name": "Step3.1",
  "description": "",
  "id": "capec-64:-using-slashes-and-url-encoding-combined-to-bypass-validation-logic;step3.1",
  "type": "scenario",
  "keyword": "Scenario"
});
formatter.step({
  "line": 5,
  "name": "prepare to",
  "keyword": "Given "
});
formatter.step({
  "line": 6,
  "name": "Try to",
  "keyword": "When "
});
formatter.step({
  "comments": [
    {
      "line": 7,
      "value": "# assertion for attack step success"
    }
  ],
  "line": 8,
  "name": "Assert the success of",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 9,
      "value": "#assertions for security pattern testing (checker whether the pattern consequences are observed)"
    }
  ],
  "line": 10,
  "name": "assert the consequences of the pattern",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 11,
      "value": "#"
    }
  ],
  "line": 12,
  "name": "assert the consequences of the pattern audit interceptor",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 13,
      "value": "# depends secure logger"
    }
  ],
  "line": 14,
  "name": "assert the consequences of the pattern secure logger",
  "keyword": "Then "
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({
  "location": "PatternSteps.assauditinterceptor()"
});
formatter.result({
  "status": "skipped"
});
formatter.match({
  "location": "PatternSteps.asssecurelogger()"
});
formatter.result({
  "status": "skipped"
});
formatter.uri("CAPEC_65_Step_1_1.feature");
formatter.feature({
  "line": 2,
  "name": "CAPEC-65: Sniff Application Code",
  "description": "",
  "id": "capec-65:-sniff-application-code",
  "keyword": "Feature",
  "tags": [
    {
      "line": 1,
      "name": "@capec65"
    }
  ]
});
formatter.scenario({
  "comments": [
    {
      "line": 3,
      "value": "#1. Explore"
    }
  ],
  "line": 4,
  "name": "Step1.1",
  "description": "",
  "id": "capec-65:-sniff-application-code;step1.1",
  "type": "scenario",
  "keyword": "Scenario"
});
formatter.step({
  "line": 5,
  "name": "prepare to",
  "keyword": "Given "
});
formatter.step({
  "line": 6,
  "name": "Try to",
  "keyword": "When "
});
formatter.step({
  "comments": [
    {
      "line": 7,
      "value": "# assertion for attack step success"
    }
  ],
  "line": 8,
  "name": "Assert the success of",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 9,
      "value": "#assertions for security pattern testing (checker whether the pattern consequences are observed)"
    }
  ],
  "line": 10,
  "name": "assert the consequences of the pattern",
  "keyword": "Then "
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.uri("CAPEC_65_Step_2_1.feature");
formatter.feature({
  "line": 2,
  "name": "CAPEC-65: Sniff Application Code",
  "description": "",
  "id": "capec-65:-sniff-application-code",
  "keyword": "Feature",
  "tags": [
    {
      "line": 1,
      "name": "@capec65"
    }
  ]
});
formatter.scenario({
  "comments": [
    {
      "line": 3,
      "value": "#2. Exploit"
    }
  ],
  "line": 4,
  "name": "Step2.1",
  "description": "",
  "id": "capec-65:-sniff-application-code;step2.1",
  "type": "scenario",
  "keyword": "Scenario"
});
formatter.step({
  "line": 5,
  "name": "prepare to",
  "keyword": "Given "
});
formatter.step({
  "line": 6,
  "name": "Try to",
  "keyword": "When "
});
formatter.step({
  "comments": [
    {
      "line": 7,
      "value": "# assertion for attack step success"
    }
  ],
  "line": 8,
  "name": "Assert the success of",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 9,
      "value": "#assertions for security pattern testing (checker whether the pattern consequences are observed)"
    }
  ],
  "line": 10,
  "name": "assert the consequences of the pattern",
  "keyword": "Then "
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.uri("CAPEC_66_Step_1_1.feature");
formatter.feature({
  "line": 2,
  "name": "CAPEC-66: SQL Injection",
  "description": "",
  "id": "capec-66:-sql-injection",
  "keyword": "Feature",
  "tags": [
    {
      "line": 1,
      "name": "@capec66"
    }
  ]
});
formatter.scenario({
  "comments": [
    {
      "line": 3,
      "value": "#1. Explore"
    }
  ],
  "line": 4,
  "name": "Step1.1 Survey application",
  "description": "",
  "id": "capec-66:-sql-injection;step1.1-survey-application",
  "type": "scenario",
  "keyword": "Scenario"
});
formatter.step({
  "line": 5,
  "name": "prepare to Survey application",
  "keyword": "Given "
});
formatter.step({
  "line": 6,
  "name": "Try to Survey application",
  "keyword": "When "
});
formatter.step({
  "comments": [
    {
      "line": 7,
      "value": "# assertion for attack step success"
    }
  ],
  "line": 8,
  "name": "Assert the success of Survey application",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 9,
      "value": "#assertions for security pattern testing (checker whether the pattern consequences are observed)"
    }
  ],
  "line": 10,
  "name": "assert the consequences of the pattern audit interceptor",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 11,
      "value": "# depends secure logger"
    }
  ],
  "line": 12,
  "name": "assert the consequences of the pattern secure logger",
  "keyword": "Then "
});
formatter.match({
  "location": "survey.presurvey()"
});
formatter.result({
  "duration": 0,
  "error_message": "cucumber.runtime.AmbiguousStepDefinitionsException: ✽.Given prepare to Survey application(CAPEC_66_Step_1_1.feature:5) matches more than one step definition:\n  prepare to Survey in survey.presurvey()\n  prepare to Survey application in surveyapplication.presurveyapplication()\n\n\tat cucumber.runtime.RuntimeGlue.stepDefinitionMatch(RuntimeGlue.java:71)\n\tat cucumber.runtime.Runtime.runStep(Runtime.java:265)\n\tat cucumber.runtime.model.StepContainer.runStep(StepContainer.java:44)\n\tat cucumber.runtime.model.StepContainer.runSteps(StepContainer.java:39)\n\tat cucumber.runtime.model.CucumberScenario.run(CucumberScenario.java:48)\n\tat cucumber.runtime.junit.ExecutionUnitRunner.run(ExecutionUnitRunner.java:91)\n\tat cucumber.runtime.junit.FeatureRunner.runChild(FeatureRunner.java:63)\n\tat cucumber.runtime.junit.FeatureRunner.runChild(FeatureRunner.java:18)\n\tat org.junit.runners.ParentRunner$3.run(ParentRunner.java:238)\n\tat org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:63)\n\tat org.junit.runners.ParentRunner.runChildren(ParentRunner.java:236)\n\tat org.junit.runners.ParentRunner.access$000(ParentRunner.java:53)\n\tat org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:229)\n\tat org.junit.runners.ParentRunner.run(ParentRunner.java:309)\n\tat cucumber.runtime.junit.FeatureRunner.run(FeatureRunner.java:70)\n\tat cucumber.api.junit.Cucumber.runChild(Cucumber.java:93)\n\tat cucumber.api.junit.Cucumber.runChild(Cucumber.java:37)\n\tat org.junit.runners.ParentRunner$3.run(ParentRunner.java:238)\n\tat org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:63)\n\tat org.junit.runners.ParentRunner.runChildren(ParentRunner.java:236)\n\tat org.junit.runners.ParentRunner.access$000(ParentRunner.java:53)\n\tat org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:229)\n\tat org.junit.internal.runners.statements.RunAfters.evaluate(RunAfters.java:27)\n\tat org.junit.runners.ParentRunner.run(ParentRunner.java:309)\n\tat cucumber.api.junit.Cucumber.run(Cucumber.java:98)\n\tat org.eclipse.jdt.internal.junit4.runner.JUnit4TestReference.run(JUnit4TestReference.java:86)\n\tat org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:459)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:678)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:382)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:192)\n",
  "status": "failed"
});
formatter.match({
  "location": "survey.trysurvey()"
});
formatter.result({
  "duration": 0,
  "error_message": "cucumber.runtime.AmbiguousStepDefinitionsException: ✽.When Try to Survey application(CAPEC_66_Step_1_1.feature:6) matches more than one step definition:\n  Try to Survey in survey.trysurvey()\n  Try to Survey application in surveyapplication.trysurveyapplication()\n\n\tat cucumber.runtime.RuntimeGlue.stepDefinitionMatch(RuntimeGlue.java:71)\n\tat cucumber.runtime.Runtime.runStep(Runtime.java:265)\n\tat cucumber.runtime.model.StepContainer.runStep(StepContainer.java:44)\n\tat cucumber.runtime.model.StepContainer.runSteps(StepContainer.java:39)\n\tat cucumber.runtime.model.CucumberScenario.run(CucumberScenario.java:48)\n\tat cucumber.runtime.junit.ExecutionUnitRunner.run(ExecutionUnitRunner.java:91)\n\tat cucumber.runtime.junit.FeatureRunner.runChild(FeatureRunner.java:63)\n\tat cucumber.runtime.junit.FeatureRunner.runChild(FeatureRunner.java:18)\n\tat org.junit.runners.ParentRunner$3.run(ParentRunner.java:238)\n\tat org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:63)\n\tat org.junit.runners.ParentRunner.runChildren(ParentRunner.java:236)\n\tat org.junit.runners.ParentRunner.access$000(ParentRunner.java:53)\n\tat org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:229)\n\tat org.junit.runners.ParentRunner.run(ParentRunner.java:309)\n\tat cucumber.runtime.junit.FeatureRunner.run(FeatureRunner.java:70)\n\tat cucumber.api.junit.Cucumber.runChild(Cucumber.java:93)\n\tat cucumber.api.junit.Cucumber.runChild(Cucumber.java:37)\n\tat org.junit.runners.ParentRunner$3.run(ParentRunner.java:238)\n\tat org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:63)\n\tat org.junit.runners.ParentRunner.runChildren(ParentRunner.java:236)\n\tat org.junit.runners.ParentRunner.access$000(ParentRunner.java:53)\n\tat org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:229)\n\tat org.junit.internal.runners.statements.RunAfters.evaluate(RunAfters.java:27)\n\tat org.junit.runners.ParentRunner.run(ParentRunner.java:309)\n\tat cucumber.api.junit.Cucumber.run(Cucumber.java:98)\n\tat org.eclipse.jdt.internal.junit4.runner.JUnit4TestReference.run(JUnit4TestReference.java:86)\n\tat org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:459)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:678)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:382)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:192)\n",
  "status": "failed"
});
formatter.match({
  "location": "survey.asssurvey()"
});
formatter.result({
  "duration": 0,
  "error_message": "cucumber.runtime.AmbiguousStepDefinitionsException: ✽.Then Assert the success of Survey application(CAPEC_66_Step_1_1.feature:8) matches more than one step definition:\n  Assert the success of Survey in survey.asssurvey()\n  Assert the success of Survey application in surveyapplication.asssurveyapplication()\n\n\tat cucumber.runtime.RuntimeGlue.stepDefinitionMatch(RuntimeGlue.java:71)\n\tat cucumber.runtime.Runtime.runStep(Runtime.java:265)\n\tat cucumber.runtime.model.StepContainer.runStep(StepContainer.java:44)\n\tat cucumber.runtime.model.StepContainer.runSteps(StepContainer.java:39)\n\tat cucumber.runtime.model.CucumberScenario.run(CucumberScenario.java:48)\n\tat cucumber.runtime.junit.ExecutionUnitRunner.run(ExecutionUnitRunner.java:91)\n\tat cucumber.runtime.junit.FeatureRunner.runChild(FeatureRunner.java:63)\n\tat cucumber.runtime.junit.FeatureRunner.runChild(FeatureRunner.java:18)\n\tat org.junit.runners.ParentRunner$3.run(ParentRunner.java:238)\n\tat org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:63)\n\tat org.junit.runners.ParentRunner.runChildren(ParentRunner.java:236)\n\tat org.junit.runners.ParentRunner.access$000(ParentRunner.java:53)\n\tat org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:229)\n\tat org.junit.runners.ParentRunner.run(ParentRunner.java:309)\n\tat cucumber.runtime.junit.FeatureRunner.run(FeatureRunner.java:70)\n\tat cucumber.api.junit.Cucumber.runChild(Cucumber.java:93)\n\tat cucumber.api.junit.Cucumber.runChild(Cucumber.java:37)\n\tat org.junit.runners.ParentRunner$3.run(ParentRunner.java:238)\n\tat org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:63)\n\tat org.junit.runners.ParentRunner.runChildren(ParentRunner.java:236)\n\tat org.junit.runners.ParentRunner.access$000(ParentRunner.java:53)\n\tat org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:229)\n\tat org.junit.internal.runners.statements.RunAfters.evaluate(RunAfters.java:27)\n\tat org.junit.runners.ParentRunner.run(ParentRunner.java:309)\n\tat cucumber.api.junit.Cucumber.run(Cucumber.java:98)\n\tat org.eclipse.jdt.internal.junit4.runner.JUnit4TestReference.run(JUnit4TestReference.java:86)\n\tat org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:459)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:678)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:382)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:192)\n",
  "status": "failed"
});
formatter.match({
  "location": "PatternSteps.assauditinterceptor()"
});
formatter.result({
  "status": "skipped"
});
formatter.match({
  "location": "PatternSteps.asssecurelogger()"
});
formatter.result({
  "status": "skipped"
});
formatter.uri("CAPEC_66_Step_2_1.feature");
formatter.feature({
  "line": 2,
  "name": "CAPEC-66: SQL Injection",
  "description": "",
  "id": "capec-66:-sql-injection",
  "keyword": "Feature",
  "tags": [
    {
      "line": 1,
      "name": "@capec66"
    }
  ]
});
formatter.scenario({
  "comments": [
    {
      "line": 3,
      "value": "#2. Experiment"
    }
  ],
  "line": 4,
  "name": "Step2.1 Determine user-controllable input susceptible to injection",
  "description": "",
  "id": "capec-66:-sql-injection;step2.1-determine-user-controllable-input-susceptible-to-injection",
  "type": "scenario",
  "keyword": "Scenario"
});
formatter.step({
  "line": 5,
  "name": "prepare to Determine user-controllable input susceptible to injection",
  "keyword": "Given "
});
formatter.step({
  "line": 6,
  "name": "Try to Determine user-controllable input susceptible to injection",
  "keyword": "When "
});
formatter.step({
  "comments": [
    {
      "line": 7,
      "value": "# assertion for attack step success"
    }
  ],
  "line": 8,
  "name": "Assert the success of Determine user-controllable input susceptible to injection",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 9,
      "value": "#assertions for security pattern testing (checker whether the pattern consequences are observed)"
    }
  ],
  "line": 10,
  "name": "assert the consequences of the pattern input guard",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 11,
      "value": "# alternative application firewall"
    }
  ],
  "line": 12,
  "name": "assert the consequences of the pattern secure logger",
  "keyword": "Then "
});
formatter.match({
  "location": "determineusercontrollableinputsusceptibletoinjection.predetermineusercontrollableinputsusceptibletoinjection()"
});
formatter.result({
  "duration": 1660899,
  "error_message": "net.continuumsecurity.proxy.ProxyException: org.zaproxy.clientapi.core.ClientApiException: java.net.ConnectException: Connection refused\n\tat net.continuumsecurity.proxy.ZAProxyScanner.validateMinimumRequiredZapVersion(ZAProxyScanner.java:96)\n\tat net.continuumsecurity.proxy.ZAProxyScanner.\u003cinit\u003e(ZAProxyScanner.java:38)\n\tat steps.determineusercontrollableinputsusceptibletoinjection.predetermineusercontrollableinputsusceptibletoinjection(determineusercontrollableinputsusceptibletoinjection.java:23)\n\tat ✽.Given prepare to Determine user-controllable input susceptible to injection(CAPEC_66_Step_2_1.feature:5)\nCaused by: org.zaproxy.clientapi.core.ClientApiException: java.net.ConnectException: Connection refused\n\tat org.zaproxy.clientapi.core.ClientApi.callApiDom(ClientApi.java:307)\n\tat org.zaproxy.clientapi.core.ClientApi.callApi(ClientApi.java:289)\n\tat org.zaproxy.clientapi.gen.Core.version(Core.java:158)\n\tat net.continuumsecurity.proxy.ZAProxyScanner.validateMinimumRequiredZapVersion(ZAProxyScanner.java:85)\n\tat net.continuumsecurity.proxy.ZAProxyScanner.\u003cinit\u003e(ZAProxyScanner.java:38)\n\tat steps.determineusercontrollableinputsusceptibletoinjection.predetermineusercontrollableinputsusceptibletoinjection(determineusercontrollableinputsusceptibletoinjection.java:23)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.lang.reflect.Method.invoke(Method.java:498)\n\tat cucumber.runtime.Utils$1.call(Utils.java:37)\n\tat cucumber.runtime.Timeout.timeout(Timeout.java:13)\n\tat cucumber.runtime.Utils.invoke(Utils.java:31)\n\tat cucumber.runtime.java.JavaStepDefinition.execute(JavaStepDefinition.java:37)\n\tat cucumber.runtime.StepDefinitionMatch.runStep(StepDefinitionMatch.java:37)\n\tat cucumber.runtime.Runtime.runStep(Runtime.java:298)\n\tat cucumber.runtime.model.StepContainer.runStep(StepContainer.java:44)\n\tat cucumber.runtime.model.StepContainer.runSteps(StepContainer.java:39)\n\tat cucumber.runtime.model.CucumberScenario.run(CucumberScenario.java:48)\n\tat cucumber.runtime.junit.ExecutionUnitRunner.run(ExecutionUnitRunner.java:91)\n\tat cucumber.runtime.junit.FeatureRunner.runChild(FeatureRunner.java:63)\n\tat cucumber.runtime.junit.FeatureRunner.runChild(FeatureRunner.java:18)\n\tat org.junit.runners.ParentRunner$3.run(ParentRunner.java:238)\n\tat org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:63)\n\tat org.junit.runners.ParentRunner.runChildren(ParentRunner.java:236)\n\tat org.junit.runners.ParentRunner.access$000(ParentRunner.java:53)\n\tat org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:229)\n\tat org.junit.runners.ParentRunner.run(ParentRunner.java:309)\n\tat cucumber.runtime.junit.FeatureRunner.run(FeatureRunner.java:70)\n\tat cucumber.api.junit.Cucumber.runChild(Cucumber.java:93)\n\tat cucumber.api.junit.Cucumber.runChild(Cucumber.java:37)\n\tat org.junit.runners.ParentRunner$3.run(ParentRunner.java:238)\n\tat org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:63)\n\tat org.junit.runners.ParentRunner.runChildren(ParentRunner.java:236)\n\tat org.junit.runners.ParentRunner.access$000(ParentRunner.java:53)\n\tat org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:229)\n\tat org.junit.internal.runners.statements.RunAfters.evaluate(RunAfters.java:27)\n\tat org.junit.runners.ParentRunner.run(ParentRunner.java:309)\n\tat cucumber.api.junit.Cucumber.run(Cucumber.java:98)\n\tat org.eclipse.jdt.internal.junit4.runner.JUnit4TestReference.run(JUnit4TestReference.java:86)\n\tat org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:459)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:678)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:382)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:192)\nCaused by: java.net.ConnectException: Connection refused\n\tat java.net.PlainSocketImpl.socketConnect(Native Method)\n\tat java.net.AbstractPlainSocketImpl.doConnect(AbstractPlainSocketImpl.java:350)\n\tat java.net.AbstractPlainSocketImpl.connectToAddress(AbstractPlainSocketImpl.java:206)\n\tat java.net.AbstractPlainSocketImpl.connect(AbstractPlainSocketImpl.java:188)\n\tat java.net.Socket.connect(Socket.java:589)\n\tat java.net.Socket.connect(Socket.java:538)\n\tat sun.net.NetworkClient.doConnect(NetworkClient.java:180)\n\tat sun.net.www.http.HttpClient.openServer(HttpClient.java:432)\n\tat sun.net.www.http.HttpClient$1.run(HttpClient.java:484)\n\tat sun.net.www.http.HttpClient$1.run(HttpClient.java:482)\n\tat java.security.AccessController.doPrivileged(Native Method)\n\tat sun.net.www.http.HttpClient.privilegedOpenServer(HttpClient.java:481)\n\tat sun.net.www.http.HttpClient.openServer(HttpClient.java:522)\n\tat sun.net.www.http.HttpClient.\u003cinit\u003e(HttpClient.java:211)\n\tat sun.net.www.http.HttpClient.New(HttpClient.java:308)\n\tat sun.net.www.http.HttpClient.New(HttpClient.java:326)\n\tat sun.net.www.protocol.http.HttpURLConnection.getNewHttpClient(HttpURLConnection.java:1169)\n\tat sun.net.www.protocol.http.HttpURLConnection.plainConnect0(HttpURLConnection.java:1148)\n\tat sun.net.www.protocol.http.HttpURLConnection.plainConnect(HttpURLConnection.java:999)\n\tat sun.net.www.protocol.http.HttpURLConnection.connect(HttpURLConnection.java:933)\n\tat org.zaproxy.clientapi.core.ClientApi.getConnectionInputStream(ClientApi.java:313)\n\tat org.zaproxy.clientapi.core.ClientApi.callApiDom(ClientApi.java:305)\n\t... 44 more\n",
  "status": "failed"
});
formatter.match({
  "location": "determineusercontrollableinputsusceptibletoinjection.trydetermineusercontrollableinputsusceptibletoinjection()"
});
formatter.result({
  "status": "skipped"
});
formatter.match({
  "location": "determineusercontrollableinputsusceptibletoinjection.assdetermineusercontrollableinputsusceptibletoinjection()"
});
formatter.result({
  "status": "skipped"
});
formatter.match({
  "location": "PatternSteps.assinputguard()"
});
formatter.result({
  "status": "skipped"
});
formatter.match({
  "location": "PatternSteps.asssecurelogger()"
});
formatter.result({
  "status": "skipped"
});
formatter.uri("CAPEC_66_Step_2_2.feature");
formatter.feature({
  "line": 2,
  "name": "CAPEC-66: SQL Injection",
  "description": "",
  "id": "capec-66:-sql-injection",
  "keyword": "Feature",
  "tags": [
    {
      "line": 1,
      "name": "@capec66"
    }
  ]
});
formatter.scenario({
  "comments": [
    {
      "line": 3,
      "value": "#2. Experiment"
    }
  ],
  "line": 4,
  "name": "Step2.2 Experiment and try to exploit SQL Injection vulnerability",
  "description": "",
  "id": "capec-66:-sql-injection;step2.2-experiment-and-try-to-exploit-sql-injection-vulnerability",
  "type": "scenario",
  "keyword": "Scenario"
});
formatter.step({
  "line": 5,
  "name": "prepare to Experiment and try to exploit SQL Injection vulnerability",
  "keyword": "Given "
});
formatter.step({
  "line": 6,
  "name": "Try to Experiment and try to exploit SQL Injection vulnerability",
  "keyword": "When "
});
formatter.step({
  "comments": [
    {
      "line": 7,
      "value": "# assertion for attack step success"
    }
  ],
  "line": 8,
  "name": "Assert the success of Experiment and try to exploit SQL Injection vulnerability",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 9,
      "value": "#assertions for security pattern testing (checker whether the pattern consequences are observed)"
    }
  ],
  "line": 10,
  "name": "assert the consequences of the pattern",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 11,
      "value": "#"
    }
  ],
  "line": 12,
  "name": "assert the consequences of the pattern audit interceptor",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 13,
      "value": "# depends secure logger"
    }
  ],
  "line": 14,
  "name": "assert the consequences of the pattern secure logger",
  "keyword": "Then "
});
formatter.match({
  "location": "experimentandtrytoexploitsqlinjectionvulnerability.preexperimentandtrytoexploitsqlinjectionvulnerability()"
});
formatter.result({
  "duration": 46040,
  "status": "passed"
});
formatter.match({
  "location": "experimentandtrytoexploitsqlinjectionvulnerability.tryexperimentandtrytoexploitsqlinjectionvulnerability()"
});
formatter.result({
  "duration": 5375,
  "status": "passed"
});
formatter.match({
  "location": "experimentandtrytoexploitsqlinjectionvulnerability.assexperimentandtrytoexploitsqlinjectionvulnerability()"
});
formatter.result({
  "duration": 5226,
  "status": "passed"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({
  "location": "PatternSteps.assauditinterceptor()"
});
formatter.result({
  "status": "skipped"
});
formatter.match({
  "location": "PatternSteps.asssecurelogger()"
});
formatter.result({
  "status": "skipped"
});
formatter.uri("CAPEC_67_Step_1_1.feature");
formatter.feature({
  "line": 2,
  "name": "CAPEC-67: String Format Overflow in syslog()",
  "description": "",
  "id": "capec-67:-string-format-overflow-in-syslog()",
  "keyword": "Feature",
  "tags": [
    {
      "line": 1,
      "name": "@capec67"
    }
  ]
});
formatter.scenario({
  "comments": [
    {
      "line": 3,
      "value": "#1. Explore"
    }
  ],
  "line": 4,
  "name": "Step1.1",
  "description": "",
  "id": "capec-67:-string-format-overflow-in-syslog();step1.1",
  "type": "scenario",
  "keyword": "Scenario"
});
formatter.step({
  "line": 5,
  "name": "prepare to",
  "keyword": "Given "
});
formatter.step({
  "line": 6,
  "name": "Try to",
  "keyword": "When "
});
formatter.step({
  "comments": [
    {
      "line": 7,
      "value": "# assertion for attack step success"
    }
  ],
  "line": 8,
  "name": "Assert the success of",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 9,
      "value": "#assertions for security pattern testing (checker whether the pattern consequences are observed)"
    }
  ],
  "line": 10,
  "name": "assert the consequences of the pattern",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 11,
      "value": "#"
    }
  ],
  "line": 12,
  "name": "assert the consequences of the pattern audit interceptor",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 13,
      "value": "# depends secure logger"
    }
  ],
  "line": 14,
  "name": "assert the consequences of the pattern secure logger",
  "keyword": "Then "
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({
  "location": "PatternSteps.assauditinterceptor()"
});
formatter.result({
  "status": "skipped"
});
formatter.match({
  "location": "PatternSteps.asssecurelogger()"
});
formatter.result({
  "status": "skipped"
});
formatter.uri("CAPEC_67_Step_2_1.feature");
formatter.feature({
  "line": 2,
  "name": "CAPEC-67: String Format Overflow in syslog()",
  "description": "",
  "id": "capec-67:-string-format-overflow-in-syslog()",
  "keyword": "Feature",
  "tags": [
    {
      "line": 1,
      "name": "@capec67"
    }
  ]
});
formatter.scenario({
  "comments": [
    {
      "line": 3,
      "value": "#2. Exploit"
    }
  ],
  "line": 4,
  "name": "Step2.1",
  "description": "",
  "id": "capec-67:-string-format-overflow-in-syslog();step2.1",
  "type": "scenario",
  "keyword": "Scenario"
});
formatter.step({
  "line": 5,
  "name": "prepare to",
  "keyword": "Given "
});
formatter.step({
  "line": 6,
  "name": "Try to",
  "keyword": "When "
});
formatter.step({
  "comments": [
    {
      "line": 7,
      "value": "# assertion for attack step success"
    }
  ],
  "line": 8,
  "name": "Assert the success of",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 9,
      "value": "#assertions for security pattern testing (checker whether the pattern consequences are observed)"
    }
  ],
  "line": 10,
  "name": "assert the consequences of the pattern",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 11,
      "value": "#"
    }
  ],
  "line": 12,
  "name": "assert the consequences of the pattern audit interceptor",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 13,
      "value": "# depends secure logger"
    }
  ],
  "line": 14,
  "name": "assert the consequences of the pattern secure logger",
  "keyword": "Then "
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({
  "location": "PatternSteps.assauditinterceptor()"
});
formatter.result({
  "status": "skipped"
});
formatter.match({
  "location": "PatternSteps.asssecurelogger()"
});
formatter.result({
  "status": "skipped"
});
formatter.uri("CAPEC_69_Step_1_1.feature");
formatter.feature({
  "line": 2,
  "name": "CAPEC-69: Target Programs with Elevated Privileges",
  "description": "",
  "id": "capec-69:-target-programs-with-elevated-privileges",
  "keyword": "Feature",
  "tags": [
    {
      "line": 1,
      "name": "@capec69"
    }
  ]
});
formatter.scenario({
  "comments": [
    {
      "line": 3,
      "value": "#1. Explore"
    }
  ],
  "line": 4,
  "name": "Step1.1",
  "description": "",
  "id": "capec-69:-target-programs-with-elevated-privileges;step1.1",
  "type": "scenario",
  "keyword": "Scenario"
});
formatter.step({
  "line": 5,
  "name": "prepare to",
  "keyword": "Given "
});
formatter.step({
  "line": 6,
  "name": "Try to",
  "keyword": "When "
});
formatter.step({
  "comments": [
    {
      "line": 7,
      "value": "# assertion for attack step success"
    }
  ],
  "line": 8,
  "name": "Assert the success of",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 9,
      "value": "#assertions for security pattern testing (checker whether the pattern consequences are observed)"
    }
  ],
  "line": 10,
  "name": "assert the consequences of the pattern",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 11,
      "value": "#"
    }
  ],
  "line": 12,
  "name": "assert the consequences of the pattern audit interceptor",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 13,
      "value": "# depends secure logger"
    }
  ],
  "line": 14,
  "name": "assert the consequences of the pattern secure logger",
  "keyword": "Then "
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({
  "location": "PatternSteps.assauditinterceptor()"
});
formatter.result({
  "status": "skipped"
});
formatter.match({
  "location": "PatternSteps.asssecurelogger()"
});
formatter.result({
  "status": "skipped"
});
formatter.uri("CAPEC_69_Step_3_1.feature");
formatter.feature({
  "line": 2,
  "name": "CAPEC-69: Target Programs with Elevated Privileges",
  "description": "",
  "id": "capec-69:-target-programs-with-elevated-privileges",
  "keyword": "Feature",
  "tags": [
    {
      "line": 1,
      "name": "@capec69"
    }
  ]
});
formatter.scenario({
  "comments": [
    {
      "line": 3,
      "value": "#3. Exploit"
    }
  ],
  "line": 4,
  "name": "Step3.1",
  "description": "",
  "id": "capec-69:-target-programs-with-elevated-privileges;step3.1",
  "type": "scenario",
  "keyword": "Scenario"
});
formatter.step({
  "line": 5,
  "name": "prepare to",
  "keyword": "Given "
});
formatter.step({
  "line": 6,
  "name": "Try to",
  "keyword": "When "
});
formatter.step({
  "comments": [
    {
      "line": 7,
      "value": "# assertion for attack step success"
    }
  ],
  "line": 8,
  "name": "Assert the success of",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 9,
      "value": "#assertions for security pattern testing (checker whether the pattern consequences are observed)"
    }
  ],
  "line": 10,
  "name": "assert the consequences of the pattern",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 11,
      "value": "#"
    }
  ],
  "line": 12,
  "name": "assert the consequences of the pattern audit interceptor",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 13,
      "value": "# depends secure logger"
    }
  ],
  "line": 14,
  "name": "assert the consequences of the pattern secure logger",
  "keyword": "Then "
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({
  "location": "PatternSteps.assauditinterceptor()"
});
formatter.result({
  "status": "skipped"
});
formatter.match({
  "location": "PatternSteps.asssecurelogger()"
});
formatter.result({
  "status": "skipped"
});
formatter.uri("CAPEC_6_Step_1_1.feature");
formatter.feature({
  "line": 2,
  "name": "CAPEC-6: Argument Injection",
  "description": "",
  "id": "capec-6:-argument-injection",
  "keyword": "Feature",
  "tags": [
    {
      "line": 1,
      "name": "@capec6"
    }
  ]
});
formatter.scenario({
  "comments": [
    {
      "line": 3,
      "value": "#1. Explore"
    }
  ],
  "line": 4,
  "name": "Step1.1 Discovery of potential injection vectors",
  "description": "",
  "id": "capec-6:-argument-injection;step1.1-discovery-of-potential-injection-vectors",
  "type": "scenario",
  "keyword": "Scenario"
});
formatter.step({
  "line": 5,
  "name": "prepare to Discovery of potential injection vectors",
  "keyword": "Given "
});
formatter.step({
  "line": 6,
  "name": "Try to Discovery of potential injection vectors",
  "keyword": "When "
});
formatter.step({
  "comments": [
    {
      "line": 7,
      "value": "# assertion for attack step success"
    }
  ],
  "line": 8,
  "name": "Assert the success of Discovery of potential injection vectors",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 9,
      "value": "#assertions for security pattern testing (checker whether the pattern consequences are observed)"
    }
  ],
  "line": 10,
  "name": "assert the consequences of the pattern",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 11,
      "value": "#"
    }
  ],
  "line": 12,
  "name": "assert the consequences of the pattern audit interceptor",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 13,
      "value": "# depends secure logger"
    }
  ],
  "line": 14,
  "name": "assert the consequences of the pattern secure logger",
  "keyword": "Then "
});
formatter.match({
  "location": "discoveryofpotentialinjectionvectors.prediscoveryofpotentialinjectionvectors()"
});
formatter.result({
  "duration": 1563288,
  "error_message": "net.continuumsecurity.proxy.ProxyException: org.zaproxy.clientapi.core.ClientApiException: java.net.ConnectException: Connection refused\n\tat net.continuumsecurity.proxy.ZAProxyScanner.validateMinimumRequiredZapVersion(ZAProxyScanner.java:96)\n\tat net.continuumsecurity.proxy.ZAProxyScanner.\u003cinit\u003e(ZAProxyScanner.java:38)\n\tat steps.discoveryofpotentialinjectionvectors.prediscoveryofpotentialinjectionvectors(discoveryofpotentialinjectionvectors.java:17)\n\tat ✽.Given prepare to Discovery of potential injection vectors(CAPEC_6_Step_1_1.feature:5)\nCaused by: org.zaproxy.clientapi.core.ClientApiException: java.net.ConnectException: Connection refused\n\tat org.zaproxy.clientapi.core.ClientApi.callApiDom(ClientApi.java:307)\n\tat org.zaproxy.clientapi.core.ClientApi.callApi(ClientApi.java:289)\n\tat org.zaproxy.clientapi.gen.Core.version(Core.java:158)\n\tat net.continuumsecurity.proxy.ZAProxyScanner.validateMinimumRequiredZapVersion(ZAProxyScanner.java:85)\n\tat net.continuumsecurity.proxy.ZAProxyScanner.\u003cinit\u003e(ZAProxyScanner.java:38)\n\tat steps.discoveryofpotentialinjectionvectors.prediscoveryofpotentialinjectionvectors(discoveryofpotentialinjectionvectors.java:17)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.lang.reflect.Method.invoke(Method.java:498)\n\tat cucumber.runtime.Utils$1.call(Utils.java:37)\n\tat cucumber.runtime.Timeout.timeout(Timeout.java:13)\n\tat cucumber.runtime.Utils.invoke(Utils.java:31)\n\tat cucumber.runtime.java.JavaStepDefinition.execute(JavaStepDefinition.java:37)\n\tat cucumber.runtime.StepDefinitionMatch.runStep(StepDefinitionMatch.java:37)\n\tat cucumber.runtime.Runtime.runStep(Runtime.java:298)\n\tat cucumber.runtime.model.StepContainer.runStep(StepContainer.java:44)\n\tat cucumber.runtime.model.StepContainer.runSteps(StepContainer.java:39)\n\tat cucumber.runtime.model.CucumberScenario.run(CucumberScenario.java:48)\n\tat cucumber.runtime.junit.ExecutionUnitRunner.run(ExecutionUnitRunner.java:91)\n\tat cucumber.runtime.junit.FeatureRunner.runChild(FeatureRunner.java:63)\n\tat cucumber.runtime.junit.FeatureRunner.runChild(FeatureRunner.java:18)\n\tat org.junit.runners.ParentRunner$3.run(ParentRunner.java:238)\n\tat org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:63)\n\tat org.junit.runners.ParentRunner.runChildren(ParentRunner.java:236)\n\tat org.junit.runners.ParentRunner.access$000(ParentRunner.java:53)\n\tat org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:229)\n\tat org.junit.runners.ParentRunner.run(ParentRunner.java:309)\n\tat cucumber.runtime.junit.FeatureRunner.run(FeatureRunner.java:70)\n\tat cucumber.api.junit.Cucumber.runChild(Cucumber.java:93)\n\tat cucumber.api.junit.Cucumber.runChild(Cucumber.java:37)\n\tat org.junit.runners.ParentRunner$3.run(ParentRunner.java:238)\n\tat org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:63)\n\tat org.junit.runners.ParentRunner.runChildren(ParentRunner.java:236)\n\tat org.junit.runners.ParentRunner.access$000(ParentRunner.java:53)\n\tat org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:229)\n\tat org.junit.internal.runners.statements.RunAfters.evaluate(RunAfters.java:27)\n\tat org.junit.runners.ParentRunner.run(ParentRunner.java:309)\n\tat cucumber.api.junit.Cucumber.run(Cucumber.java:98)\n\tat org.eclipse.jdt.internal.junit4.runner.JUnit4TestReference.run(JUnit4TestReference.java:86)\n\tat org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:459)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:678)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:382)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:192)\nCaused by: java.net.ConnectException: Connection refused\n\tat java.net.PlainSocketImpl.socketConnect(Native Method)\n\tat java.net.AbstractPlainSocketImpl.doConnect(AbstractPlainSocketImpl.java:350)\n\tat java.net.AbstractPlainSocketImpl.connectToAddress(AbstractPlainSocketImpl.java:206)\n\tat java.net.AbstractPlainSocketImpl.connect(AbstractPlainSocketImpl.java:188)\n\tat java.net.Socket.connect(Socket.java:589)\n\tat java.net.Socket.connect(Socket.java:538)\n\tat sun.net.NetworkClient.doConnect(NetworkClient.java:180)\n\tat sun.net.www.http.HttpClient.openServer(HttpClient.java:432)\n\tat sun.net.www.http.HttpClient$1.run(HttpClient.java:484)\n\tat sun.net.www.http.HttpClient$1.run(HttpClient.java:482)\n\tat java.security.AccessController.doPrivileged(Native Method)\n\tat sun.net.www.http.HttpClient.privilegedOpenServer(HttpClient.java:481)\n\tat sun.net.www.http.HttpClient.openServer(HttpClient.java:522)\n\tat sun.net.www.http.HttpClient.\u003cinit\u003e(HttpClient.java:211)\n\tat sun.net.www.http.HttpClient.New(HttpClient.java:308)\n\tat sun.net.www.http.HttpClient.New(HttpClient.java:326)\n\tat sun.net.www.protocol.http.HttpURLConnection.getNewHttpClient(HttpURLConnection.java:1169)\n\tat sun.net.www.protocol.http.HttpURLConnection.plainConnect0(HttpURLConnection.java:1148)\n\tat sun.net.www.protocol.http.HttpURLConnection.plainConnect(HttpURLConnection.java:999)\n\tat sun.net.www.protocol.http.HttpURLConnection.connect(HttpURLConnection.java:933)\n\tat org.zaproxy.clientapi.core.ClientApi.getConnectionInputStream(ClientApi.java:313)\n\tat org.zaproxy.clientapi.core.ClientApi.callApiDom(ClientApi.java:305)\n\t... 44 more\n",
  "status": "failed"
});
formatter.match({
  "location": "discoveryofpotentialinjectionvectors.trydiscoveryofpotentialinjectionvectors()"
});
formatter.result({
  "status": "skipped"
});
formatter.match({
  "location": "discoveryofpotentialinjectionvectors.assdiscoveryofpotentialinjectionvectors()"
});
formatter.result({
  "status": "skipped"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({
  "location": "PatternSteps.assauditinterceptor()"
});
formatter.result({
  "status": "skipped"
});
formatter.match({
  "location": "PatternSteps.asssecurelogger()"
});
formatter.result({
  "status": "skipped"
});
formatter.uri("CAPEC_6_Step_2_1.feature");
formatter.feature({
  "line": 2,
  "name": "CAPEC-6: Argument Injection",
  "description": "",
  "id": "capec-6:-argument-injection",
  "keyword": "Feature",
  "tags": [
    {
      "line": 1,
      "name": "@capec6"
    }
  ]
});
formatter.scenario({
  "comments": [
    {
      "line": 3,
      "value": "#2. Experiment"
    }
  ],
  "line": 4,
  "name": "Step2.1 1. Attempt variations on argument content",
  "description": "",
  "id": "capec-6:-argument-injection;step2.1-1.-attempt-variations-on-argument-content",
  "type": "scenario",
  "keyword": "Scenario"
});
formatter.step({
  "line": 5,
  "name": "prepare to 1. Attempt variations on argument content",
  "keyword": "Given "
});
formatter.step({
  "line": 6,
  "name": "Try to 1. Attempt variations on argument content",
  "keyword": "When "
});
formatter.step({
  "comments": [
    {
      "line": 7,
      "value": "# assertion for attack step success"
    }
  ],
  "line": 8,
  "name": "Assert the success of 1. Attempt variations on argument content",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 9,
      "value": "#assertions for security pattern testing (checker whether the pattern consequences are observed)"
    }
  ],
  "line": 10,
  "name": "assert the consequences of the pattern application firewall",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 11,
      "value": "# alternative input guard"
    }
  ],
  "line": 12,
  "name": "assert the consequences of the pattern input guard",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 13,
      "value": "# alternative application firewall"
    }
  ],
  "line": 14,
  "name": "assert the consequences of the pattern secure logger",
  "keyword": "Then "
});
formatter.match({
  "location": "attemptvariationsonargumentcontent.preattemptvariationsonargumentcontent()"
});
formatter.result({
  "duration": 54805,
  "status": "passed"
});
formatter.match({
  "location": "attemptvariationsonargumentcontent.tryattemptvariationsonargumentcontent()"
});
formatter.result({
  "duration": 5631,
  "status": "passed"
});
formatter.match({
  "location": "attemptvariationsonargumentcontent.assattemptvariationsonargumentcontent()"
});
formatter.result({
  "duration": 5321,
  "status": "passed"
});
formatter.match({
  "location": "PatternSteps.assapplicationfirewall()"
});
formatter.result({
  "duration": 14475,
  "status": "passed"
});
formatter.match({
  "location": "PatternSteps.assinputguard()"
});
formatter.result({
  "duration": 3601,
  "status": "passed"
});
formatter.match({
  "location": "PatternSteps.asssecurelogger()"
});
formatter.result({
  "duration": 3596,
  "status": "passed"
});
formatter.uri("CAPEC_6_Step_3_1.feature");
formatter.feature({
  "line": 2,
  "name": "CAPEC-6: Argument Injection",
  "description": "",
  "id": "capec-6:-argument-injection",
  "keyword": "Feature",
  "tags": [
    {
      "line": 1,
      "name": "@capec6"
    }
  ]
});
formatter.scenario({
  "comments": [
    {
      "line": 3,
      "value": "#3. Exploit"
    }
  ],
  "line": 4,
  "name": "Step3.1 Abuse of the application",
  "description": "",
  "id": "capec-6:-argument-injection;step3.1-abuse-of-the-application",
  "type": "scenario",
  "keyword": "Scenario"
});
formatter.step({
  "line": 5,
  "name": "prepare to Abuse of the application",
  "keyword": "Given "
});
formatter.step({
  "line": 6,
  "name": "Try to Abuse of the application",
  "keyword": "When "
});
formatter.step({
  "comments": [
    {
      "line": 7,
      "value": "# assertion for attack step success"
    }
  ],
  "line": 8,
  "name": "Assert the success of Abuse of the application",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 9,
      "value": "#assertions for security pattern testing (checker whether the pattern consequences are observed)"
    }
  ],
  "line": 10,
  "name": "assert the consequences of the pattern application firewall",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 11,
      "value": "# alternative input guard"
    }
  ],
  "line": 12,
  "name": "assert the consequences of the pattern input guard",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 13,
      "value": "# alternative application firewall"
    }
  ],
  "line": 14,
  "name": "assert the consequences of the pattern secure logger",
  "keyword": "Then "
});
formatter.match({
  "location": "abuseoftheapplication.preabuseoftheapplication()"
});
formatter.result({
  "duration": 39993,
  "status": "passed"
});
formatter.match({
  "location": "abuseoftheapplication.tryabuseoftheapplication()"
});
formatter.result({
  "duration": 3602,
  "status": "passed"
});
formatter.match({
  "location": "abuseoftheapplication.assabuseoftheapplication()"
});
formatter.result({
  "duration": 4637,
  "status": "passed"
});
formatter.match({
  "location": "PatternSteps.assapplicationfirewall()"
});
formatter.result({
  "duration": 13974,
  "status": "passed"
});
formatter.match({
  "location": "PatternSteps.assinputguard()"
});
formatter.result({
  "duration": 4110,
  "status": "passed"
});
formatter.match({
  "location": "PatternSteps.asssecurelogger()"
});
formatter.result({
  "duration": 3792,
  "status": "passed"
});
formatter.uri("CAPEC_71_Step_1_1.feature");
formatter.feature({
  "line": 2,
  "name": "CAPEC-71: Using Unicode Encoding to Bypass Validation Logic",
  "description": "",
  "id": "capec-71:-using-unicode-encoding-to-bypass-validation-logic",
  "keyword": "Feature",
  "tags": [
    {
      "line": 1,
      "name": "@capec71"
    }
  ]
});
formatter.scenario({
  "comments": [
    {
      "line": 3,
      "value": "#1. Explore"
    }
  ],
  "line": 4,
  "name": "Step1.1 Survey the application for user-controllable inputs",
  "description": "",
  "id": "capec-71:-using-unicode-encoding-to-bypass-validation-logic;step1.1-survey-the-application-for-user-controllable-inputs",
  "type": "scenario",
  "keyword": "Scenario"
});
formatter.step({
  "line": 5,
  "name": "prepare to Survey the application for user-controllable inputs",
  "keyword": "Given "
});
formatter.step({
  "line": 6,
  "name": "Try to Survey the application for user-controllable inputs",
  "keyword": "When "
});
formatter.step({
  "comments": [
    {
      "line": 7,
      "value": "# assertion for attack step success"
    }
  ],
  "line": 8,
  "name": "Assert the success of Survey the application for user-controllable inputs",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 9,
      "value": "#assertions for security pattern testing (checker whether the pattern consequences are observed)"
    }
  ],
  "line": 10,
  "name": "assert the consequences of the pattern",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 11,
      "value": "#"
    }
  ],
  "line": 12,
  "name": "assert the consequences of the pattern audit interceptor",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 13,
      "value": "# depends secure logger"
    }
  ],
  "line": 14,
  "name": "assert the consequences of the pattern secure logger",
  "keyword": "Then "
});
formatter.match({
  "location": "survey.presurvey()"
});
formatter.result({
  "duration": 0,
  "error_message": "cucumber.runtime.AmbiguousStepDefinitionsException: ✽.Given prepare to Survey the application for user-controllable inputs(CAPEC_71_Step_1_1.feature:5) matches more than one step definition:\n  prepare to Survey in survey.presurvey()\n  prepare to Survey the application in surveytheapplication.presurveytheapplication()\n  prepare to Survey the application for user-controllable inputs in surveytheapplicationforusercontrollableinputs.presurveytheapplicationforusercontrollableinputs()\n\n\tat cucumber.runtime.RuntimeGlue.stepDefinitionMatch(RuntimeGlue.java:71)\n\tat cucumber.runtime.Runtime.runStep(Runtime.java:265)\n\tat cucumber.runtime.model.StepContainer.runStep(StepContainer.java:44)\n\tat cucumber.runtime.model.StepContainer.runSteps(StepContainer.java:39)\n\tat cucumber.runtime.model.CucumberScenario.run(CucumberScenario.java:48)\n\tat cucumber.runtime.junit.ExecutionUnitRunner.run(ExecutionUnitRunner.java:91)\n\tat cucumber.runtime.junit.FeatureRunner.runChild(FeatureRunner.java:63)\n\tat cucumber.runtime.junit.FeatureRunner.runChild(FeatureRunner.java:18)\n\tat org.junit.runners.ParentRunner$3.run(ParentRunner.java:238)\n\tat org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:63)\n\tat org.junit.runners.ParentRunner.runChildren(ParentRunner.java:236)\n\tat org.junit.runners.ParentRunner.access$000(ParentRunner.java:53)\n\tat org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:229)\n\tat org.junit.runners.ParentRunner.run(ParentRunner.java:309)\n\tat cucumber.runtime.junit.FeatureRunner.run(FeatureRunner.java:70)\n\tat cucumber.api.junit.Cucumber.runChild(Cucumber.java:93)\n\tat cucumber.api.junit.Cucumber.runChild(Cucumber.java:37)\n\tat org.junit.runners.ParentRunner$3.run(ParentRunner.java:238)\n\tat org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:63)\n\tat org.junit.runners.ParentRunner.runChildren(ParentRunner.java:236)\n\tat org.junit.runners.ParentRunner.access$000(ParentRunner.java:53)\n\tat org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:229)\n\tat org.junit.internal.runners.statements.RunAfters.evaluate(RunAfters.java:27)\n\tat org.junit.runners.ParentRunner.run(ParentRunner.java:309)\n\tat cucumber.api.junit.Cucumber.run(Cucumber.java:98)\n\tat org.eclipse.jdt.internal.junit4.runner.JUnit4TestReference.run(JUnit4TestReference.java:86)\n\tat org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:459)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:678)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:382)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:192)\n",
  "status": "failed"
});
formatter.match({
  "location": "survey.trysurvey()"
});
formatter.result({
  "duration": 0,
  "error_message": "cucumber.runtime.AmbiguousStepDefinitionsException: ✽.When Try to Survey the application for user-controllable inputs(CAPEC_71_Step_1_1.feature:6) matches more than one step definition:\n  Try to Survey in survey.trysurvey()\n  Try to Survey the application in surveytheapplication.trysurveytheapplication()\n  Try to Survey the application for user-controllable inputs in surveytheapplicationforusercontrollableinputs.trysurveytheapplicationforusercontrollableinputs()\n\n\tat cucumber.runtime.RuntimeGlue.stepDefinitionMatch(RuntimeGlue.java:71)\n\tat cucumber.runtime.Runtime.runStep(Runtime.java:265)\n\tat cucumber.runtime.model.StepContainer.runStep(StepContainer.java:44)\n\tat cucumber.runtime.model.StepContainer.runSteps(StepContainer.java:39)\n\tat cucumber.runtime.model.CucumberScenario.run(CucumberScenario.java:48)\n\tat cucumber.runtime.junit.ExecutionUnitRunner.run(ExecutionUnitRunner.java:91)\n\tat cucumber.runtime.junit.FeatureRunner.runChild(FeatureRunner.java:63)\n\tat cucumber.runtime.junit.FeatureRunner.runChild(FeatureRunner.java:18)\n\tat org.junit.runners.ParentRunner$3.run(ParentRunner.java:238)\n\tat org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:63)\n\tat org.junit.runners.ParentRunner.runChildren(ParentRunner.java:236)\n\tat org.junit.runners.ParentRunner.access$000(ParentRunner.java:53)\n\tat org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:229)\n\tat org.junit.runners.ParentRunner.run(ParentRunner.java:309)\n\tat cucumber.runtime.junit.FeatureRunner.run(FeatureRunner.java:70)\n\tat cucumber.api.junit.Cucumber.runChild(Cucumber.java:93)\n\tat cucumber.api.junit.Cucumber.runChild(Cucumber.java:37)\n\tat org.junit.runners.ParentRunner$3.run(ParentRunner.java:238)\n\tat org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:63)\n\tat org.junit.runners.ParentRunner.runChildren(ParentRunner.java:236)\n\tat org.junit.runners.ParentRunner.access$000(ParentRunner.java:53)\n\tat org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:229)\n\tat org.junit.internal.runners.statements.RunAfters.evaluate(RunAfters.java:27)\n\tat org.junit.runners.ParentRunner.run(ParentRunner.java:309)\n\tat cucumber.api.junit.Cucumber.run(Cucumber.java:98)\n\tat org.eclipse.jdt.internal.junit4.runner.JUnit4TestReference.run(JUnit4TestReference.java:86)\n\tat org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:459)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:678)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:382)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:192)\n",
  "status": "failed"
});
formatter.match({
  "location": "survey.asssurvey()"
});
formatter.result({
  "duration": 0,
  "error_message": "cucumber.runtime.AmbiguousStepDefinitionsException: ✽.Then Assert the success of Survey the application for user-controllable inputs(CAPEC_71_Step_1_1.feature:8) matches more than one step definition:\n  Assert the success of Survey in survey.asssurvey()\n  Assert the success of Survey the application in surveytheapplication.asssurveytheapplication()\n  Assert the success of Survey the application for user-controllable inputs in surveytheapplicationforusercontrollableinputs.asssurveytheapplicationforusercontrollableinputs()\n\n\tat cucumber.runtime.RuntimeGlue.stepDefinitionMatch(RuntimeGlue.java:71)\n\tat cucumber.runtime.Runtime.runStep(Runtime.java:265)\n\tat cucumber.runtime.model.StepContainer.runStep(StepContainer.java:44)\n\tat cucumber.runtime.model.StepContainer.runSteps(StepContainer.java:39)\n\tat cucumber.runtime.model.CucumberScenario.run(CucumberScenario.java:48)\n\tat cucumber.runtime.junit.ExecutionUnitRunner.run(ExecutionUnitRunner.java:91)\n\tat cucumber.runtime.junit.FeatureRunner.runChild(FeatureRunner.java:63)\n\tat cucumber.runtime.junit.FeatureRunner.runChild(FeatureRunner.java:18)\n\tat org.junit.runners.ParentRunner$3.run(ParentRunner.java:238)\n\tat org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:63)\n\tat org.junit.runners.ParentRunner.runChildren(ParentRunner.java:236)\n\tat org.junit.runners.ParentRunner.access$000(ParentRunner.java:53)\n\tat org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:229)\n\tat org.junit.runners.ParentRunner.run(ParentRunner.java:309)\n\tat cucumber.runtime.junit.FeatureRunner.run(FeatureRunner.java:70)\n\tat cucumber.api.junit.Cucumber.runChild(Cucumber.java:93)\n\tat cucumber.api.junit.Cucumber.runChild(Cucumber.java:37)\n\tat org.junit.runners.ParentRunner$3.run(ParentRunner.java:238)\n\tat org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:63)\n\tat org.junit.runners.ParentRunner.runChildren(ParentRunner.java:236)\n\tat org.junit.runners.ParentRunner.access$000(ParentRunner.java:53)\n\tat org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:229)\n\tat org.junit.internal.runners.statements.RunAfters.evaluate(RunAfters.java:27)\n\tat org.junit.runners.ParentRunner.run(ParentRunner.java:309)\n\tat cucumber.api.junit.Cucumber.run(Cucumber.java:98)\n\tat org.eclipse.jdt.internal.junit4.runner.JUnit4TestReference.run(JUnit4TestReference.java:86)\n\tat org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:459)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:678)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:382)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:192)\n",
  "status": "failed"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({
  "location": "PatternSteps.assauditinterceptor()"
});
formatter.result({
  "status": "skipped"
});
formatter.match({
  "location": "PatternSteps.asssecurelogger()"
});
formatter.result({
  "status": "skipped"
});
formatter.uri("CAPEC_71_Step_2_1.feature");
formatter.feature({
  "line": 2,
  "name": "CAPEC-71: Using Unicode Encoding to Bypass Validation Logic",
  "description": "",
  "id": "capec-71:-using-unicode-encoding-to-bypass-validation-logic",
  "keyword": "Feature",
  "tags": [
    {
      "line": 1,
      "name": "@capec71"
    }
  ]
});
formatter.scenario({
  "comments": [
    {
      "line": 3,
      "value": "#2. Experiment"
    }
  ],
  "line": 4,
  "name": "Step2.1 Probe entry points to locate vulnerabilities",
  "description": "",
  "id": "capec-71:-using-unicode-encoding-to-bypass-validation-logic;step2.1-probe-entry-points-to-locate-vulnerabilities",
  "type": "scenario",
  "keyword": "Scenario"
});
formatter.step({
  "line": 5,
  "name": "prepare to Probe entry points to locate vulnerabilities",
  "keyword": "Given "
});
formatter.step({
  "line": 6,
  "name": "Try to Probe entry points to locate vulnerabilities",
  "keyword": "When "
});
formatter.step({
  "comments": [
    {
      "line": 7,
      "value": "# assertion for attack step success"
    }
  ],
  "line": 8,
  "name": "Assert the success of Probe entry points to locate vulnerabilities",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 9,
      "value": "#assertions for security pattern testing (checker whether the pattern consequences are observed)"
    }
  ],
  "line": 10,
  "name": "assert the consequences of the pattern application firewall",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 11,
      "value": "# alternative input guard"
    }
  ],
  "line": 12,
  "name": "assert the consequences of the pattern input guard",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 13,
      "value": "# alternative application firewall"
    }
  ],
  "line": 14,
  "name": "assert the consequences of the pattern pathname canonicalization",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 15,
      "value": "#"
    }
  ],
  "line": 16,
  "name": "assert the consequences of the pattern",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 17,
      "value": "#"
    }
  ],
  "line": 18,
  "name": "assert the consequences of the pattern audit interceptor",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 19,
      "value": "# depends secure logger"
    }
  ],
  "line": 20,
  "name": "assert the consequences of the pattern secure logger",
  "keyword": "Then "
});
formatter.match({
  "location": "probeentrypointstolocatevulnerabilities.preprobeentrypointstolocatevulnerabilities()"
});
formatter.result({
  "duration": 24675,
  "status": "passed"
});
formatter.match({
  "location": "probeentrypointstolocatevulnerabilities.tryprobeentrypointstolocatevulnerabilities()"
});
formatter.result({
  "duration": 3838,
  "status": "passed"
});
formatter.match({
  "location": "probeentrypointstolocatevulnerabilities.assprobeentrypointstolocatevulnerabilities()"
});
formatter.result({
  "duration": 3380,
  "status": "passed"
});
formatter.match({
  "location": "PatternSteps.assapplicationfirewall()"
});
formatter.result({
  "duration": 26442,
  "status": "passed"
});
formatter.match({
  "location": "PatternSteps.assinputguard()"
});
formatter.result({
  "duration": 5721,
  "status": "passed"
});
formatter.match({
  "location": "PatternSteps.asspathnamecanonicalization()"
});
formatter.result({
  "duration": 6399,
  "status": "passed"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({
  "location": "PatternSteps.assauditinterceptor()"
});
formatter.result({
  "status": "skipped"
});
formatter.match({
  "location": "PatternSteps.asssecurelogger()"
});
formatter.result({
  "status": "skipped"
});
formatter.uri("CAPEC_72_Step_1_1.feature");
formatter.feature({
  "line": 2,
  "name": "CAPEC-72: URL Encoding",
  "description": "",
  "id": "capec-72:-url-encoding",
  "keyword": "Feature",
  "tags": [
    {
      "line": 1,
      "name": "@capec72"
    }
  ]
});
formatter.scenario({
  "comments": [
    {
      "line": 3,
      "value": "#1. Explore"
    }
  ],
  "line": 4,
  "name": "Step1.1",
  "description": "",
  "id": "capec-72:-url-encoding;step1.1",
  "type": "scenario",
  "keyword": "Scenario"
});
formatter.step({
  "line": 5,
  "name": "prepare to",
  "keyword": "Given "
});
formatter.step({
  "line": 6,
  "name": "Try to",
  "keyword": "When "
});
formatter.step({
  "comments": [
    {
      "line": 7,
      "value": "# assertion for attack step success"
    }
  ],
  "line": 8,
  "name": "Assert the success of",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 9,
      "value": "#assertions for security pattern testing (checker whether the pattern consequences are observed)"
    }
  ],
  "line": 10,
  "name": "assert the consequences of the pattern",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 11,
      "value": "#"
    }
  ],
  "line": 12,
  "name": "assert the consequences of the pattern audit interceptor",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 13,
      "value": "# depends secure logger"
    }
  ],
  "line": 14,
  "name": "assert the consequences of the pattern secure logger",
  "keyword": "Then "
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({
  "location": "PatternSteps.assauditinterceptor()"
});
formatter.result({
  "status": "skipped"
});
formatter.match({
  "location": "PatternSteps.asssecurelogger()"
});
formatter.result({
  "status": "skipped"
});
formatter.uri("CAPEC_72_Step_2_1.feature");
formatter.feature({
  "line": 2,
  "name": "CAPEC-72: URL Encoding",
  "description": "",
  "id": "capec-72:-url-encoding",
  "keyword": "Feature",
  "tags": [
    {
      "line": 1,
      "name": "@capec72"
    }
  ]
});
formatter.scenario({
  "comments": [
    {
      "line": 3,
      "value": "#2. Experiment"
    }
  ],
  "line": 4,
  "name": "Step2.1",
  "description": "",
  "id": "capec-72:-url-encoding;step2.1",
  "type": "scenario",
  "keyword": "Scenario"
});
formatter.step({
  "line": 5,
  "name": "prepare to",
  "keyword": "Given "
});
formatter.step({
  "line": 6,
  "name": "Try to",
  "keyword": "When "
});
formatter.step({
  "comments": [
    {
      "line": 7,
      "value": "# assertion for attack step success"
    }
  ],
  "line": 8,
  "name": "Assert the success of",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 9,
      "value": "#assertions for security pattern testing (checker whether the pattern consequences are observed)"
    }
  ],
  "line": 10,
  "name": "assert the consequences of the pattern",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 11,
      "value": "#"
    }
  ],
  "line": 12,
  "name": "assert the consequences of the pattern audit interceptor",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 13,
      "value": "# depends secure logger"
    }
  ],
  "line": 14,
  "name": "assert the consequences of the pattern secure logger",
  "keyword": "Then "
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({
  "location": "PatternSteps.assauditinterceptor()"
});
formatter.result({
  "status": "skipped"
});
formatter.match({
  "location": "PatternSteps.asssecurelogger()"
});
formatter.result({
  "status": "skipped"
});
formatter.uri("CAPEC_72_Step_3_1.feature");
formatter.feature({
  "line": 2,
  "name": "CAPEC-72: URL Encoding",
  "description": "",
  "id": "capec-72:-url-encoding",
  "keyword": "Feature",
  "tags": [
    {
      "line": 1,
      "name": "@capec72"
    }
  ]
});
formatter.scenario({
  "comments": [
    {
      "line": 3,
      "value": "#3. Exploit"
    }
  ],
  "line": 4,
  "name": "Step3.1",
  "description": "",
  "id": "capec-72:-url-encoding;step3.1",
  "type": "scenario",
  "keyword": "Scenario"
});
formatter.step({
  "line": 5,
  "name": "prepare to",
  "keyword": "Given "
});
formatter.step({
  "line": 6,
  "name": "Try to",
  "keyword": "When "
});
formatter.step({
  "comments": [
    {
      "line": 7,
      "value": "# assertion for attack step success"
    }
  ],
  "line": 8,
  "name": "Assert the success of",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 9,
      "value": "#assertions for security pattern testing (checker whether the pattern consequences are observed)"
    }
  ],
  "line": 10,
  "name": "assert the consequences of the pattern",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 11,
      "value": "#"
    }
  ],
  "line": 12,
  "name": "assert the consequences of the pattern audit interceptor",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 13,
      "value": "# depends secure logger"
    }
  ],
  "line": 14,
  "name": "assert the consequences of the pattern secure logger",
  "keyword": "Then "
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({
  "location": "PatternSteps.assauditinterceptor()"
});
formatter.result({
  "status": "skipped"
});
formatter.match({
  "location": "PatternSteps.asssecurelogger()"
});
formatter.result({
  "status": "skipped"
});
formatter.uri("CAPEC_74_Step_1_1.feature");
formatter.feature({
  "line": 2,
  "name": "CAPEC-74: Manipulating User State",
  "description": "",
  "id": "capec-74:-manipulating-user-state",
  "keyword": "Feature",
  "tags": [
    {
      "line": 1,
      "name": "@capec74"
    }
  ]
});
formatter.scenario({
  "comments": [
    {
      "line": 3,
      "value": "#1. Explore"
    }
  ],
  "line": 4,
  "name": "Step1.1",
  "description": "",
  "id": "capec-74:-manipulating-user-state;step1.1",
  "type": "scenario",
  "keyword": "Scenario"
});
formatter.step({
  "line": 5,
  "name": "prepare to",
  "keyword": "Given "
});
formatter.step({
  "line": 6,
  "name": "Try to",
  "keyword": "When "
});
formatter.step({
  "comments": [
    {
      "line": 7,
      "value": "# assertion for attack step success"
    }
  ],
  "line": 8,
  "name": "Assert the success of",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 9,
      "value": "#assertions for security pattern testing (checker whether the pattern consequences are observed)"
    }
  ],
  "line": 10,
  "name": "assert the consequences of the pattern",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 11,
      "value": "#"
    }
  ],
  "line": 12,
  "name": "assert the consequences of the pattern audit interceptor",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 13,
      "value": "# depends secure logger"
    }
  ],
  "line": 14,
  "name": "assert the consequences of the pattern secure logger",
  "keyword": "Then "
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({
  "location": "PatternSteps.assauditinterceptor()"
});
formatter.result({
  "status": "skipped"
});
formatter.match({
  "location": "PatternSteps.asssecurelogger()"
});
formatter.result({
  "status": "skipped"
});
formatter.uri("CAPEC_74_Step_2_1.feature");
formatter.feature({
  "line": 2,
  "name": "CAPEC-74: Manipulating User State",
  "description": "",
  "id": "capec-74:-manipulating-user-state",
  "keyword": "Feature",
  "tags": [
    {
      "line": 1,
      "name": "@capec74"
    }
  ]
});
formatter.scenario({
  "comments": [
    {
      "line": 3,
      "value": "#2. Experiment"
    }
  ],
  "line": 4,
  "name": "Step2.1",
  "description": "",
  "id": "capec-74:-manipulating-user-state;step2.1",
  "type": "scenario",
  "keyword": "Scenario"
});
formatter.step({
  "line": 5,
  "name": "prepare to",
  "keyword": "Given "
});
formatter.step({
  "line": 6,
  "name": "Try to",
  "keyword": "When "
});
formatter.step({
  "comments": [
    {
      "line": 7,
      "value": "# assertion for attack step success"
    }
  ],
  "line": 8,
  "name": "Assert the success of",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 9,
      "value": "#assertions for security pattern testing (checker whether the pattern consequences are observed)"
    }
  ],
  "line": 10,
  "name": "assert the consequences of the pattern",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 11,
      "value": "#"
    }
  ],
  "line": 12,
  "name": "assert the consequences of the pattern audit interceptor",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 13,
      "value": "# depends secure logger"
    }
  ],
  "line": 14,
  "name": "assert the consequences of the pattern secure logger",
  "keyword": "Then "
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({
  "location": "PatternSteps.assauditinterceptor()"
});
formatter.result({
  "status": "skipped"
});
formatter.match({
  "location": "PatternSteps.asssecurelogger()"
});
formatter.result({
  "status": "skipped"
});
formatter.uri("CAPEC_74_Step_3_1.feature");
formatter.feature({
  "line": 2,
  "name": "CAPEC-74: Manipulating User State",
  "description": "",
  "id": "capec-74:-manipulating-user-state",
  "keyword": "Feature",
  "tags": [
    {
      "line": 1,
      "name": "@capec74"
    }
  ]
});
formatter.scenario({
  "comments": [
    {
      "line": 3,
      "value": "#3. Exploit"
    }
  ],
  "line": 4,
  "name": "Step3.1",
  "description": "",
  "id": "capec-74:-manipulating-user-state;step3.1",
  "type": "scenario",
  "keyword": "Scenario"
});
formatter.step({
  "line": 5,
  "name": "prepare to",
  "keyword": "Given "
});
formatter.step({
  "line": 6,
  "name": "Try to",
  "keyword": "When "
});
formatter.step({
  "comments": [
    {
      "line": 7,
      "value": "# assertion for attack step success"
    }
  ],
  "line": 8,
  "name": "Assert the success of",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 9,
      "value": "#assertions for security pattern testing (checker whether the pattern consequences are observed)"
    }
  ],
  "line": 10,
  "name": "assert the consequences of the pattern",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 11,
      "value": "#"
    }
  ],
  "line": 12,
  "name": "assert the consequences of the pattern audit interceptor",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 13,
      "value": "# depends secure logger"
    }
  ],
  "line": 14,
  "name": "assert the consequences of the pattern secure logger",
  "keyword": "Then "
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({
  "location": "PatternSteps.assauditinterceptor()"
});
formatter.result({
  "status": "skipped"
});
formatter.match({
  "location": "PatternSteps.asssecurelogger()"
});
formatter.result({
  "status": "skipped"
});
formatter.uri("CAPEC_76_Step_1_1.feature");
formatter.feature({
  "line": 2,
  "name": "CAPEC-76: Manipulating Input to File System Calls",
  "description": "",
  "id": "capec-76:-manipulating-input-to-file-system-calls",
  "keyword": "Feature",
  "tags": [
    {
      "line": 1,
      "name": "@capec76"
    }
  ]
});
formatter.scenario({
  "comments": [
    {
      "line": 3,
      "value": "#1. Explore"
    }
  ],
  "line": 4,
  "name": "Step1.1 Fingerprinting of the operating system",
  "description": "",
  "id": "capec-76:-manipulating-input-to-file-system-calls;step1.1-fingerprinting-of-the-operating-system",
  "type": "scenario",
  "keyword": "Scenario"
});
formatter.step({
  "line": 5,
  "name": "prepare to Fingerprinting of the operating system",
  "keyword": "Given "
});
formatter.step({
  "line": 6,
  "name": "Try to Fingerprinting of the operating system",
  "keyword": "When "
});
formatter.step({
  "comments": [
    {
      "line": 7,
      "value": "# assertion for attack step success"
    }
  ],
  "line": 8,
  "name": "Assert the success of Fingerprinting of the operating system",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 9,
      "value": "#assertions for security pattern testing (checker whether the pattern consequences are observed)"
    }
  ],
  "line": 10,
  "name": "assert the consequences of the pattern",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 11,
      "value": "#"
    }
  ],
  "line": 12,
  "name": "assert the consequences of the pattern secure logger",
  "keyword": "Then "
});
formatter.match({
  "location": "fingerprintingoftheoperatingsystem.prefingerprintingoftheoperatingsystem()"
});
formatter.result({
  "duration": 57627,
  "status": "passed"
});
formatter.match({
  "location": "fingerprintingoftheoperatingsystem.tryfingerprintingoftheoperatingsystem()"
});
formatter.result({
  "duration": 5134,
  "status": "passed"
});
formatter.match({
  "location": "fingerprintingoftheoperatingsystem.assfingerprintingoftheoperatingsystem()"
});
formatter.result({
  "duration": 4378,
  "status": "passed"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({
  "location": "PatternSteps.asssecurelogger()"
});
formatter.result({
  "status": "skipped"
});
formatter.uri("CAPEC_76_Step_1_2.feature");
formatter.feature({
  "line": 2,
  "name": "CAPEC-76: Manipulating Input to File System Calls",
  "description": "",
  "id": "capec-76:-manipulating-input-to-file-system-calls",
  "keyword": "Feature",
  "tags": [
    {
      "line": 1,
      "name": "@capec76"
    }
  ]
});
formatter.scenario({
  "comments": [
    {
      "line": 3,
      "value": "#1. Explore"
    }
  ],
  "line": 4,
  "name": "Step1.2 Survey the Application to Identify User-controllable Inputs",
  "description": "",
  "id": "capec-76:-manipulating-input-to-file-system-calls;step1.2-survey-the-application-to-identify-user-controllable-inputs",
  "type": "scenario",
  "keyword": "Scenario"
});
formatter.step({
  "line": 5,
  "name": "prepare to Survey the Application to Identify User-controllable Inputs",
  "keyword": "Given "
});
formatter.step({
  "line": 6,
  "name": "Try to Survey the Application to Identify User-controllable Inputs",
  "keyword": "When "
});
formatter.step({
  "comments": [
    {
      "line": 7,
      "value": "# assertion for attack step success"
    }
  ],
  "line": 8,
  "name": "Assert the success of Survey the Application to Identify User-controllable Inputs",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 9,
      "value": "#assertions for security pattern testing (checker whether the pattern consequences are observed)"
    }
  ],
  "line": 10,
  "name": "assert the consequences of the pattern",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 11,
      "value": "#"
    }
  ],
  "line": 12,
  "name": "assert the consequences of the pattern audit interceptor",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 13,
      "value": "# depends secure logger"
    }
  ],
  "line": 14,
  "name": "assert the consequences of the pattern secure logger",
  "keyword": "Then "
});
formatter.match({
  "location": "survey.presurvey()"
});
formatter.result({
  "duration": 0,
  "error_message": "cucumber.runtime.AmbiguousStepDefinitionsException: ✽.Given prepare to Survey the Application to Identify User-controllable Inputs(CAPEC_76_Step_1_2.feature:5) matches more than one step definition:\n  prepare to Survey in survey.presurvey()\n  prepare to Survey the Application to Identify User-controllable Inputs in surveytheapplicationtoidentifyusercontrollableinputs.presurveytheapplicationtoidentifyusercontrollableinputs()\n\n\tat cucumber.runtime.RuntimeGlue.stepDefinitionMatch(RuntimeGlue.java:71)\n\tat cucumber.runtime.Runtime.runStep(Runtime.java:265)\n\tat cucumber.runtime.model.StepContainer.runStep(StepContainer.java:44)\n\tat cucumber.runtime.model.StepContainer.runSteps(StepContainer.java:39)\n\tat cucumber.runtime.model.CucumberScenario.run(CucumberScenario.java:48)\n\tat cucumber.runtime.junit.ExecutionUnitRunner.run(ExecutionUnitRunner.java:91)\n\tat cucumber.runtime.junit.FeatureRunner.runChild(FeatureRunner.java:63)\n\tat cucumber.runtime.junit.FeatureRunner.runChild(FeatureRunner.java:18)\n\tat org.junit.runners.ParentRunner$3.run(ParentRunner.java:238)\n\tat org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:63)\n\tat org.junit.runners.ParentRunner.runChildren(ParentRunner.java:236)\n\tat org.junit.runners.ParentRunner.access$000(ParentRunner.java:53)\n\tat org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:229)\n\tat org.junit.runners.ParentRunner.run(ParentRunner.java:309)\n\tat cucumber.runtime.junit.FeatureRunner.run(FeatureRunner.java:70)\n\tat cucumber.api.junit.Cucumber.runChild(Cucumber.java:93)\n\tat cucumber.api.junit.Cucumber.runChild(Cucumber.java:37)\n\tat org.junit.runners.ParentRunner$3.run(ParentRunner.java:238)\n\tat org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:63)\n\tat org.junit.runners.ParentRunner.runChildren(ParentRunner.java:236)\n\tat org.junit.runners.ParentRunner.access$000(ParentRunner.java:53)\n\tat org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:229)\n\tat org.junit.internal.runners.statements.RunAfters.evaluate(RunAfters.java:27)\n\tat org.junit.runners.ParentRunner.run(ParentRunner.java:309)\n\tat cucumber.api.junit.Cucumber.run(Cucumber.java:98)\n\tat org.eclipse.jdt.internal.junit4.runner.JUnit4TestReference.run(JUnit4TestReference.java:86)\n\tat org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:459)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:678)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:382)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:192)\n",
  "status": "failed"
});
formatter.match({
  "location": "survey.trysurvey()"
});
formatter.result({
  "duration": 0,
  "error_message": "cucumber.runtime.AmbiguousStepDefinitionsException: ✽.When Try to Survey the Application to Identify User-controllable Inputs(CAPEC_76_Step_1_2.feature:6) matches more than one step definition:\n  Try to Survey in survey.trysurvey()\n  Try to Survey the Application to Identify User-controllable Inputs in surveytheapplicationtoidentifyusercontrollableinputs.trysurveytheapplicationtoidentifyusercontrollableinputs()\n\n\tat cucumber.runtime.RuntimeGlue.stepDefinitionMatch(RuntimeGlue.java:71)\n\tat cucumber.runtime.Runtime.runStep(Runtime.java:265)\n\tat cucumber.runtime.model.StepContainer.runStep(StepContainer.java:44)\n\tat cucumber.runtime.model.StepContainer.runSteps(StepContainer.java:39)\n\tat cucumber.runtime.model.CucumberScenario.run(CucumberScenario.java:48)\n\tat cucumber.runtime.junit.ExecutionUnitRunner.run(ExecutionUnitRunner.java:91)\n\tat cucumber.runtime.junit.FeatureRunner.runChild(FeatureRunner.java:63)\n\tat cucumber.runtime.junit.FeatureRunner.runChild(FeatureRunner.java:18)\n\tat org.junit.runners.ParentRunner$3.run(ParentRunner.java:238)\n\tat org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:63)\n\tat org.junit.runners.ParentRunner.runChildren(ParentRunner.java:236)\n\tat org.junit.runners.ParentRunner.access$000(ParentRunner.java:53)\n\tat org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:229)\n\tat org.junit.runners.ParentRunner.run(ParentRunner.java:309)\n\tat cucumber.runtime.junit.FeatureRunner.run(FeatureRunner.java:70)\n\tat cucumber.api.junit.Cucumber.runChild(Cucumber.java:93)\n\tat cucumber.api.junit.Cucumber.runChild(Cucumber.java:37)\n\tat org.junit.runners.ParentRunner$3.run(ParentRunner.java:238)\n\tat org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:63)\n\tat org.junit.runners.ParentRunner.runChildren(ParentRunner.java:236)\n\tat org.junit.runners.ParentRunner.access$000(ParentRunner.java:53)\n\tat org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:229)\n\tat org.junit.internal.runners.statements.RunAfters.evaluate(RunAfters.java:27)\n\tat org.junit.runners.ParentRunner.run(ParentRunner.java:309)\n\tat cucumber.api.junit.Cucumber.run(Cucumber.java:98)\n\tat org.eclipse.jdt.internal.junit4.runner.JUnit4TestReference.run(JUnit4TestReference.java:86)\n\tat org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:459)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:678)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:382)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:192)\n",
  "status": "failed"
});
formatter.match({
  "location": "survey.asssurvey()"
});
formatter.result({
  "duration": 0,
  "error_message": "cucumber.runtime.AmbiguousStepDefinitionsException: ✽.Then Assert the success of Survey the Application to Identify User-controllable Inputs(CAPEC_76_Step_1_2.feature:8) matches more than one step definition:\n  Assert the success of Survey in survey.asssurvey()\n  Assert the success of Survey the Application to Identify User-controllable Inputs in surveytheapplicationtoidentifyusercontrollableinputs.asssurveytheapplicationtoidentifyusercontrollableinputs()\n\n\tat cucumber.runtime.RuntimeGlue.stepDefinitionMatch(RuntimeGlue.java:71)\n\tat cucumber.runtime.Runtime.runStep(Runtime.java:265)\n\tat cucumber.runtime.model.StepContainer.runStep(StepContainer.java:44)\n\tat cucumber.runtime.model.StepContainer.runSteps(StepContainer.java:39)\n\tat cucumber.runtime.model.CucumberScenario.run(CucumberScenario.java:48)\n\tat cucumber.runtime.junit.ExecutionUnitRunner.run(ExecutionUnitRunner.java:91)\n\tat cucumber.runtime.junit.FeatureRunner.runChild(FeatureRunner.java:63)\n\tat cucumber.runtime.junit.FeatureRunner.runChild(FeatureRunner.java:18)\n\tat org.junit.runners.ParentRunner$3.run(ParentRunner.java:238)\n\tat org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:63)\n\tat org.junit.runners.ParentRunner.runChildren(ParentRunner.java:236)\n\tat org.junit.runners.ParentRunner.access$000(ParentRunner.java:53)\n\tat org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:229)\n\tat org.junit.runners.ParentRunner.run(ParentRunner.java:309)\n\tat cucumber.runtime.junit.FeatureRunner.run(FeatureRunner.java:70)\n\tat cucumber.api.junit.Cucumber.runChild(Cucumber.java:93)\n\tat cucumber.api.junit.Cucumber.runChild(Cucumber.java:37)\n\tat org.junit.runners.ParentRunner$3.run(ParentRunner.java:238)\n\tat org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:63)\n\tat org.junit.runners.ParentRunner.runChildren(ParentRunner.java:236)\n\tat org.junit.runners.ParentRunner.access$000(ParentRunner.java:53)\n\tat org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:229)\n\tat org.junit.internal.runners.statements.RunAfters.evaluate(RunAfters.java:27)\n\tat org.junit.runners.ParentRunner.run(ParentRunner.java:309)\n\tat cucumber.api.junit.Cucumber.run(Cucumber.java:98)\n\tat org.eclipse.jdt.internal.junit4.runner.JUnit4TestReference.run(JUnit4TestReference.java:86)\n\tat org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:459)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:678)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:382)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:192)\n",
  "status": "failed"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({
  "location": "PatternSteps.assauditinterceptor()"
});
formatter.result({
  "status": "skipped"
});
formatter.match({
  "location": "PatternSteps.asssecurelogger()"
});
formatter.result({
  "status": "skipped"
});
formatter.uri("CAPEC_76_Step_2_1.feature");
formatter.feature({
  "line": 2,
  "name": "CAPEC-76: Manipulating Input to File System Calls",
  "description": "",
  "id": "capec-76:-manipulating-input-to-file-system-calls",
  "keyword": "Feature",
  "tags": [
    {
      "line": 1,
      "name": "@capec76"
    }
  ]
});
formatter.scenario({
  "comments": [
    {
      "line": 3,
      "value": "#2. Experiment"
    }
  ],
  "line": 4,
  "name": "Step2.1 Vary inputs, looking for malicious results",
  "description": "",
  "id": "capec-76:-manipulating-input-to-file-system-calls;step2.1-vary-inputs,-looking-for-malicious-results",
  "type": "scenario",
  "keyword": "Scenario"
});
formatter.step({
  "line": 5,
  "name": "prepare to Vary inputs, looking for malicious results",
  "keyword": "Given "
});
formatter.step({
  "line": 6,
  "name": "Try to Vary inputs, looking for malicious results",
  "keyword": "When "
});
formatter.step({
  "comments": [
    {
      "line": 7,
      "value": "# assertion for attack step success"
    }
  ],
  "line": 8,
  "name": "Assert the success of Vary inputs, looking for malicious results",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 9,
      "value": "#assertions for security pattern testing (checker whether the pattern consequences are observed)"
    }
  ],
  "line": 10,
  "name": "assert the consequences of the pattern",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 11,
      "value": "#"
    }
  ],
  "line": 12,
  "name": "assert the consequences of the pattern audit interceptor",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 13,
      "value": "# depends secure logger"
    }
  ],
  "line": 14,
  "name": "assert the consequences of the pattern secure logger",
  "keyword": "Then "
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({
  "location": "PatternSteps.assauditinterceptor()"
});
formatter.result({
  "status": "skipped"
});
formatter.match({
  "location": "PatternSteps.asssecurelogger()"
});
formatter.result({
  "status": "skipped"
});
formatter.uri("CAPEC_76_Step_3_1.feature");
formatter.feature({
  "line": 2,
  "name": "CAPEC-76: Manipulating Input to File System Calls",
  "description": "",
  "id": "capec-76:-manipulating-input-to-file-system-calls",
  "keyword": "Feature",
  "tags": [
    {
      "line": 1,
      "name": "@capec76"
    }
  ]
});
formatter.scenario({
  "comments": [
    {
      "line": 3,
      "value": "#3. Exploit"
    }
  ],
  "line": 4,
  "name": "Step3.1 Manipulate files accessible by the application",
  "description": "",
  "id": "capec-76:-manipulating-input-to-file-system-calls;step3.1-manipulate-files-accessible-by-the-application",
  "type": "scenario",
  "keyword": "Scenario"
});
formatter.step({
  "line": 5,
  "name": "prepare to Manipulate files accessible by the application",
  "keyword": "Given "
});
formatter.step({
  "line": 6,
  "name": "Try to Manipulate files accessible by the application",
  "keyword": "When "
});
formatter.step({
  "comments": [
    {
      "line": 7,
      "value": "# assertion for attack step success"
    }
  ],
  "line": 8,
  "name": "Assert the success of Manipulate files accessible by the application",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 9,
      "value": "#assertions for security pattern testing (checker whether the pattern consequences are observed)"
    }
  ],
  "line": 10,
  "name": "assert the consequences of the pattern secure logger",
  "keyword": "Then "
});
formatter.match({
  "location": "manipulatefilesaccessiblebytheapplication.premanipulatefilesaccessiblebytheapplication()"
});
formatter.result({
  "duration": 50611,
  "status": "passed"
});
formatter.match({
  "location": "manipulatefilesaccessiblebytheapplication.trymanipulatefilesaccessiblebytheapplication()"
});
formatter.result({
  "duration": 4165,
  "status": "passed"
});
formatter.match({
  "location": "manipulatefilesaccessiblebytheapplication.assmanipulatefilesaccessiblebytheapplication()"
});
formatter.result({
  "duration": 3646,
  "status": "passed"
});
formatter.match({
  "location": "PatternSteps.asssecurelogger()"
});
formatter.result({
  "duration": 11803,
  "status": "passed"
});
formatter.uri("CAPEC_77_Step_1_1.feature");
formatter.feature({
  "line": 2,
  "name": "CAPEC-77: Manipulating User-Controlled Variables",
  "description": "",
  "id": "capec-77:-manipulating-user-controlled-variables",
  "keyword": "Feature",
  "tags": [
    {
      "line": 1,
      "name": "@capec77"
    }
  ]
});
formatter.scenario({
  "comments": [
    {
      "line": 3,
      "value": "#1. Explore"
    }
  ],
  "line": 4,
  "name": "Step1.1",
  "description": "",
  "id": "capec-77:-manipulating-user-controlled-variables;step1.1",
  "type": "scenario",
  "keyword": "Scenario"
});
formatter.step({
  "line": 5,
  "name": "prepare to",
  "keyword": "Given "
});
formatter.step({
  "line": 6,
  "name": "Try to",
  "keyword": "When "
});
formatter.step({
  "comments": [
    {
      "line": 7,
      "value": "# assertion for attack step success"
    }
  ],
  "line": 8,
  "name": "Assert the success of",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 9,
      "value": "#assertions for security pattern testing (checker whether the pattern consequences are observed)"
    }
  ],
  "line": 10,
  "name": "assert the consequences of the pattern",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 11,
      "value": "#"
    }
  ],
  "line": 12,
  "name": "assert the consequences of the pattern audit interceptor",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 13,
      "value": "# depends secure logger"
    }
  ],
  "line": 14,
  "name": "assert the consequences of the pattern secure logger",
  "keyword": "Then "
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({
  "location": "PatternSteps.assauditinterceptor()"
});
formatter.result({
  "status": "skipped"
});
formatter.match({
  "location": "PatternSteps.asssecurelogger()"
});
formatter.result({
  "status": "skipped"
});
formatter.uri("CAPEC_77_Step_2_1.feature");
formatter.feature({
  "line": 2,
  "name": "CAPEC-77: Manipulating User-Controlled Variables",
  "description": "",
  "id": "capec-77:-manipulating-user-controlled-variables",
  "keyword": "Feature",
  "tags": [
    {
      "line": 1,
      "name": "@capec77"
    }
  ]
});
formatter.scenario({
  "comments": [
    {
      "line": 3,
      "value": "#2. Experiment"
    }
  ],
  "line": 4,
  "name": "Step2.1",
  "description": "",
  "id": "capec-77:-manipulating-user-controlled-variables;step2.1",
  "type": "scenario",
  "keyword": "Scenario"
});
formatter.step({
  "line": 5,
  "name": "prepare to",
  "keyword": "Given "
});
formatter.step({
  "line": 6,
  "name": "Try to",
  "keyword": "When "
});
formatter.step({
  "comments": [
    {
      "line": 7,
      "value": "# assertion for attack step success"
    }
  ],
  "line": 8,
  "name": "Assert the success of",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 9,
      "value": "#assertions for security pattern testing (checker whether the pattern consequences are observed)"
    }
  ],
  "line": 10,
  "name": "assert the consequences of the pattern",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 11,
      "value": "#"
    }
  ],
  "line": 12,
  "name": "assert the consequences of the pattern audit interceptor",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 13,
      "value": "# depends secure logger"
    }
  ],
  "line": 14,
  "name": "assert the consequences of the pattern secure logger",
  "keyword": "Then "
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({
  "location": "PatternSteps.assauditinterceptor()"
});
formatter.result({
  "status": "skipped"
});
formatter.match({
  "location": "PatternSteps.asssecurelogger()"
});
formatter.result({
  "status": "skipped"
});
formatter.uri("CAPEC_77_Step_3_1.feature");
formatter.feature({
  "line": 2,
  "name": "CAPEC-77: Manipulating User-Controlled Variables",
  "description": "",
  "id": "capec-77:-manipulating-user-controlled-variables",
  "keyword": "Feature",
  "tags": [
    {
      "line": 1,
      "name": "@capec77"
    }
  ]
});
formatter.scenario({
  "comments": [
    {
      "line": 3,
      "value": "#3. Exploit"
    }
  ],
  "line": 4,
  "name": "Step3.1",
  "description": "",
  "id": "capec-77:-manipulating-user-controlled-variables;step3.1",
  "type": "scenario",
  "keyword": "Scenario"
});
formatter.step({
  "line": 5,
  "name": "prepare to",
  "keyword": "Given "
});
formatter.step({
  "line": 6,
  "name": "Try to",
  "keyword": "When "
});
formatter.step({
  "comments": [
    {
      "line": 7,
      "value": "# assertion for attack step success"
    }
  ],
  "line": 8,
  "name": "Assert the success of",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 9,
      "value": "#assertions for security pattern testing (checker whether the pattern consequences are observed)"
    }
  ],
  "line": 10,
  "name": "assert the consequences of the pattern",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 11,
      "value": "#"
    }
  ],
  "line": 12,
  "name": "assert the consequences of the pattern audit interceptor",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 13,
      "value": "# depends secure logger"
    }
  ],
  "line": 14,
  "name": "assert the consequences of the pattern secure logger",
  "keyword": "Then "
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({
  "location": "PatternSteps.assauditinterceptor()"
});
formatter.result({
  "status": "skipped"
});
formatter.match({
  "location": "PatternSteps.asssecurelogger()"
});
formatter.result({
  "status": "skipped"
});
formatter.uri("CAPEC_78_Step_1_1.feature");
formatter.feature({
  "line": 2,
  "name": "CAPEC-78: Using Escaped Slashes in Alternate Encoding",
  "description": "",
  "id": "capec-78:-using-escaped-slashes-in-alternate-encoding",
  "keyword": "Feature",
  "tags": [
    {
      "line": 1,
      "name": "@capec78"
    }
  ]
});
formatter.scenario({
  "comments": [
    {
      "line": 3,
      "value": "#1. Experiment"
    }
  ],
  "line": 4,
  "name": "Step1.1",
  "description": "",
  "id": "capec-78:-using-escaped-slashes-in-alternate-encoding;step1.1",
  "type": "scenario",
  "keyword": "Scenario"
});
formatter.step({
  "line": 5,
  "name": "prepare to",
  "keyword": "Given "
});
formatter.step({
  "line": 6,
  "name": "Try to",
  "keyword": "When "
});
formatter.step({
  "comments": [
    {
      "line": 7,
      "value": "# assertion for attack step success"
    }
  ],
  "line": 8,
  "name": "Assert the success of",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 9,
      "value": "#assertions for security pattern testing (checker whether the pattern consequences are observed)"
    }
  ],
  "line": 10,
  "name": "assert the consequences of the pattern",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 11,
      "value": "#"
    }
  ],
  "line": 12,
  "name": "assert the consequences of the pattern audit interceptor",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 13,
      "value": "# depends secure logger"
    }
  ],
  "line": 14,
  "name": "assert the consequences of the pattern secure logger",
  "keyword": "Then "
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({
  "location": "PatternSteps.assauditinterceptor()"
});
formatter.result({
  "status": "skipped"
});
formatter.match({
  "location": "PatternSteps.asssecurelogger()"
});
formatter.result({
  "status": "skipped"
});
formatter.uri("CAPEC_79_Step_1_1.feature");
formatter.feature({
  "line": 2,
  "name": "CAPEC-79: Using Slashes in Alternate Encoding",
  "description": "",
  "id": "capec-79:-using-slashes-in-alternate-encoding",
  "keyword": "Feature",
  "tags": [
    {
      "line": 1,
      "name": "@capec79"
    }
  ]
});
formatter.scenario({
  "comments": [
    {
      "line": 3,
      "value": "#1. Experiment"
    }
  ],
  "line": 4,
  "name": "Step1.1",
  "description": "",
  "id": "capec-79:-using-slashes-in-alternate-encoding;step1.1",
  "type": "scenario",
  "keyword": "Scenario"
});
formatter.step({
  "line": 5,
  "name": "prepare to",
  "keyword": "Given "
});
formatter.step({
  "line": 6,
  "name": "Try to",
  "keyword": "When "
});
formatter.step({
  "comments": [
    {
      "line": 7,
      "value": "# assertion for attack step success"
    }
  ],
  "line": 8,
  "name": "Assert the success of",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 9,
      "value": "#assertions for security pattern testing (checker whether the pattern consequences are observed)"
    }
  ],
  "line": 10,
  "name": "assert the consequences of the pattern",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 11,
      "value": "#"
    }
  ],
  "line": 12,
  "name": "assert the consequences of the pattern audit interceptor",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 13,
      "value": "# depends secure logger"
    }
  ],
  "line": 14,
  "name": "assert the consequences of the pattern secure logger",
  "keyword": "Then "
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({
  "location": "PatternSteps.assauditinterceptor()"
});
formatter.result({
  "status": "skipped"
});
formatter.match({
  "location": "PatternSteps.asssecurelogger()"
});
formatter.result({
  "status": "skipped"
});
formatter.uri("CAPEC_7_Step_1_1.feature");
formatter.feature({
  "line": 2,
  "name": "CAPEC-7: Blind SQL Injection",
  "description": "",
  "id": "capec-7:-blind-sql-injection",
  "keyword": "Feature",
  "tags": [
    {
      "line": 1,
      "name": "@capec7"
    }
  ]
});
formatter.scenario({
  "comments": [
    {
      "line": 3,
      "value": "#1. Explore"
    }
  ],
  "line": 4,
  "name": "Step1.1 Hypothesize SQL queries in application",
  "description": "",
  "id": "capec-7:-blind-sql-injection;step1.1-hypothesize-sql-queries-in-application",
  "type": "scenario",
  "keyword": "Scenario"
});
formatter.step({
  "line": 5,
  "name": "prepare to Hypothesize SQL queries in application",
  "keyword": "Given "
});
formatter.step({
  "line": 6,
  "name": "Try to Hypothesize SQL queries in application",
  "keyword": "When "
});
formatter.step({
  "comments": [
    {
      "line": 7,
      "value": "# assertion for attack step success"
    }
  ],
  "line": 8,
  "name": "Assert the success of Hypothesize SQL queries in application",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 9,
      "value": "#assertions for security pattern testing (checker whether the pattern consequences are observed)"
    }
  ],
  "line": 10,
  "name": "assert the consequences of the pattern",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 11,
      "value": "#"
    }
  ],
  "line": 12,
  "name": "assert the consequences of the pattern audit interceptor",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 13,
      "value": "# depends secure logger"
    }
  ],
  "line": 14,
  "name": "assert the consequences of the pattern secure logger",
  "keyword": "Then "
});
formatter.match({
  "location": "hypothesizesqlqueriesinapplication.prehypothesizesqlqueriesinapplication()"
});
formatter.result({
  "duration": 46012,
  "status": "passed"
});
formatter.match({
  "location": "hypothesizesqlqueriesinapplication.tryhypothesizesqlqueriesinapplication()"
});
formatter.result({
  "duration": 3918,
  "status": "passed"
});
formatter.match({
  "location": "hypothesizesqlqueriesinapplication.asshypothesizesqlqueriesinapplication()"
});
formatter.result({
  "duration": 6608,
  "status": "passed"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({
  "location": "PatternSteps.assauditinterceptor()"
});
formatter.result({
  "status": "skipped"
});
formatter.match({
  "location": "PatternSteps.asssecurelogger()"
});
formatter.result({
  "status": "skipped"
});
formatter.uri("CAPEC_7_Step_1_2.feature");
formatter.feature({
  "line": 2,
  "name": "CAPEC-7: Blind SQL Injection",
  "description": "",
  "id": "capec-7:-blind-sql-injection",
  "keyword": "Feature",
  "tags": [
    {
      "line": 1,
      "name": "@capec7"
    }
  ]
});
formatter.scenario({
  "comments": [
    {
      "line": 3,
      "value": "#1. Explore"
    }
  ],
  "line": 4,
  "name": "Step1.2 Determine how to inject information into the queries",
  "description": "",
  "id": "capec-7:-blind-sql-injection;step1.2-determine-how-to-inject-information-into-the-queries",
  "type": "scenario",
  "keyword": "Scenario"
});
formatter.step({
  "line": 5,
  "name": "prepare to Determine how to inject information into the queries",
  "keyword": "Given "
});
formatter.step({
  "line": 6,
  "name": "Try to Determine how to inject information into the queries",
  "keyword": "When "
});
formatter.step({
  "comments": [
    {
      "line": 7,
      "value": "# assertion for attack step success"
    }
  ],
  "line": 8,
  "name": "Assert the success of Determine how to inject information into the queries",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 9,
      "value": "#assertions for security pattern testing (checker whether the pattern consequences are observed)"
    }
  ],
  "line": 10,
  "name": "assert the consequences of the pattern",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 11,
      "value": "#"
    }
  ],
  "line": 12,
  "name": "assert the consequences of the pattern audit interceptor",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 13,
      "value": "# depends secure logger"
    }
  ],
  "line": 14,
  "name": "assert the consequences of the pattern secure logger",
  "keyword": "Then "
});
formatter.match({
  "location": "determinehowtoinjectinformationintothequeries.predeterminehowtoinjectinformationintothequeries()"
});
formatter.result({
  "duration": 57722,
  "status": "passed"
});
formatter.match({
  "location": "determinehowtoinjectinformationintothequeries.trydeterminehowtoinjectinformationintothequeries()"
});
formatter.result({
  "duration": 3776,
  "status": "passed"
});
formatter.match({
  "location": "determinehowtoinjectinformationintothequeries.assdeterminehowtoinjectinformationintothequeries()"
});
formatter.result({
  "duration": 2867,
  "status": "passed"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({
  "location": "PatternSteps.assauditinterceptor()"
});
formatter.result({
  "status": "skipped"
});
formatter.match({
  "location": "PatternSteps.asssecurelogger()"
});
formatter.result({
  "status": "skipped"
});
formatter.uri("CAPEC_7_Step_2_1.feature");
formatter.feature({
  "line": 2,
  "name": "CAPEC-7: Blind SQL Injection",
  "description": "",
  "id": "capec-7:-blind-sql-injection",
  "keyword": "Feature",
  "tags": [
    {
      "line": 1,
      "name": "@capec7"
    }
  ]
});
formatter.scenario({
  "comments": [
    {
      "line": 3,
      "value": "#2. Experiment"
    }
  ],
  "line": 4,
  "name": "Step2.1 Determine user-controllable input susceptible to injection",
  "description": "",
  "id": "capec-7:-blind-sql-injection;step2.1-determine-user-controllable-input-susceptible-to-injection",
  "type": "scenario",
  "keyword": "Scenario"
});
formatter.step({
  "line": 5,
  "name": "prepare to Determine user-controllable input susceptible to injection",
  "keyword": "Given "
});
formatter.step({
  "line": 6,
  "name": "Try to Determine user-controllable input susceptible to injection",
  "keyword": "When "
});
formatter.step({
  "comments": [
    {
      "line": 7,
      "value": "# assertion for attack step success"
    }
  ],
  "line": 8,
  "name": "Assert the success of Determine user-controllable input susceptible to injection",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 9,
      "value": "#assertions for security pattern testing (checker whether the pattern consequences are observed)"
    }
  ],
  "line": 10,
  "name": "assert the consequences of the pattern secure logger",
  "keyword": "Then "
});
formatter.step({
  "line": 11,
  "name": "assert the consequences of the pattern application firewall",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 12,
      "value": "# alternative input guard"
    }
  ],
  "line": 13,
  "name": "assert the consequences of the pattern input guard",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 14,
      "value": "# alternative application firewall"
    }
  ],
  "line": 15,
  "name": "assert the consequences of the pattern",
  "keyword": "Then "
});
formatter.match({
  "location": "determineusercontrollableinputsusceptibletoinjection.predetermineusercontrollableinputsusceptibletoinjection()"
});
formatter.result({
  "duration": 1335487,
  "error_message": "net.continuumsecurity.proxy.ProxyException: org.zaproxy.clientapi.core.ClientApiException: java.net.ConnectException: Connection refused\n\tat net.continuumsecurity.proxy.ZAProxyScanner.validateMinimumRequiredZapVersion(ZAProxyScanner.java:96)\n\tat net.continuumsecurity.proxy.ZAProxyScanner.\u003cinit\u003e(ZAProxyScanner.java:38)\n\tat steps.determineusercontrollableinputsusceptibletoinjection.predetermineusercontrollableinputsusceptibletoinjection(determineusercontrollableinputsusceptibletoinjection.java:23)\n\tat ✽.Given prepare to Determine user-controllable input susceptible to injection(CAPEC_7_Step_2_1.feature:5)\nCaused by: org.zaproxy.clientapi.core.ClientApiException: java.net.ConnectException: Connection refused\n\tat org.zaproxy.clientapi.core.ClientApi.callApiDom(ClientApi.java:307)\n\tat org.zaproxy.clientapi.core.ClientApi.callApi(ClientApi.java:289)\n\tat org.zaproxy.clientapi.gen.Core.version(Core.java:158)\n\tat net.continuumsecurity.proxy.ZAProxyScanner.validateMinimumRequiredZapVersion(ZAProxyScanner.java:85)\n\tat net.continuumsecurity.proxy.ZAProxyScanner.\u003cinit\u003e(ZAProxyScanner.java:38)\n\tat steps.determineusercontrollableinputsusceptibletoinjection.predetermineusercontrollableinputsusceptibletoinjection(determineusercontrollableinputsusceptibletoinjection.java:23)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.lang.reflect.Method.invoke(Method.java:498)\n\tat cucumber.runtime.Utils$1.call(Utils.java:37)\n\tat cucumber.runtime.Timeout.timeout(Timeout.java:13)\n\tat cucumber.runtime.Utils.invoke(Utils.java:31)\n\tat cucumber.runtime.java.JavaStepDefinition.execute(JavaStepDefinition.java:37)\n\tat cucumber.runtime.StepDefinitionMatch.runStep(StepDefinitionMatch.java:37)\n\tat cucumber.runtime.Runtime.runStep(Runtime.java:298)\n\tat cucumber.runtime.model.StepContainer.runStep(StepContainer.java:44)\n\tat cucumber.runtime.model.StepContainer.runSteps(StepContainer.java:39)\n\tat cucumber.runtime.model.CucumberScenario.run(CucumberScenario.java:48)\n\tat cucumber.runtime.junit.ExecutionUnitRunner.run(ExecutionUnitRunner.java:91)\n\tat cucumber.runtime.junit.FeatureRunner.runChild(FeatureRunner.java:63)\n\tat cucumber.runtime.junit.FeatureRunner.runChild(FeatureRunner.java:18)\n\tat org.junit.runners.ParentRunner$3.run(ParentRunner.java:238)\n\tat org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:63)\n\tat org.junit.runners.ParentRunner.runChildren(ParentRunner.java:236)\n\tat org.junit.runners.ParentRunner.access$000(ParentRunner.java:53)\n\tat org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:229)\n\tat org.junit.runners.ParentRunner.run(ParentRunner.java:309)\n\tat cucumber.runtime.junit.FeatureRunner.run(FeatureRunner.java:70)\n\tat cucumber.api.junit.Cucumber.runChild(Cucumber.java:93)\n\tat cucumber.api.junit.Cucumber.runChild(Cucumber.java:37)\n\tat org.junit.runners.ParentRunner$3.run(ParentRunner.java:238)\n\tat org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:63)\n\tat org.junit.runners.ParentRunner.runChildren(ParentRunner.java:236)\n\tat org.junit.runners.ParentRunner.access$000(ParentRunner.java:53)\n\tat org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:229)\n\tat org.junit.internal.runners.statements.RunAfters.evaluate(RunAfters.java:27)\n\tat org.junit.runners.ParentRunner.run(ParentRunner.java:309)\n\tat cucumber.api.junit.Cucumber.run(Cucumber.java:98)\n\tat org.eclipse.jdt.internal.junit4.runner.JUnit4TestReference.run(JUnit4TestReference.java:86)\n\tat org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:459)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:678)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:382)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:192)\nCaused by: java.net.ConnectException: Connection refused\n\tat java.net.PlainSocketImpl.socketConnect(Native Method)\n\tat java.net.AbstractPlainSocketImpl.doConnect(AbstractPlainSocketImpl.java:350)\n\tat java.net.AbstractPlainSocketImpl.connectToAddress(AbstractPlainSocketImpl.java:206)\n\tat java.net.AbstractPlainSocketImpl.connect(AbstractPlainSocketImpl.java:188)\n\tat java.net.Socket.connect(Socket.java:589)\n\tat java.net.Socket.connect(Socket.java:538)\n\tat sun.net.NetworkClient.doConnect(NetworkClient.java:180)\n\tat sun.net.www.http.HttpClient.openServer(HttpClient.java:432)\n\tat sun.net.www.http.HttpClient$1.run(HttpClient.java:484)\n\tat sun.net.www.http.HttpClient$1.run(HttpClient.java:482)\n\tat java.security.AccessController.doPrivileged(Native Method)\n\tat sun.net.www.http.HttpClient.privilegedOpenServer(HttpClient.java:481)\n\tat sun.net.www.http.HttpClient.openServer(HttpClient.java:522)\n\tat sun.net.www.http.HttpClient.\u003cinit\u003e(HttpClient.java:211)\n\tat sun.net.www.http.HttpClient.New(HttpClient.java:308)\n\tat sun.net.www.http.HttpClient.New(HttpClient.java:326)\n\tat sun.net.www.protocol.http.HttpURLConnection.getNewHttpClient(HttpURLConnection.java:1169)\n\tat sun.net.www.protocol.http.HttpURLConnection.plainConnect0(HttpURLConnection.java:1148)\n\tat sun.net.www.protocol.http.HttpURLConnection.plainConnect(HttpURLConnection.java:999)\n\tat sun.net.www.protocol.http.HttpURLConnection.connect(HttpURLConnection.java:933)\n\tat org.zaproxy.clientapi.core.ClientApi.getConnectionInputStream(ClientApi.java:313)\n\tat org.zaproxy.clientapi.core.ClientApi.callApiDom(ClientApi.java:305)\n\t... 44 more\n",
  "status": "failed"
});
formatter.match({
  "location": "determineusercontrollableinputsusceptibletoinjection.trydetermineusercontrollableinputsusceptibletoinjection()"
});
formatter.result({
  "status": "skipped"
});
formatter.match({
  "location": "determineusercontrollableinputsusceptibletoinjection.assdetermineusercontrollableinputsusceptibletoinjection()"
});
formatter.result({
  "status": "skipped"
});
formatter.match({
  "location": "PatternSteps.asssecurelogger()"
});
formatter.result({
  "status": "skipped"
});
formatter.match({
  "location": "PatternSteps.assapplicationfirewall()"
});
formatter.result({
  "status": "skipped"
});
formatter.match({
  "location": "PatternSteps.assinputguard()"
});
formatter.result({
  "status": "skipped"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.uri("CAPEC_7_Step_2_2.feature");
formatter.feature({
  "line": 2,
  "name": "CAPEC-7: Blind SQL Injection",
  "description": "",
  "id": "capec-7:-blind-sql-injection",
  "keyword": "Feature",
  "tags": [
    {
      "line": 1,
      "name": "@capec7"
    }
  ]
});
formatter.scenario({
  "comments": [
    {
      "line": 3,
      "value": "#2. Experiment"
    }
  ],
  "line": 4,
  "name": "Step2.2 Determine database type",
  "description": "",
  "id": "capec-7:-blind-sql-injection;step2.2-determine-database-type",
  "type": "scenario",
  "keyword": "Scenario"
});
formatter.step({
  "line": 5,
  "name": "prepare to Determine database type",
  "keyword": "Given "
});
formatter.step({
  "line": 6,
  "name": "Try to Determine database type",
  "keyword": "When "
});
formatter.step({
  "comments": [
    {
      "line": 7,
      "value": "# assertion for attack step success"
    }
  ],
  "line": 8,
  "name": "Assert the success of Determine database type",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 9,
      "value": "#assertions for security pattern testing (checker whether the pattern consequences are observed)"
    }
  ],
  "line": 10,
  "name": "assert the consequences of the pattern",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 11,
      "value": "#"
    }
  ],
  "line": 12,
  "name": "assert the consequences of the pattern audit interceptor",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 13,
      "value": "# depends secure logger"
    }
  ],
  "line": 14,
  "name": "assert the consequences of the pattern secure logger",
  "keyword": "Then "
});
formatter.match({
  "location": "determinedatabasetype.predeterminedatabasetype()"
});
formatter.result({
  "duration": 56672,
  "status": "passed"
});
formatter.match({
  "location": "determinedatabasetype.trydeterminedatabasetype()"
});
formatter.result({
  "duration": 7565,
  "status": "passed"
});
formatter.match({
  "location": "determinedatabasetype.assdeterminedatabasetype()"
});
formatter.result({
  "duration": 18276,
  "status": "passed"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({
  "location": "PatternSteps.assauditinterceptor()"
});
formatter.result({
  "status": "skipped"
});
formatter.match({
  "location": "PatternSteps.asssecurelogger()"
});
formatter.result({
  "status": "skipped"
});
formatter.uri("CAPEC_7_Step_3_1.feature");
formatter.feature({
  "line": 2,
  "name": "CAPEC-7: Blind SQL Injection",
  "description": "",
  "id": "capec-7:-blind-sql-injection",
  "keyword": "Feature",
  "tags": [
    {
      "line": 1,
      "name": "@capec7"
    }
  ]
});
formatter.scenario({
  "comments": [
    {
      "line": 3,
      "value": "#3. Exploit"
    }
  ],
  "line": 4,
  "name": "Step3.1 Extract information about database schema",
  "description": "",
  "id": "capec-7:-blind-sql-injection;step3.1-extract-information-about-database-schema",
  "type": "scenario",
  "keyword": "Scenario"
});
formatter.step({
  "line": 5,
  "name": "prepare to Extract information about database schema",
  "keyword": "Given "
});
formatter.step({
  "line": 6,
  "name": "Try to Extract information about database schema",
  "keyword": "When "
});
formatter.step({
  "comments": [
    {
      "line": 7,
      "value": "# assertion for attack step success"
    }
  ],
  "line": 8,
  "name": "Assert the success of Extract information about database schema",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 9,
      "value": "#assertions for security pattern testing (checker whether the pattern consequences are observed)"
    }
  ],
  "line": 10,
  "name": "assert the consequences of the pattern",
  "keyword": "Then "
});
formatter.match({
  "location": "extractinformationaboutdatabaseschema.preextractinformationaboutdatabaseschema()"
});
formatter.result({
  "duration": 59224,
  "status": "passed"
});
formatter.match({
  "location": "extractinformationaboutdatabaseschema.tryextractinformationaboutdatabaseschema()"
});
formatter.result({
  "duration": 3798,
  "status": "passed"
});
formatter.match({
  "location": "extractinformationaboutdatabaseschema.assextractinformationaboutdatabaseschema()"
});
formatter.result({
  "duration": 2842,
  "status": "passed"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.uri("CAPEC_7_Step_3_2.feature");
formatter.feature({
  "line": 2,
  "name": "CAPEC-7: Blind SQL Injection",
  "description": "",
  "id": "capec-7:-blind-sql-injection",
  "keyword": "Feature",
  "tags": [
    {
      "line": 1,
      "name": "@capec7"
    }
  ]
});
formatter.scenario({
  "comments": [
    {
      "line": 3,
      "value": "#3. Exploit"
    }
  ],
  "line": 4,
  "name": "Step3.2 Exploit SQL Injection vulnerability",
  "description": "",
  "id": "capec-7:-blind-sql-injection;step3.2-exploit-sql-injection-vulnerability",
  "type": "scenario",
  "keyword": "Scenario"
});
formatter.step({
  "line": 5,
  "name": "prepare to Exploit SQL Injection vulnerability",
  "keyword": "Given "
});
formatter.step({
  "line": 6,
  "name": "Try to Exploit SQL Injection vulnerability",
  "keyword": "When "
});
formatter.step({
  "comments": [
    {
      "line": 7,
      "value": "# assertion for attack step success"
    }
  ],
  "line": 8,
  "name": "Assert the success of Exploit SQL Injection vulnerability",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 9,
      "value": "#assertions for security pattern testing (checker whether the pattern consequences are observed)"
    }
  ],
  "line": 10,
  "name": "assert the consequences of the pattern",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 11,
      "value": "#"
    }
  ],
  "line": 12,
  "name": "assert the consequences of the pattern audit interceptor",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 13,
      "value": "# depends secure logger"
    }
  ],
  "line": 14,
  "name": "assert the consequences of the pattern secure logger",
  "keyword": "Then "
});
formatter.match({
  "location": "exploitsqlinjectionvulnerability.preexploitsqlinjectionvulnerability()"
});
formatter.result({
  "duration": 35111,
  "status": "passed"
});
formatter.match({
  "location": "exploitsqlinjectionvulnerability.tryexploitsqlinjectionvulnerability()"
});
formatter.result({
  "duration": 4207,
  "status": "passed"
});
formatter.match({
  "location": "exploitsqlinjectionvulnerability.assexploitsqlinjectionvulnerability()"
});
formatter.result({
  "duration": 3383,
  "status": "passed"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({
  "location": "PatternSteps.assauditinterceptor()"
});
formatter.result({
  "status": "skipped"
});
formatter.match({
  "location": "PatternSteps.asssecurelogger()"
});
formatter.result({
  "status": "skipped"
});
formatter.uri("CAPEC_80_Step_1_1.feature");
formatter.feature({
  "line": 2,
  "name": "CAPEC-80: Using UTF-8 Encoding to Bypass Validation Logic",
  "description": "",
  "id": "capec-80:-using-utf-8-encoding-to-bypass-validation-logic",
  "keyword": "Feature",
  "tags": [
    {
      "line": 1,
      "name": "@capec80"
    }
  ]
});
formatter.scenario({
  "comments": [
    {
      "line": 3,
      "value": "#1. Explore"
    }
  ],
  "line": 4,
  "name": "Step1.1 Survey the application for user-controllable inputs",
  "description": "",
  "id": "capec-80:-using-utf-8-encoding-to-bypass-validation-logic;step1.1-survey-the-application-for-user-controllable-inputs",
  "type": "scenario",
  "keyword": "Scenario"
});
formatter.step({
  "line": 5,
  "name": "prepare to Survey the application for user-controllable inputs",
  "keyword": "Given "
});
formatter.step({
  "line": 6,
  "name": "Try to Survey the application for user-controllable inputs",
  "keyword": "When "
});
formatter.step({
  "comments": [
    {
      "line": 7,
      "value": "# assertion for attack step success"
    }
  ],
  "line": 8,
  "name": "Assert the success of Survey the application for user-controllable inputs",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 9,
      "value": "#assertions for security pattern testing (checker whether the pattern consequences are observed)"
    }
  ],
  "line": 10,
  "name": "assert the consequences of the pattern",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 11,
      "value": "#"
    }
  ],
  "line": 12,
  "name": "assert the consequences of the pattern audit interceptor",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 13,
      "value": "# depends secure logger"
    }
  ],
  "line": 14,
  "name": "assert the consequences of the pattern secure logger",
  "keyword": "Then "
});
formatter.match({
  "location": "survey.presurvey()"
});
formatter.result({
  "duration": 0,
  "error_message": "cucumber.runtime.AmbiguousStepDefinitionsException: ✽.Given prepare to Survey the application for user-controllable inputs(CAPEC_80_Step_1_1.feature:5) matches more than one step definition:\n  prepare to Survey in survey.presurvey()\n  prepare to Survey the application in surveytheapplication.presurveytheapplication()\n  prepare to Survey the application for user-controllable inputs in surveytheapplicationforusercontrollableinputs.presurveytheapplicationforusercontrollableinputs()\n\n\tat cucumber.runtime.RuntimeGlue.stepDefinitionMatch(RuntimeGlue.java:71)\n\tat cucumber.runtime.Runtime.runStep(Runtime.java:265)\n\tat cucumber.runtime.model.StepContainer.runStep(StepContainer.java:44)\n\tat cucumber.runtime.model.StepContainer.runSteps(StepContainer.java:39)\n\tat cucumber.runtime.model.CucumberScenario.run(CucumberScenario.java:48)\n\tat cucumber.runtime.junit.ExecutionUnitRunner.run(ExecutionUnitRunner.java:91)\n\tat cucumber.runtime.junit.FeatureRunner.runChild(FeatureRunner.java:63)\n\tat cucumber.runtime.junit.FeatureRunner.runChild(FeatureRunner.java:18)\n\tat org.junit.runners.ParentRunner$3.run(ParentRunner.java:238)\n\tat org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:63)\n\tat org.junit.runners.ParentRunner.runChildren(ParentRunner.java:236)\n\tat org.junit.runners.ParentRunner.access$000(ParentRunner.java:53)\n\tat org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:229)\n\tat org.junit.runners.ParentRunner.run(ParentRunner.java:309)\n\tat cucumber.runtime.junit.FeatureRunner.run(FeatureRunner.java:70)\n\tat cucumber.api.junit.Cucumber.runChild(Cucumber.java:93)\n\tat cucumber.api.junit.Cucumber.runChild(Cucumber.java:37)\n\tat org.junit.runners.ParentRunner$3.run(ParentRunner.java:238)\n\tat org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:63)\n\tat org.junit.runners.ParentRunner.runChildren(ParentRunner.java:236)\n\tat org.junit.runners.ParentRunner.access$000(ParentRunner.java:53)\n\tat org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:229)\n\tat org.junit.internal.runners.statements.RunAfters.evaluate(RunAfters.java:27)\n\tat org.junit.runners.ParentRunner.run(ParentRunner.java:309)\n\tat cucumber.api.junit.Cucumber.run(Cucumber.java:98)\n\tat org.eclipse.jdt.internal.junit4.runner.JUnit4TestReference.run(JUnit4TestReference.java:86)\n\tat org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:459)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:678)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:382)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:192)\n",
  "status": "failed"
});
formatter.match({
  "location": "survey.trysurvey()"
});
formatter.result({
  "duration": 0,
  "error_message": "cucumber.runtime.AmbiguousStepDefinitionsException: ✽.When Try to Survey the application for user-controllable inputs(CAPEC_80_Step_1_1.feature:6) matches more than one step definition:\n  Try to Survey in survey.trysurvey()\n  Try to Survey the application in surveytheapplication.trysurveytheapplication()\n  Try to Survey the application for user-controllable inputs in surveytheapplicationforusercontrollableinputs.trysurveytheapplicationforusercontrollableinputs()\n\n\tat cucumber.runtime.RuntimeGlue.stepDefinitionMatch(RuntimeGlue.java:71)\n\tat cucumber.runtime.Runtime.runStep(Runtime.java:265)\n\tat cucumber.runtime.model.StepContainer.runStep(StepContainer.java:44)\n\tat cucumber.runtime.model.StepContainer.runSteps(StepContainer.java:39)\n\tat cucumber.runtime.model.CucumberScenario.run(CucumberScenario.java:48)\n\tat cucumber.runtime.junit.ExecutionUnitRunner.run(ExecutionUnitRunner.java:91)\n\tat cucumber.runtime.junit.FeatureRunner.runChild(FeatureRunner.java:63)\n\tat cucumber.runtime.junit.FeatureRunner.runChild(FeatureRunner.java:18)\n\tat org.junit.runners.ParentRunner$3.run(ParentRunner.java:238)\n\tat org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:63)\n\tat org.junit.runners.ParentRunner.runChildren(ParentRunner.java:236)\n\tat org.junit.runners.ParentRunner.access$000(ParentRunner.java:53)\n\tat org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:229)\n\tat org.junit.runners.ParentRunner.run(ParentRunner.java:309)\n\tat cucumber.runtime.junit.FeatureRunner.run(FeatureRunner.java:70)\n\tat cucumber.api.junit.Cucumber.runChild(Cucumber.java:93)\n\tat cucumber.api.junit.Cucumber.runChild(Cucumber.java:37)\n\tat org.junit.runners.ParentRunner$3.run(ParentRunner.java:238)\n\tat org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:63)\n\tat org.junit.runners.ParentRunner.runChildren(ParentRunner.java:236)\n\tat org.junit.runners.ParentRunner.access$000(ParentRunner.java:53)\n\tat org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:229)\n\tat org.junit.internal.runners.statements.RunAfters.evaluate(RunAfters.java:27)\n\tat org.junit.runners.ParentRunner.run(ParentRunner.java:309)\n\tat cucumber.api.junit.Cucumber.run(Cucumber.java:98)\n\tat org.eclipse.jdt.internal.junit4.runner.JUnit4TestReference.run(JUnit4TestReference.java:86)\n\tat org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:459)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:678)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:382)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:192)\n",
  "status": "failed"
});
formatter.match({
  "location": "survey.asssurvey()"
});
formatter.result({
  "duration": 0,
  "error_message": "cucumber.runtime.AmbiguousStepDefinitionsException: ✽.Then Assert the success of Survey the application for user-controllable inputs(CAPEC_80_Step_1_1.feature:8) matches more than one step definition:\n  Assert the success of Survey in survey.asssurvey()\n  Assert the success of Survey the application in surveytheapplication.asssurveytheapplication()\n  Assert the success of Survey the application for user-controllable inputs in surveytheapplicationforusercontrollableinputs.asssurveytheapplicationforusercontrollableinputs()\n\n\tat cucumber.runtime.RuntimeGlue.stepDefinitionMatch(RuntimeGlue.java:71)\n\tat cucumber.runtime.Runtime.runStep(Runtime.java:265)\n\tat cucumber.runtime.model.StepContainer.runStep(StepContainer.java:44)\n\tat cucumber.runtime.model.StepContainer.runSteps(StepContainer.java:39)\n\tat cucumber.runtime.model.CucumberScenario.run(CucumberScenario.java:48)\n\tat cucumber.runtime.junit.ExecutionUnitRunner.run(ExecutionUnitRunner.java:91)\n\tat cucumber.runtime.junit.FeatureRunner.runChild(FeatureRunner.java:63)\n\tat cucumber.runtime.junit.FeatureRunner.runChild(FeatureRunner.java:18)\n\tat org.junit.runners.ParentRunner$3.run(ParentRunner.java:238)\n\tat org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:63)\n\tat org.junit.runners.ParentRunner.runChildren(ParentRunner.java:236)\n\tat org.junit.runners.ParentRunner.access$000(ParentRunner.java:53)\n\tat org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:229)\n\tat org.junit.runners.ParentRunner.run(ParentRunner.java:309)\n\tat cucumber.runtime.junit.FeatureRunner.run(FeatureRunner.java:70)\n\tat cucumber.api.junit.Cucumber.runChild(Cucumber.java:93)\n\tat cucumber.api.junit.Cucumber.runChild(Cucumber.java:37)\n\tat org.junit.runners.ParentRunner$3.run(ParentRunner.java:238)\n\tat org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:63)\n\tat org.junit.runners.ParentRunner.runChildren(ParentRunner.java:236)\n\tat org.junit.runners.ParentRunner.access$000(ParentRunner.java:53)\n\tat org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:229)\n\tat org.junit.internal.runners.statements.RunAfters.evaluate(RunAfters.java:27)\n\tat org.junit.runners.ParentRunner.run(ParentRunner.java:309)\n\tat cucumber.api.junit.Cucumber.run(Cucumber.java:98)\n\tat org.eclipse.jdt.internal.junit4.runner.JUnit4TestReference.run(JUnit4TestReference.java:86)\n\tat org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:459)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:678)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:382)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:192)\n",
  "status": "failed"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({
  "location": "PatternSteps.assauditinterceptor()"
});
formatter.result({
  "status": "skipped"
});
formatter.match({
  "location": "PatternSteps.asssecurelogger()"
});
formatter.result({
  "status": "skipped"
});
formatter.uri("CAPEC_80_Step_2_1.feature");
formatter.feature({
  "line": 2,
  "name": "CAPEC-80: Using UTF-8 Encoding to Bypass Validation Logic",
  "description": "",
  "id": "capec-80:-using-utf-8-encoding-to-bypass-validation-logic",
  "keyword": "Feature",
  "tags": [
    {
      "line": 1,
      "name": "@capec80"
    }
  ]
});
formatter.scenario({
  "comments": [
    {
      "line": 3,
      "value": "#2. Experiment"
    }
  ],
  "line": 4,
  "name": "Step2.1 Probe entry points to locate vulnerabilities",
  "description": "",
  "id": "capec-80:-using-utf-8-encoding-to-bypass-validation-logic;step2.1-probe-entry-points-to-locate-vulnerabilities",
  "type": "scenario",
  "keyword": "Scenario"
});
formatter.step({
  "line": 5,
  "name": "prepare to Probe entry points to locate vulnerabilities",
  "keyword": "Given "
});
formatter.step({
  "line": 6,
  "name": "Try to Probe entry points to locate vulnerabilities",
  "keyword": "When "
});
formatter.step({
  "comments": [
    {
      "line": 7,
      "value": "# assertion for attack step success"
    }
  ],
  "line": 8,
  "name": "Assert the success of Probe entry points to locate vulnerabilities",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 9,
      "value": "#assertions for security pattern testing (checker whether the pattern consequences are observed)"
    }
  ],
  "line": 10,
  "name": "assert the consequences of the pattern application firewall",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 11,
      "value": "# alternative input guard"
    }
  ],
  "line": 12,
  "name": "assert the consequences of the pattern input guard",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 13,
      "value": "# alternative application firewall"
    }
  ],
  "line": 14,
  "name": "assert the consequences of the pattern pathname canonicalization",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 15,
      "value": "#"
    }
  ],
  "line": 16,
  "name": "assert the consequences of the pattern",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 17,
      "value": "#"
    }
  ],
  "line": 18,
  "name": "assert the consequences of the pattern audit interceptor",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 19,
      "value": "# depends secure logger"
    }
  ],
  "line": 20,
  "name": "assert the consequences of the pattern secure logger",
  "keyword": "Then "
});
formatter.match({
  "location": "probeentrypointstolocatevulnerabilities.preprobeentrypointstolocatevulnerabilities()"
});
formatter.result({
  "duration": 36020,
  "status": "passed"
});
formatter.match({
  "location": "probeentrypointstolocatevulnerabilities.tryprobeentrypointstolocatevulnerabilities()"
});
formatter.result({
  "duration": 3119,
  "status": "passed"
});
formatter.match({
  "location": "probeentrypointstolocatevulnerabilities.assprobeentrypointstolocatevulnerabilities()"
});
formatter.result({
  "duration": 2781,
  "status": "passed"
});
formatter.match({
  "location": "PatternSteps.assapplicationfirewall()"
});
formatter.result({
  "duration": 13681,
  "status": "passed"
});
formatter.match({
  "location": "PatternSteps.assinputguard()"
});
formatter.result({
  "duration": 3608,
  "status": "passed"
});
formatter.match({
  "location": "PatternSteps.asspathnamecanonicalization()"
});
formatter.result({
  "duration": 2917,
  "status": "passed"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({
  "location": "PatternSteps.assauditinterceptor()"
});
formatter.result({
  "status": "skipped"
});
formatter.match({
  "location": "PatternSteps.asssecurelogger()"
});
formatter.result({
  "status": "skipped"
});
formatter.uri("CAPEC_81_Step_1_1.feature");
formatter.feature({
  "line": 2,
  "name": "CAPEC-81: Web Logs Tampering",
  "description": "",
  "id": "capec-81:-web-logs-tampering",
  "keyword": "Feature",
  "tags": [
    {
      "line": 1,
      "name": "@capec81"
    }
  ]
});
formatter.scenario({
  "comments": [
    {
      "line": 3,
      "value": "#1. Explore"
    }
  ],
  "line": 4,
  "name": "Step1.1 Determine Application Web Server Log File Format",
  "description": "",
  "id": "capec-81:-web-logs-tampering;step1.1-determine-application-web-server-log-file-format",
  "type": "scenario",
  "keyword": "Scenario"
});
formatter.step({
  "line": 5,
  "name": "prepare to Determine Application Web Server Log File Format",
  "keyword": "Given "
});
formatter.step({
  "line": 6,
  "name": "Try to Determine Application Web Server Log File Format",
  "keyword": "When "
});
formatter.step({
  "comments": [
    {
      "line": 7,
      "value": "# assertion for attack step success"
    }
  ],
  "line": 8,
  "name": "Assert the success of Determine Application Web Server Log File Format",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 9,
      "value": "#assertions for security pattern testing (checker whether the pattern consequences are observed)"
    }
  ],
  "line": 10,
  "name": "assert the consequences of the pattern",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 11,
      "value": "#"
    }
  ],
  "line": 12,
  "name": "assert the consequences of the pattern audit interceptor",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 13,
      "value": "# depends secure logger"
    }
  ],
  "line": 14,
  "name": "assert the consequences of the pattern secure logger",
  "keyword": "Then "
});
formatter.match({
  "location": "determineapplicationwebserverlogfileformat.predetermineapplicationwebserverlogfileformat()"
});
formatter.result({
  "duration": 61189,
  "status": "passed"
});
formatter.match({
  "location": "determineapplicationwebserverlogfileformat.trydetermineapplicationwebserverlogfileformat()"
});
formatter.result({
  "duration": 7854,
  "status": "passed"
});
formatter.match({
  "location": "determineapplicationwebserverlogfileformat.assdetermineapplicationwebserverlogfileformat()"
});
formatter.result({
  "duration": 3571,
  "status": "passed"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({
  "location": "PatternSteps.assauditinterceptor()"
});
formatter.result({
  "status": "skipped"
});
formatter.match({
  "location": "PatternSteps.asssecurelogger()"
});
formatter.result({
  "status": "skipped"
});
formatter.uri("CAPEC_81_Step_2_1.feature");
formatter.feature({
  "line": 2,
  "name": "CAPEC-81: Web Logs Tampering",
  "description": "",
  "id": "capec-81:-web-logs-tampering",
  "keyword": "Feature",
  "tags": [
    {
      "line": 1,
      "name": "@capec81"
    }
  ]
});
formatter.scenario({
  "comments": [
    {
      "line": 3,
      "value": "#2. Experiment"
    }
  ],
  "line": 4,
  "name": "Step2.1 Determine Injectable Content",
  "description": "",
  "id": "capec-81:-web-logs-tampering;step2.1-determine-injectable-content",
  "type": "scenario",
  "keyword": "Scenario"
});
formatter.step({
  "line": 5,
  "name": "prepare to Determine Injectable Content",
  "keyword": "Given "
});
formatter.step({
  "line": 6,
  "name": "Try to Determine Injectable Content",
  "keyword": "When "
});
formatter.step({
  "comments": [
    {
      "line": 7,
      "value": "# assertion for attack step success"
    }
  ],
  "line": 8,
  "name": "Assert the success of Determine Injectable Content",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 9,
      "value": "#assertions for security pattern testing (checker whether the pattern consequences are observed)"
    }
  ],
  "line": 10,
  "name": "assert the consequences of the pattern",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 11,
      "value": "#"
    }
  ],
  "line": 12,
  "name": "assert the consequences of the pattern audit interceptor",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 13,
      "value": "# depends secure logger"
    }
  ],
  "line": 14,
  "name": "assert the consequences of the pattern secure logger",
  "keyword": "Then "
});
formatter.match({
  "location": "determineinjectablecontent.predetermineinjectablecontent()"
});
formatter.result({
  "duration": 67374,
  "status": "passed"
});
formatter.match({
  "location": "determineinjectablecontent.trydetermineinjectablecontent()"
});
formatter.result({
  "duration": 5138,
  "status": "passed"
});
formatter.match({
  "location": "determineinjectablecontent.assdetermineinjectablecontent()"
});
formatter.result({
  "duration": 4544,
  "status": "passed"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({
  "location": "PatternSteps.assauditinterceptor()"
});
formatter.result({
  "status": "skipped"
});
formatter.match({
  "location": "PatternSteps.asssecurelogger()"
});
formatter.result({
  "status": "skipped"
});
formatter.uri("CAPEC_81_Step_3_1.feature");
formatter.feature({
  "line": 2,
  "name": "CAPEC-81: Web Logs Tampering",
  "description": "",
  "id": "capec-81:-web-logs-tampering",
  "keyword": "Feature",
  "tags": [
    {
      "line": 1,
      "name": "@capec81"
    }
  ]
});
formatter.scenario({
  "comments": [
    {
      "line": 3,
      "value": "#3. Exploit"
    }
  ],
  "line": 4,
  "name": "Step3.1 Manipulate Log Files",
  "description": "",
  "id": "capec-81:-web-logs-tampering;step3.1-manipulate-log-files",
  "type": "scenario",
  "keyword": "Scenario"
});
formatter.step({
  "line": 5,
  "name": "prepare to Manipulate Log Files",
  "keyword": "Given "
});
formatter.step({
  "line": 6,
  "name": "Try to Manipulate Log Files",
  "keyword": "When "
});
formatter.step({
  "comments": [
    {
      "line": 7,
      "value": "# assertion for attack step success"
    }
  ],
  "line": 8,
  "name": "Assert the success of Manipulate Log Files",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 9,
      "value": "#assertions for security pattern testing (checker whether the pattern consequences are observed)"
    }
  ],
  "line": 10,
  "name": "assert the consequences of the pattern secure logger",
  "keyword": "Then "
});
formatter.step({
  "line": 11,
  "name": "assert the consequences of the pattern application firewall",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 12,
      "value": "# alternative output guard"
    },
    {
      "line": 13,
      "value": "# alternative input guard"
    }
  ],
  "line": 14,
  "name": "assert the consequences of the pattern input guard",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 15,
      "value": "# alternative application firewall"
    },
    {
      "line": 16,
      "value": "# benifits output guard"
    }
  ],
  "line": 17,
  "name": "assert the consequences of the pattern pathname canonicalization",
  "keyword": "Then "
});
formatter.step({
  "line": 18,
  "name": "assert the consequences of the pattern output guard",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 19,
      "value": "# alternative application firewall"
    },
    {
      "line": 20,
      "value": "# benifits input guard"
    }
  ],
  "line": 21,
  "name": "assert the consequences of the pattern comparator checked fault tolerant system",
  "keyword": "Then "
});
formatter.match({
  "location": "manipulatelogfiles.premanipulatelogfiles()"
});
formatter.result({
  "duration": 51637,
  "status": "passed"
});
formatter.match({
  "location": "manipulatelogfiles.trymanipulatelogfiles()"
});
formatter.result({
  "duration": 4116,
  "status": "passed"
});
formatter.match({
  "location": "manipulatelogfiles.assmanipulatelogfiles()"
});
formatter.result({
  "duration": 3886,
  "status": "passed"
});
formatter.match({
  "location": "PatternSteps.asssecurelogger()"
});
formatter.result({
  "duration": 14394,
  "status": "passed"
});
formatter.match({
  "location": "PatternSteps.assapplicationfirewall()"
});
formatter.result({
  "duration": 5282,
  "status": "passed"
});
formatter.match({
  "location": "PatternSteps.assinputguard()"
});
formatter.result({
  "duration": 3771,
  "status": "passed"
});
formatter.match({
  "location": "PatternSteps.asspathnamecanonicalization()"
});
formatter.result({
  "duration": 4999,
  "status": "passed"
});
formatter.match({
  "location": "PatternSteps.assoutputguard()"
});
formatter.result({
  "duration": 4724,
  "status": "passed"
});
formatter.match({
  "location": "PatternSteps.asscomparatorcheckedfaulttolerantsystem()"
});
formatter.result({
  "duration": 3187,
  "status": "passed"
});
formatter.uri("CAPEC_83_Step_1_1.feature");
formatter.feature({
  "line": 2,
  "name": "CAPEC-83: XPath Injection",
  "description": "",
  "id": "capec-83:-xpath-injection",
  "keyword": "Feature",
  "tags": [
    {
      "line": 1,
      "name": "@capec83"
    }
  ]
});
formatter.scenario({
  "comments": [
    {
      "line": 3,
      "value": "#1. Explore"
    }
  ],
  "line": 4,
  "name": "Step1.1",
  "description": "",
  "id": "capec-83:-xpath-injection;step1.1",
  "type": "scenario",
  "keyword": "Scenario"
});
formatter.step({
  "line": 5,
  "name": "prepare to",
  "keyword": "Given "
});
formatter.step({
  "line": 6,
  "name": "Try to",
  "keyword": "When "
});
formatter.step({
  "comments": [
    {
      "line": 7,
      "value": "# assertion for attack step success"
    }
  ],
  "line": 8,
  "name": "Assert the success of",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 9,
      "value": "#assertions for security pattern testing (checker whether the pattern consequences are observed)"
    }
  ],
  "line": 10,
  "name": "assert the consequences of the pattern",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 11,
      "value": "#"
    }
  ],
  "line": 12,
  "name": "assert the consequences of the pattern audit interceptor",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 13,
      "value": "# depends secure logger"
    }
  ],
  "line": 14,
  "name": "assert the consequences of the pattern secure logger",
  "keyword": "Then "
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({
  "location": "PatternSteps.assauditinterceptor()"
});
formatter.result({
  "status": "skipped"
});
formatter.match({
  "location": "PatternSteps.asssecurelogger()"
});
formatter.result({
  "status": "skipped"
});
formatter.uri("CAPEC_83_Step_2_1.feature");
formatter.feature({
  "line": 2,
  "name": "CAPEC-83: XPath Injection",
  "description": "",
  "id": "capec-83:-xpath-injection",
  "keyword": "Feature",
  "tags": [
    {
      "line": 1,
      "name": "@capec83"
    }
  ]
});
formatter.scenario({
  "comments": [
    {
      "line": 3,
      "value": "#2. Exploit"
    }
  ],
  "line": 4,
  "name": "Step2.1",
  "description": "",
  "id": "capec-83:-xpath-injection;step2.1",
  "type": "scenario",
  "keyword": "Scenario"
});
formatter.step({
  "line": 5,
  "name": "prepare to",
  "keyword": "Given "
});
formatter.step({
  "line": 6,
  "name": "Try to",
  "keyword": "When "
});
formatter.step({
  "comments": [
    {
      "line": 7,
      "value": "# assertion for attack step success"
    }
  ],
  "line": 8,
  "name": "Assert the success of",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 9,
      "value": "#assertions for security pattern testing (checker whether the pattern consequences are observed)"
    }
  ],
  "line": 10,
  "name": "assert the consequences of the pattern",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 11,
      "value": "#"
    }
  ],
  "line": 12,
  "name": "assert the consequences of the pattern audit interceptor",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 13,
      "value": "# depends secure logger"
    }
  ],
  "line": 14,
  "name": "assert the consequences of the pattern secure logger",
  "keyword": "Then "
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({
  "location": "PatternSteps.assauditinterceptor()"
});
formatter.result({
  "status": "skipped"
});
formatter.match({
  "location": "PatternSteps.asssecurelogger()"
});
formatter.result({
  "status": "skipped"
});
formatter.uri("CAPEC_84_Step_1_1.feature");
formatter.feature({
  "line": 2,
  "name": "CAPEC-84: XQuery Injection",
  "description": "",
  "id": "capec-84:-xquery-injection",
  "keyword": "Feature",
  "tags": [
    {
      "line": 1,
      "name": "@capec84"
    }
  ]
});
formatter.scenario({
  "comments": [
    {
      "line": 3,
      "value": "#1. Explore"
    }
  ],
  "line": 4,
  "name": "Step1.1 Survey the application for user-controllable inputs",
  "description": "",
  "id": "capec-84:-xquery-injection;step1.1-survey-the-application-for-user-controllable-inputs",
  "type": "scenario",
  "keyword": "Scenario"
});
formatter.step({
  "line": 5,
  "name": "prepare to Survey the application for user-controllable inputs",
  "keyword": "Given "
});
formatter.step({
  "line": 6,
  "name": "Try to Survey the application for user-controllable inputs",
  "keyword": "When "
});
formatter.step({
  "comments": [
    {
      "line": 7,
      "value": "# assertion for attack step success"
    }
  ],
  "line": 8,
  "name": "Assert the success of Survey the application for user-controllable inputs",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 9,
      "value": "#assertions for security pattern testing (checker whether the pattern consequences are observed)"
    }
  ],
  "line": 10,
  "name": "assert the consequences of the pattern",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 11,
      "value": "#"
    }
  ],
  "line": 12,
  "name": "assert the consequences of the pattern audit interceptor",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 13,
      "value": "# depends secure logger"
    }
  ],
  "line": 14,
  "name": "assert the consequences of the pattern secure logger",
  "keyword": "Then "
});
formatter.match({
  "location": "survey.presurvey()"
});
formatter.result({
  "duration": 0,
  "error_message": "cucumber.runtime.AmbiguousStepDefinitionsException: ✽.Given prepare to Survey the application for user-controllable inputs(CAPEC_84_Step_1_1.feature:5) matches more than one step definition:\n  prepare to Survey in survey.presurvey()\n  prepare to Survey the application in surveytheapplication.presurveytheapplication()\n  prepare to Survey the application for user-controllable inputs in surveytheapplicationforusercontrollableinputs.presurveytheapplicationforusercontrollableinputs()\n\n\tat cucumber.runtime.RuntimeGlue.stepDefinitionMatch(RuntimeGlue.java:71)\n\tat cucumber.runtime.Runtime.runStep(Runtime.java:265)\n\tat cucumber.runtime.model.StepContainer.runStep(StepContainer.java:44)\n\tat cucumber.runtime.model.StepContainer.runSteps(StepContainer.java:39)\n\tat cucumber.runtime.model.CucumberScenario.run(CucumberScenario.java:48)\n\tat cucumber.runtime.junit.ExecutionUnitRunner.run(ExecutionUnitRunner.java:91)\n\tat cucumber.runtime.junit.FeatureRunner.runChild(FeatureRunner.java:63)\n\tat cucumber.runtime.junit.FeatureRunner.runChild(FeatureRunner.java:18)\n\tat org.junit.runners.ParentRunner$3.run(ParentRunner.java:238)\n\tat org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:63)\n\tat org.junit.runners.ParentRunner.runChildren(ParentRunner.java:236)\n\tat org.junit.runners.ParentRunner.access$000(ParentRunner.java:53)\n\tat org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:229)\n\tat org.junit.runners.ParentRunner.run(ParentRunner.java:309)\n\tat cucumber.runtime.junit.FeatureRunner.run(FeatureRunner.java:70)\n\tat cucumber.api.junit.Cucumber.runChild(Cucumber.java:93)\n\tat cucumber.api.junit.Cucumber.runChild(Cucumber.java:37)\n\tat org.junit.runners.ParentRunner$3.run(ParentRunner.java:238)\n\tat org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:63)\n\tat org.junit.runners.ParentRunner.runChildren(ParentRunner.java:236)\n\tat org.junit.runners.ParentRunner.access$000(ParentRunner.java:53)\n\tat org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:229)\n\tat org.junit.internal.runners.statements.RunAfters.evaluate(RunAfters.java:27)\n\tat org.junit.runners.ParentRunner.run(ParentRunner.java:309)\n\tat cucumber.api.junit.Cucumber.run(Cucumber.java:98)\n\tat org.eclipse.jdt.internal.junit4.runner.JUnit4TestReference.run(JUnit4TestReference.java:86)\n\tat org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:459)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:678)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:382)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:192)\n",
  "status": "failed"
});
formatter.match({
  "location": "survey.trysurvey()"
});
formatter.result({
  "duration": 0,
  "error_message": "cucumber.runtime.AmbiguousStepDefinitionsException: ✽.When Try to Survey the application for user-controllable inputs(CAPEC_84_Step_1_1.feature:6) matches more than one step definition:\n  Try to Survey in survey.trysurvey()\n  Try to Survey the application in surveytheapplication.trysurveytheapplication()\n  Try to Survey the application for user-controllable inputs in surveytheapplicationforusercontrollableinputs.trysurveytheapplicationforusercontrollableinputs()\n\n\tat cucumber.runtime.RuntimeGlue.stepDefinitionMatch(RuntimeGlue.java:71)\n\tat cucumber.runtime.Runtime.runStep(Runtime.java:265)\n\tat cucumber.runtime.model.StepContainer.runStep(StepContainer.java:44)\n\tat cucumber.runtime.model.StepContainer.runSteps(StepContainer.java:39)\n\tat cucumber.runtime.model.CucumberScenario.run(CucumberScenario.java:48)\n\tat cucumber.runtime.junit.ExecutionUnitRunner.run(ExecutionUnitRunner.java:91)\n\tat cucumber.runtime.junit.FeatureRunner.runChild(FeatureRunner.java:63)\n\tat cucumber.runtime.junit.FeatureRunner.runChild(FeatureRunner.java:18)\n\tat org.junit.runners.ParentRunner$3.run(ParentRunner.java:238)\n\tat org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:63)\n\tat org.junit.runners.ParentRunner.runChildren(ParentRunner.java:236)\n\tat org.junit.runners.ParentRunner.access$000(ParentRunner.java:53)\n\tat org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:229)\n\tat org.junit.runners.ParentRunner.run(ParentRunner.java:309)\n\tat cucumber.runtime.junit.FeatureRunner.run(FeatureRunner.java:70)\n\tat cucumber.api.junit.Cucumber.runChild(Cucumber.java:93)\n\tat cucumber.api.junit.Cucumber.runChild(Cucumber.java:37)\n\tat org.junit.runners.ParentRunner$3.run(ParentRunner.java:238)\n\tat org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:63)\n\tat org.junit.runners.ParentRunner.runChildren(ParentRunner.java:236)\n\tat org.junit.runners.ParentRunner.access$000(ParentRunner.java:53)\n\tat org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:229)\n\tat org.junit.internal.runners.statements.RunAfters.evaluate(RunAfters.java:27)\n\tat org.junit.runners.ParentRunner.run(ParentRunner.java:309)\n\tat cucumber.api.junit.Cucumber.run(Cucumber.java:98)\n\tat org.eclipse.jdt.internal.junit4.runner.JUnit4TestReference.run(JUnit4TestReference.java:86)\n\tat org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:459)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:678)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:382)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:192)\n",
  "status": "failed"
});
formatter.match({
  "location": "survey.asssurvey()"
});
formatter.result({
  "duration": 0,
  "error_message": "cucumber.runtime.AmbiguousStepDefinitionsException: ✽.Then Assert the success of Survey the application for user-controllable inputs(CAPEC_84_Step_1_1.feature:8) matches more than one step definition:\n  Assert the success of Survey in survey.asssurvey()\n  Assert the success of Survey the application in surveytheapplication.asssurveytheapplication()\n  Assert the success of Survey the application for user-controllable inputs in surveytheapplicationforusercontrollableinputs.asssurveytheapplicationforusercontrollableinputs()\n\n\tat cucumber.runtime.RuntimeGlue.stepDefinitionMatch(RuntimeGlue.java:71)\n\tat cucumber.runtime.Runtime.runStep(Runtime.java:265)\n\tat cucumber.runtime.model.StepContainer.runStep(StepContainer.java:44)\n\tat cucumber.runtime.model.StepContainer.runSteps(StepContainer.java:39)\n\tat cucumber.runtime.model.CucumberScenario.run(CucumberScenario.java:48)\n\tat cucumber.runtime.junit.ExecutionUnitRunner.run(ExecutionUnitRunner.java:91)\n\tat cucumber.runtime.junit.FeatureRunner.runChild(FeatureRunner.java:63)\n\tat cucumber.runtime.junit.FeatureRunner.runChild(FeatureRunner.java:18)\n\tat org.junit.runners.ParentRunner$3.run(ParentRunner.java:238)\n\tat org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:63)\n\tat org.junit.runners.ParentRunner.runChildren(ParentRunner.java:236)\n\tat org.junit.runners.ParentRunner.access$000(ParentRunner.java:53)\n\tat org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:229)\n\tat org.junit.runners.ParentRunner.run(ParentRunner.java:309)\n\tat cucumber.runtime.junit.FeatureRunner.run(FeatureRunner.java:70)\n\tat cucumber.api.junit.Cucumber.runChild(Cucumber.java:93)\n\tat cucumber.api.junit.Cucumber.runChild(Cucumber.java:37)\n\tat org.junit.runners.ParentRunner$3.run(ParentRunner.java:238)\n\tat org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:63)\n\tat org.junit.runners.ParentRunner.runChildren(ParentRunner.java:236)\n\tat org.junit.runners.ParentRunner.access$000(ParentRunner.java:53)\n\tat org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:229)\n\tat org.junit.internal.runners.statements.RunAfters.evaluate(RunAfters.java:27)\n\tat org.junit.runners.ParentRunner.run(ParentRunner.java:309)\n\tat cucumber.api.junit.Cucumber.run(Cucumber.java:98)\n\tat org.eclipse.jdt.internal.junit4.runner.JUnit4TestReference.run(JUnit4TestReference.java:86)\n\tat org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:459)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:678)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:382)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:192)\n",
  "status": "failed"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({
  "location": "PatternSteps.assauditinterceptor()"
});
formatter.result({
  "status": "skipped"
});
formatter.match({
  "location": "PatternSteps.asssecurelogger()"
});
formatter.result({
  "status": "skipped"
});
formatter.uri("CAPEC_84_Step_2_1.feature");
formatter.feature({
  "line": 2,
  "name": "CAPEC-84: XQuery Injection",
  "description": "",
  "id": "capec-84:-xquery-injection",
  "keyword": "Feature",
  "tags": [
    {
      "line": 1,
      "name": "@capec84"
    }
  ]
});
formatter.scenario({
  "comments": [
    {
      "line": 3,
      "value": "#2. Experiment"
    }
  ],
  "line": 4,
  "name": "Step2.1 Determine user-controllable input susceptible to injection",
  "description": "",
  "id": "capec-84:-xquery-injection;step2.1-determine-user-controllable-input-susceptible-to-injection",
  "type": "scenario",
  "keyword": "Scenario"
});
formatter.step({
  "line": 5,
  "name": "prepare to Determine user-controllable input susceptible to injection",
  "keyword": "Given "
});
formatter.step({
  "line": 6,
  "name": "Try to Determine user-controllable input susceptible to injection",
  "keyword": "When "
});
formatter.step({
  "comments": [
    {
      "line": 7,
      "value": "# assertion for attack step success"
    }
  ],
  "line": 8,
  "name": "Assert the success of Determine user-controllable input susceptible to injection",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 9,
      "value": "#assertions for security pattern testing (checker whether the pattern consequences are observed)"
    }
  ],
  "line": 10,
  "name": "assert the consequences of the pattern application firewall",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 11,
      "value": "# alternative input guard"
    }
  ],
  "line": 12,
  "name": "assert the consequences of the pattern input guard",
  "keyword": "Then "
});
formatter.match({
  "location": "determineusercontrollableinputsusceptibletoinjection.predetermineusercontrollableinputsusceptibletoinjection()"
});
formatter.result({
  "duration": 1650565,
  "error_message": "net.continuumsecurity.proxy.ProxyException: org.zaproxy.clientapi.core.ClientApiException: java.net.ConnectException: Connection refused\n\tat net.continuumsecurity.proxy.ZAProxyScanner.validateMinimumRequiredZapVersion(ZAProxyScanner.java:96)\n\tat net.continuumsecurity.proxy.ZAProxyScanner.\u003cinit\u003e(ZAProxyScanner.java:38)\n\tat steps.determineusercontrollableinputsusceptibletoinjection.predetermineusercontrollableinputsusceptibletoinjection(determineusercontrollableinputsusceptibletoinjection.java:23)\n\tat ✽.Given prepare to Determine user-controllable input susceptible to injection(CAPEC_84_Step_2_1.feature:5)\nCaused by: org.zaproxy.clientapi.core.ClientApiException: java.net.ConnectException: Connection refused\n\tat org.zaproxy.clientapi.core.ClientApi.callApiDom(ClientApi.java:307)\n\tat org.zaproxy.clientapi.core.ClientApi.callApi(ClientApi.java:289)\n\tat org.zaproxy.clientapi.gen.Core.version(Core.java:158)\n\tat net.continuumsecurity.proxy.ZAProxyScanner.validateMinimumRequiredZapVersion(ZAProxyScanner.java:85)\n\tat net.continuumsecurity.proxy.ZAProxyScanner.\u003cinit\u003e(ZAProxyScanner.java:38)\n\tat steps.determineusercontrollableinputsusceptibletoinjection.predetermineusercontrollableinputsusceptibletoinjection(determineusercontrollableinputsusceptibletoinjection.java:23)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.lang.reflect.Method.invoke(Method.java:498)\n\tat cucumber.runtime.Utils$1.call(Utils.java:37)\n\tat cucumber.runtime.Timeout.timeout(Timeout.java:13)\n\tat cucumber.runtime.Utils.invoke(Utils.java:31)\n\tat cucumber.runtime.java.JavaStepDefinition.execute(JavaStepDefinition.java:37)\n\tat cucumber.runtime.StepDefinitionMatch.runStep(StepDefinitionMatch.java:37)\n\tat cucumber.runtime.Runtime.runStep(Runtime.java:298)\n\tat cucumber.runtime.model.StepContainer.runStep(StepContainer.java:44)\n\tat cucumber.runtime.model.StepContainer.runSteps(StepContainer.java:39)\n\tat cucumber.runtime.model.CucumberScenario.run(CucumberScenario.java:48)\n\tat cucumber.runtime.junit.ExecutionUnitRunner.run(ExecutionUnitRunner.java:91)\n\tat cucumber.runtime.junit.FeatureRunner.runChild(FeatureRunner.java:63)\n\tat cucumber.runtime.junit.FeatureRunner.runChild(FeatureRunner.java:18)\n\tat org.junit.runners.ParentRunner$3.run(ParentRunner.java:238)\n\tat org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:63)\n\tat org.junit.runners.ParentRunner.runChildren(ParentRunner.java:236)\n\tat org.junit.runners.ParentRunner.access$000(ParentRunner.java:53)\n\tat org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:229)\n\tat org.junit.runners.ParentRunner.run(ParentRunner.java:309)\n\tat cucumber.runtime.junit.FeatureRunner.run(FeatureRunner.java:70)\n\tat cucumber.api.junit.Cucumber.runChild(Cucumber.java:93)\n\tat cucumber.api.junit.Cucumber.runChild(Cucumber.java:37)\n\tat org.junit.runners.ParentRunner$3.run(ParentRunner.java:238)\n\tat org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:63)\n\tat org.junit.runners.ParentRunner.runChildren(ParentRunner.java:236)\n\tat org.junit.runners.ParentRunner.access$000(ParentRunner.java:53)\n\tat org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:229)\n\tat org.junit.internal.runners.statements.RunAfters.evaluate(RunAfters.java:27)\n\tat org.junit.runners.ParentRunner.run(ParentRunner.java:309)\n\tat cucumber.api.junit.Cucumber.run(Cucumber.java:98)\n\tat org.eclipse.jdt.internal.junit4.runner.JUnit4TestReference.run(JUnit4TestReference.java:86)\n\tat org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:459)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:678)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:382)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:192)\nCaused by: java.net.ConnectException: Connection refused\n\tat java.net.PlainSocketImpl.socketConnect(Native Method)\n\tat java.net.AbstractPlainSocketImpl.doConnect(AbstractPlainSocketImpl.java:350)\n\tat java.net.AbstractPlainSocketImpl.connectToAddress(AbstractPlainSocketImpl.java:206)\n\tat java.net.AbstractPlainSocketImpl.connect(AbstractPlainSocketImpl.java:188)\n\tat java.net.Socket.connect(Socket.java:589)\n\tat java.net.Socket.connect(Socket.java:538)\n\tat sun.net.NetworkClient.doConnect(NetworkClient.java:180)\n\tat sun.net.www.http.HttpClient.openServer(HttpClient.java:432)\n\tat sun.net.www.http.HttpClient$1.run(HttpClient.java:484)\n\tat sun.net.www.http.HttpClient$1.run(HttpClient.java:482)\n\tat java.security.AccessController.doPrivileged(Native Method)\n\tat sun.net.www.http.HttpClient.privilegedOpenServer(HttpClient.java:481)\n\tat sun.net.www.http.HttpClient.openServer(HttpClient.java:522)\n\tat sun.net.www.http.HttpClient.\u003cinit\u003e(HttpClient.java:211)\n\tat sun.net.www.http.HttpClient.New(HttpClient.java:308)\n\tat sun.net.www.http.HttpClient.New(HttpClient.java:326)\n\tat sun.net.www.protocol.http.HttpURLConnection.getNewHttpClient(HttpURLConnection.java:1169)\n\tat sun.net.www.protocol.http.HttpURLConnection.plainConnect0(HttpURLConnection.java:1148)\n\tat sun.net.www.protocol.http.HttpURLConnection.plainConnect(HttpURLConnection.java:999)\n\tat sun.net.www.protocol.http.HttpURLConnection.connect(HttpURLConnection.java:933)\n\tat org.zaproxy.clientapi.core.ClientApi.getConnectionInputStream(ClientApi.java:313)\n\tat org.zaproxy.clientapi.core.ClientApi.callApiDom(ClientApi.java:305)\n\t... 44 more\n",
  "status": "failed"
});
formatter.match({
  "location": "determineusercontrollableinputsusceptibletoinjection.trydetermineusercontrollableinputsusceptibletoinjection()"
});
formatter.result({
  "status": "skipped"
});
formatter.match({
  "location": "determineusercontrollableinputsusceptibletoinjection.assdetermineusercontrollableinputsusceptibletoinjection()"
});
formatter.result({
  "status": "skipped"
});
formatter.match({
  "location": "PatternSteps.assapplicationfirewall()"
});
formatter.result({
  "status": "skipped"
});
formatter.match({
  "location": "PatternSteps.assinputguard()"
});
formatter.result({
  "status": "skipped"
});
formatter.uri("CAPEC_84_Step_3_1.feature");
formatter.feature({
  "line": 2,
  "name": "CAPEC-84: XQuery Injection",
  "description": "",
  "id": "capec-84:-xquery-injection",
  "keyword": "Feature",
  "tags": [
    {
      "line": 1,
      "name": "@capec84"
    }
  ]
});
formatter.scenario({
  "comments": [
    {
      "line": 3,
      "value": "#3. Exploit"
    }
  ],
  "line": 4,
  "name": "Step3.1 Information Disclosure",
  "description": "",
  "id": "capec-84:-xquery-injection;step3.1-information-disclosure",
  "type": "scenario",
  "keyword": "Scenario"
});
formatter.step({
  "line": 5,
  "name": "prepare to Information Disclosure",
  "keyword": "Given "
});
formatter.step({
  "line": 6,
  "name": "Try to Information Disclosure",
  "keyword": "When "
});
formatter.step({
  "comments": [
    {
      "line": 7,
      "value": "# assertion for attack step success"
    }
  ],
  "line": 8,
  "name": "Assert the success of Information Disclosure",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 9,
      "value": "#assertions for security pattern testing (checker whether the pattern consequences are observed)"
    }
  ],
  "line": 10,
  "name": "assert the consequences of the pattern audit interceptor",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 11,
      "value": "# depends secure logger"
    }
  ],
  "line": 12,
  "name": "assert the consequences of the pattern secure logger",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 13,
      "value": "# benifits audit interceptor"
    }
  ],
  "line": 14,
  "name": "assert the consequences of the pattern application firewall",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 15,
      "value": "# alternative input guard"
    }
  ],
  "line": 16,
  "name": "assert the consequences of the pattern input guard",
  "keyword": "Then "
});
formatter.match({
  "location": "informationdisclosure.preinformationdisclosure()"
});
formatter.result({
  "duration": 71196,
  "status": "passed"
});
formatter.match({
  "location": "informationdisclosure.tryinformationdisclosure()"
});
formatter.result({
  "duration": 5330,
  "status": "passed"
});
formatter.match({
  "location": "informationdisclosure.assinformationdisclosure()"
});
formatter.result({
  "duration": 5077,
  "status": "passed"
});
formatter.match({
  "location": "PatternSteps.assauditinterceptor()"
});
formatter.result({
  "duration": 13388,
  "status": "passed"
});
formatter.match({
  "location": "PatternSteps.asssecurelogger()"
});
formatter.result({
  "duration": 5402,
  "status": "passed"
});
formatter.match({
  "location": "PatternSteps.assapplicationfirewall()"
});
formatter.result({
  "duration": 5205,
  "status": "passed"
});
formatter.match({
  "location": "PatternSteps.assinputguard()"
});
formatter.result({
  "duration": 5374,
  "status": "passed"
});
formatter.uri("CAPEC_84_Step_3_2.feature");
formatter.feature({
  "line": 2,
  "name": "CAPEC-84: XQuery Injection",
  "description": "",
  "id": "capec-84:-xquery-injection",
  "keyword": "Feature",
  "tags": [
    {
      "line": 1,
      "name": "@capec84"
    }
  ]
});
formatter.scenario({
  "comments": [
    {
      "line": 3,
      "value": "#3. Exploit"
    }
  ],
  "line": 4,
  "name": "Step3.2 Manipulate the data in the XML database",
  "description": "",
  "id": "capec-84:-xquery-injection;step3.2-manipulate-the-data-in-the-xml-database",
  "type": "scenario",
  "keyword": "Scenario"
});
formatter.step({
  "line": 5,
  "name": "prepare to Manipulate the data in the XML database",
  "keyword": "Given "
});
formatter.step({
  "line": 6,
  "name": "Try to Manipulate the data in the XML database",
  "keyword": "When "
});
formatter.step({
  "comments": [
    {
      "line": 7,
      "value": "# assertion for attack step success"
    }
  ],
  "line": 8,
  "name": "Assert the success of Manipulate the data in the XML database",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 9,
      "value": "#assertions for security pattern testing (checker whether the pattern consequences are observed)"
    }
  ],
  "line": 10,
  "name": "assert the consequences of the pattern audit interceptor",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 11,
      "value": "# depends secure logger"
    }
  ],
  "line": 12,
  "name": "assert the consequences of the pattern secure logger",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 13,
      "value": "# benifits audit interceptor"
    }
  ],
  "line": 14,
  "name": "assert the consequences of the pattern application firewall",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 15,
      "value": "# alternative input guard"
    }
  ],
  "line": 16,
  "name": "assert the consequences of the pattern input guard",
  "keyword": "Then "
});
formatter.match({
  "location": "manipulatethedatainthexmldatabase.premanipulatethedatainthexmldatabase()"
});
formatter.result({
  "duration": 55304,
  "status": "passed"
});
formatter.match({
  "location": "manipulatethedatainthexmldatabase.trymanipulatethedatainthexmldatabase()"
});
formatter.result({
  "duration": 5017,
  "status": "passed"
});
formatter.match({
  "location": "manipulatethedatainthexmldatabase.assmanipulatethedatainthexmldatabase()"
});
formatter.result({
  "duration": 4494,
  "status": "passed"
});
formatter.match({
  "location": "PatternSteps.assauditinterceptor()"
});
formatter.result({
  "duration": 15706,
  "status": "passed"
});
formatter.match({
  "location": "PatternSteps.asssecurelogger()"
});
formatter.result({
  "duration": 4691,
  "status": "passed"
});
formatter.match({
  "location": "PatternSteps.assapplicationfirewall()"
});
formatter.result({
  "duration": 4349,
  "status": "passed"
});
formatter.match({
  "location": "PatternSteps.assinputguard()"
});
formatter.result({
  "duration": 5940,
  "status": "passed"
});
formatter.uri("CAPEC_86_Step_1_1.feature");
formatter.feature({
  "line": 2,
  "name": "CAPEC-86: Embedding Script (XSS) in HTTP Headers",
  "description": "",
  "id": "capec-86:-embedding-script-(xss)-in-http-headers",
  "keyword": "Feature",
  "tags": [
    {
      "line": 1,
      "name": "@capec86"
    }
  ]
});
formatter.scenario({
  "comments": [
    {
      "line": 3,
      "value": "#1. Explore"
    }
  ],
  "line": 4,
  "name": "Step1.1 Spider",
  "description": "",
  "id": "capec-86:-embedding-script-(xss)-in-http-headers;step1.1-spider",
  "type": "scenario",
  "keyword": "Scenario"
});
formatter.step({
  "line": 5,
  "name": "prepare to Spider",
  "keyword": "Given "
});
formatter.step({
  "line": 6,
  "name": "Try to Spider",
  "keyword": "When "
});
formatter.step({
  "comments": [
    {
      "line": 7,
      "value": "# assertion for attack step success"
    }
  ],
  "line": 8,
  "name": "Assert the success of Spider",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 9,
      "value": "#assertions for security pattern testing (checker whether the pattern consequences are observed)"
    }
  ],
  "line": 10,
  "name": "assert the consequences of the pattern",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 11,
      "value": "#"
    }
  ],
  "line": 12,
  "name": "assert the consequences of the pattern audit interceptor",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 13,
      "value": "# depends secure logger"
    }
  ],
  "line": 14,
  "name": "assert the consequences of the pattern secure logger",
  "keyword": "Then "
});
formatter.match({
  "location": "spider.prespider()"
});
formatter.result({
  "duration": 1406259,
  "error_message": "net.continuumsecurity.proxy.ProxyException: org.zaproxy.clientapi.core.ClientApiException: java.net.ConnectException: Connection refused\n\tat net.continuumsecurity.proxy.ZAProxyScanner.validateMinimumRequiredZapVersion(ZAProxyScanner.java:96)\n\tat net.continuumsecurity.proxy.ZAProxyScanner.\u003cinit\u003e(ZAProxyScanner.java:38)\n\tat steps.spider.prespider(spider.java:17)\n\tat ✽.Given prepare to Spider(CAPEC_86_Step_1_1.feature:5)\nCaused by: org.zaproxy.clientapi.core.ClientApiException: java.net.ConnectException: Connection refused\n\tat org.zaproxy.clientapi.core.ClientApi.callApiDom(ClientApi.java:307)\n\tat org.zaproxy.clientapi.core.ClientApi.callApi(ClientApi.java:289)\n\tat org.zaproxy.clientapi.gen.Core.version(Core.java:158)\n\tat net.continuumsecurity.proxy.ZAProxyScanner.validateMinimumRequiredZapVersion(ZAProxyScanner.java:85)\n\tat net.continuumsecurity.proxy.ZAProxyScanner.\u003cinit\u003e(ZAProxyScanner.java:38)\n\tat steps.spider.prespider(spider.java:17)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.lang.reflect.Method.invoke(Method.java:498)\n\tat cucumber.runtime.Utils$1.call(Utils.java:37)\n\tat cucumber.runtime.Timeout.timeout(Timeout.java:13)\n\tat cucumber.runtime.Utils.invoke(Utils.java:31)\n\tat cucumber.runtime.java.JavaStepDefinition.execute(JavaStepDefinition.java:37)\n\tat cucumber.runtime.StepDefinitionMatch.runStep(StepDefinitionMatch.java:37)\n\tat cucumber.runtime.Runtime.runStep(Runtime.java:298)\n\tat cucumber.runtime.model.StepContainer.runStep(StepContainer.java:44)\n\tat cucumber.runtime.model.StepContainer.runSteps(StepContainer.java:39)\n\tat cucumber.runtime.model.CucumberScenario.run(CucumberScenario.java:48)\n\tat cucumber.runtime.junit.ExecutionUnitRunner.run(ExecutionUnitRunner.java:91)\n\tat cucumber.runtime.junit.FeatureRunner.runChild(FeatureRunner.java:63)\n\tat cucumber.runtime.junit.FeatureRunner.runChild(FeatureRunner.java:18)\n\tat org.junit.runners.ParentRunner$3.run(ParentRunner.java:238)\n\tat org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:63)\n\tat org.junit.runners.ParentRunner.runChildren(ParentRunner.java:236)\n\tat org.junit.runners.ParentRunner.access$000(ParentRunner.java:53)\n\tat org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:229)\n\tat org.junit.runners.ParentRunner.run(ParentRunner.java:309)\n\tat cucumber.runtime.junit.FeatureRunner.run(FeatureRunner.java:70)\n\tat cucumber.api.junit.Cucumber.runChild(Cucumber.java:93)\n\tat cucumber.api.junit.Cucumber.runChild(Cucumber.java:37)\n\tat org.junit.runners.ParentRunner$3.run(ParentRunner.java:238)\n\tat org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:63)\n\tat org.junit.runners.ParentRunner.runChildren(ParentRunner.java:236)\n\tat org.junit.runners.ParentRunner.access$000(ParentRunner.java:53)\n\tat org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:229)\n\tat org.junit.internal.runners.statements.RunAfters.evaluate(RunAfters.java:27)\n\tat org.junit.runners.ParentRunner.run(ParentRunner.java:309)\n\tat cucumber.api.junit.Cucumber.run(Cucumber.java:98)\n\tat org.eclipse.jdt.internal.junit4.runner.JUnit4TestReference.run(JUnit4TestReference.java:86)\n\tat org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:459)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:678)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:382)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:192)\nCaused by: java.net.ConnectException: Connection refused\n\tat java.net.PlainSocketImpl.socketConnect(Native Method)\n\tat java.net.AbstractPlainSocketImpl.doConnect(AbstractPlainSocketImpl.java:350)\n\tat java.net.AbstractPlainSocketImpl.connectToAddress(AbstractPlainSocketImpl.java:206)\n\tat java.net.AbstractPlainSocketImpl.connect(AbstractPlainSocketImpl.java:188)\n\tat java.net.Socket.connect(Socket.java:589)\n\tat java.net.Socket.connect(Socket.java:538)\n\tat sun.net.NetworkClient.doConnect(NetworkClient.java:180)\n\tat sun.net.www.http.HttpClient.openServer(HttpClient.java:432)\n\tat sun.net.www.http.HttpClient$1.run(HttpClient.java:484)\n\tat sun.net.www.http.HttpClient$1.run(HttpClient.java:482)\n\tat java.security.AccessController.doPrivileged(Native Method)\n\tat sun.net.www.http.HttpClient.privilegedOpenServer(HttpClient.java:481)\n\tat sun.net.www.http.HttpClient.openServer(HttpClient.java:522)\n\tat sun.net.www.http.HttpClient.\u003cinit\u003e(HttpClient.java:211)\n\tat sun.net.www.http.HttpClient.New(HttpClient.java:308)\n\tat sun.net.www.http.HttpClient.New(HttpClient.java:326)\n\tat sun.net.www.protocol.http.HttpURLConnection.getNewHttpClient(HttpURLConnection.java:1169)\n\tat sun.net.www.protocol.http.HttpURLConnection.plainConnect0(HttpURLConnection.java:1148)\n\tat sun.net.www.protocol.http.HttpURLConnection.plainConnect(HttpURLConnection.java:999)\n\tat sun.net.www.protocol.http.HttpURLConnection.connect(HttpURLConnection.java:933)\n\tat org.zaproxy.clientapi.core.ClientApi.getConnectionInputStream(ClientApi.java:313)\n\tat org.zaproxy.clientapi.core.ClientApi.callApiDom(ClientApi.java:305)\n\t... 44 more\n",
  "status": "failed"
});
formatter.match({
  "location": "spider.tryspider()"
});
formatter.result({
  "status": "skipped"
});
formatter.match({
  "location": "spider.assspider()"
});
formatter.result({
  "status": "skipped"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({
  "location": "PatternSteps.assauditinterceptor()"
});
formatter.result({
  "status": "skipped"
});
formatter.match({
  "location": "PatternSteps.asssecurelogger()"
});
formatter.result({
  "status": "skipped"
});
formatter.uri("CAPEC_86_Step_2_1.feature");
formatter.feature({
  "line": 2,
  "name": "CAPEC-86: Embedding Script (XSS) in HTTP Headers",
  "description": "",
  "id": "capec-86:-embedding-script-(xss)-in-http-headers",
  "keyword": "Feature",
  "tags": [
    {
      "line": 1,
      "name": "@capec86"
    }
  ]
});
formatter.scenario({
  "comments": [
    {
      "line": 3,
      "value": "#2. Experiment"
    }
  ],
  "line": 4,
  "name": "Step2.1 Probe identified potential entry points for XSS vulnerability",
  "description": "",
  "id": "capec-86:-embedding-script-(xss)-in-http-headers;step2.1-probe-identified-potential-entry-points-for-xss-vulnerability",
  "type": "scenario",
  "keyword": "Scenario"
});
formatter.step({
  "line": 5,
  "name": "prepare to Probe identified potential entry points for XSS vulnerability",
  "keyword": "Given "
});
formatter.step({
  "line": 6,
  "name": "Try to Probe identified potential entry points for XSS vulnerability",
  "keyword": "When "
});
formatter.step({
  "comments": [
    {
      "line": 7,
      "value": "# assertion for attack step success"
    }
  ],
  "line": 8,
  "name": "Assert the success of Probe identified potential entry points for XSS vulnerability",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 9,
      "value": "#assertions for security pattern testing (checker whether the pattern consequences are observed)"
    }
  ],
  "line": 10,
  "name": "assert the consequences of the pattern audit interceptor",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 11,
      "value": "# depends secure logger"
    }
  ],
  "line": 12,
  "name": "assert the consequences of the pattern secure logger",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 13,
      "value": "# benifits audit interceptor"
    }
  ],
  "line": 14,
  "name": "assert the consequences of the pattern application firewall",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 15,
      "value": "# alternative input guard"
    }
  ],
  "line": 16,
  "name": "assert the consequences of the pattern input guard",
  "keyword": "Then "
});
formatter.match({
  "location": "probeidentifiedpotentialentrypointsforxssvulnerability.preprobeidentifiedpotentialentrypointsforxssvulnerability()"
});
formatter.result({
  "duration": 1579551,
  "error_message": "net.continuumsecurity.proxy.ProxyException: org.zaproxy.clientapi.core.ClientApiException: java.net.ConnectException: Connection refused\n\tat net.continuumsecurity.proxy.ZAProxyScanner.validateMinimumRequiredZapVersion(ZAProxyScanner.java:96)\n\tat net.continuumsecurity.proxy.ZAProxyScanner.\u003cinit\u003e(ZAProxyScanner.java:38)\n\tat steps.probeidentifiedpotentialentrypointsforxssvulnerability.preprobeidentifiedpotentialentrypointsforxssvulnerability(probeidentifiedpotentialentrypointsforxssvulnerability.java:15)\n\tat ✽.Given prepare to Probe identified potential entry points for XSS vulnerability(CAPEC_86_Step_2_1.feature:5)\nCaused by: org.zaproxy.clientapi.core.ClientApiException: java.net.ConnectException: Connection refused\n\tat org.zaproxy.clientapi.core.ClientApi.callApiDom(ClientApi.java:307)\n\tat org.zaproxy.clientapi.core.ClientApi.callApi(ClientApi.java:289)\n\tat org.zaproxy.clientapi.gen.Core.version(Core.java:158)\n\tat net.continuumsecurity.proxy.ZAProxyScanner.validateMinimumRequiredZapVersion(ZAProxyScanner.java:85)\n\tat net.continuumsecurity.proxy.ZAProxyScanner.\u003cinit\u003e(ZAProxyScanner.java:38)\n\tat steps.probeidentifiedpotentialentrypointsforxssvulnerability.preprobeidentifiedpotentialentrypointsforxssvulnerability(probeidentifiedpotentialentrypointsforxssvulnerability.java:15)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.lang.reflect.Method.invoke(Method.java:498)\n\tat cucumber.runtime.Utils$1.call(Utils.java:37)\n\tat cucumber.runtime.Timeout.timeout(Timeout.java:13)\n\tat cucumber.runtime.Utils.invoke(Utils.java:31)\n\tat cucumber.runtime.java.JavaStepDefinition.execute(JavaStepDefinition.java:37)\n\tat cucumber.runtime.StepDefinitionMatch.runStep(StepDefinitionMatch.java:37)\n\tat cucumber.runtime.Runtime.runStep(Runtime.java:298)\n\tat cucumber.runtime.model.StepContainer.runStep(StepContainer.java:44)\n\tat cucumber.runtime.model.StepContainer.runSteps(StepContainer.java:39)\n\tat cucumber.runtime.model.CucumberScenario.run(CucumberScenario.java:48)\n\tat cucumber.runtime.junit.ExecutionUnitRunner.run(ExecutionUnitRunner.java:91)\n\tat cucumber.runtime.junit.FeatureRunner.runChild(FeatureRunner.java:63)\n\tat cucumber.runtime.junit.FeatureRunner.runChild(FeatureRunner.java:18)\n\tat org.junit.runners.ParentRunner$3.run(ParentRunner.java:238)\n\tat org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:63)\n\tat org.junit.runners.ParentRunner.runChildren(ParentRunner.java:236)\n\tat org.junit.runners.ParentRunner.access$000(ParentRunner.java:53)\n\tat org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:229)\n\tat org.junit.runners.ParentRunner.run(ParentRunner.java:309)\n\tat cucumber.runtime.junit.FeatureRunner.run(FeatureRunner.java:70)\n\tat cucumber.api.junit.Cucumber.runChild(Cucumber.java:93)\n\tat cucumber.api.junit.Cucumber.runChild(Cucumber.java:37)\n\tat org.junit.runners.ParentRunner$3.run(ParentRunner.java:238)\n\tat org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:63)\n\tat org.junit.runners.ParentRunner.runChildren(ParentRunner.java:236)\n\tat org.junit.runners.ParentRunner.access$000(ParentRunner.java:53)\n\tat org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:229)\n\tat org.junit.internal.runners.statements.RunAfters.evaluate(RunAfters.java:27)\n\tat org.junit.runners.ParentRunner.run(ParentRunner.java:309)\n\tat cucumber.api.junit.Cucumber.run(Cucumber.java:98)\n\tat org.eclipse.jdt.internal.junit4.runner.JUnit4TestReference.run(JUnit4TestReference.java:86)\n\tat org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:459)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:678)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:382)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:192)\nCaused by: java.net.ConnectException: Connection refused\n\tat java.net.PlainSocketImpl.socketConnect(Native Method)\n\tat java.net.AbstractPlainSocketImpl.doConnect(AbstractPlainSocketImpl.java:350)\n\tat java.net.AbstractPlainSocketImpl.connectToAddress(AbstractPlainSocketImpl.java:206)\n\tat java.net.AbstractPlainSocketImpl.connect(AbstractPlainSocketImpl.java:188)\n\tat java.net.Socket.connect(Socket.java:589)\n\tat java.net.Socket.connect(Socket.java:538)\n\tat sun.net.NetworkClient.doConnect(NetworkClient.java:180)\n\tat sun.net.www.http.HttpClient.openServer(HttpClient.java:432)\n\tat sun.net.www.http.HttpClient$1.run(HttpClient.java:484)\n\tat sun.net.www.http.HttpClient$1.run(HttpClient.java:482)\n\tat java.security.AccessController.doPrivileged(Native Method)\n\tat sun.net.www.http.HttpClient.privilegedOpenServer(HttpClient.java:481)\n\tat sun.net.www.http.HttpClient.openServer(HttpClient.java:522)\n\tat sun.net.www.http.HttpClient.\u003cinit\u003e(HttpClient.java:211)\n\tat sun.net.www.http.HttpClient.New(HttpClient.java:308)\n\tat sun.net.www.http.HttpClient.New(HttpClient.java:326)\n\tat sun.net.www.protocol.http.HttpURLConnection.getNewHttpClient(HttpURLConnection.java:1169)\n\tat sun.net.www.protocol.http.HttpURLConnection.plainConnect0(HttpURLConnection.java:1148)\n\tat sun.net.www.protocol.http.HttpURLConnection.plainConnect(HttpURLConnection.java:999)\n\tat sun.net.www.protocol.http.HttpURLConnection.connect(HttpURLConnection.java:933)\n\tat org.zaproxy.clientapi.core.ClientApi.getConnectionInputStream(ClientApi.java:313)\n\tat org.zaproxy.clientapi.core.ClientApi.callApiDom(ClientApi.java:305)\n\t... 44 more\n",
  "status": "failed"
});
formatter.match({
  "location": "probeidentifiedpotentialentrypointsforxssvulnerability.tryprobeidentifiedpotentialentrypointsforxssvulnerability()"
});
formatter.result({
  "status": "skipped"
});
formatter.match({
  "location": "probeidentifiedpotentialentrypointsforxssvulnerability.assprobeidentifiedpotentialentrypointsforxssvulnerability()"
});
formatter.result({
  "status": "skipped"
});
formatter.match({
  "location": "PatternSteps.assauditinterceptor()"
});
formatter.result({
  "status": "skipped"
});
formatter.match({
  "location": "PatternSteps.asssecurelogger()"
});
formatter.result({
  "status": "skipped"
});
formatter.match({
  "location": "PatternSteps.assapplicationfirewall()"
});
formatter.result({
  "status": "skipped"
});
formatter.match({
  "location": "PatternSteps.assinputguard()"
});
formatter.result({
  "status": "skipped"
});
formatter.uri("CAPEC_86_Step_3_1.feature");
formatter.feature({
  "line": 2,
  "name": "CAPEC-86: Embedding Script (XSS) in HTTP Headers",
  "description": "",
  "id": "capec-86:-embedding-script-(xss)-in-http-headers",
  "keyword": "Feature",
  "tags": [
    {
      "line": 1,
      "name": "@capec86"
    }
  ]
});
formatter.scenario({
  "comments": [
    {
      "line": 3,
      "value": "#3. Exploit"
    }
  ],
  "line": 4,
  "name": "Step3.1 Steal session IDs, credentials, page content, etc.",
  "description": "",
  "id": "capec-86:-embedding-script-(xss)-in-http-headers;step3.1-steal-session-ids,-credentials,-page-content,-etc.",
  "type": "scenario",
  "keyword": "Scenario"
});
formatter.step({
  "line": 5,
  "name": "prepare to Steal session IDs, credentials, page content, etc.",
  "keyword": "Given "
});
formatter.step({
  "line": 6,
  "name": "Try to Steal session IDs, credentials, page content, etc.",
  "keyword": "When "
});
formatter.step({
  "comments": [
    {
      "line": 7,
      "value": "# assertion for attack step success"
    }
  ],
  "line": 8,
  "name": "Assert the success of Steal session IDs, credentials, page content, etc.",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 9,
      "value": "#assertions for security pattern testing (checker whether the pattern consequences are observed)"
    }
  ],
  "line": 10,
  "name": "assert the consequences of the pattern audit interceptor",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 11,
      "value": "# depends secure logger"
    }
  ],
  "line": 12,
  "name": "assert the consequences of the pattern secure logger",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 13,
      "value": "# benifits audit interceptor"
    }
  ],
  "line": 14,
  "name": "assert the consequences of the pattern application firewall",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 15,
      "value": "# alternative output guard"
    },
    {
      "line": 16,
      "value": "# alternative input guard"
    }
  ],
  "line": 17,
  "name": "assert the consequences of the pattern input guard",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 18,
      "value": "# alternative application firewall"
    },
    {
      "line": 19,
      "value": "# benifits output guard"
    }
  ],
  "line": 20,
  "name": "assert the consequences of the pattern output guard",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 21,
      "value": "# alternative application firewall"
    },
    {
      "line": 22,
      "value": "# benifits input guard"
    }
  ],
  "line": 23,
  "name": "assert the consequences of the pattern comparator checked fault tolerant system",
  "keyword": "Then "
});
formatter.match({
  "location": "stealsessionidscredentialspagecontentetc.prestealsessionidscredentialspagecontentetc()"
});
formatter.result({
  "duration": 23801,
  "status": "passed"
});
formatter.match({
  "location": "stealsessionidscredentialspagecontentetc.trystealsessionidscredentialspagecontentetc()"
});
formatter.result({
  "duration": 3529,
  "status": "passed"
});
formatter.match({
  "location": "stealsessionidscredentialspagecontentetc.assstealsessionidscredentialspagecontentetc()"
});
formatter.result({
  "duration": 3040,
  "status": "passed"
});
formatter.match({
  "location": "PatternSteps.assauditinterceptor()"
});
formatter.result({
  "duration": 9982,
  "status": "passed"
});
formatter.match({
  "location": "PatternSteps.asssecurelogger()"
});
formatter.result({
  "duration": 3617,
  "status": "passed"
});
formatter.match({
  "location": "PatternSteps.assapplicationfirewall()"
});
formatter.result({
  "duration": 3547,
  "status": "passed"
});
formatter.match({
  "location": "PatternSteps.assinputguard()"
});
formatter.result({
  "duration": 3043,
  "status": "passed"
});
formatter.match({
  "location": "PatternSteps.assoutputguard()"
});
formatter.result({
  "duration": 3196,
  "status": "passed"
});
formatter.match({
  "location": "PatternSteps.asscomparatorcheckedfaulttolerantsystem()"
});
formatter.result({
  "duration": 3131,
  "status": "passed"
});
formatter.uri("CAPEC_86_Step_3_2.feature");
formatter.feature({
  "line": 2,
  "name": "CAPEC-86: Embedding Script (XSS) in HTTP Headers",
  "description": "",
  "id": "capec-86:-embedding-script-(xss)-in-http-headers",
  "keyword": "Feature",
  "tags": [
    {
      "line": 1,
      "name": "@capec86"
    }
  ]
});
formatter.scenario({
  "comments": [
    {
      "line": 3,
      "value": "#3. Exploit"
    }
  ],
  "line": 4,
  "name": "Step3.2 Forceful browsing",
  "description": "",
  "id": "capec-86:-embedding-script-(xss)-in-http-headers;step3.2-forceful-browsing",
  "type": "scenario",
  "keyword": "Scenario"
});
formatter.step({
  "line": 5,
  "name": "prepare to Forceful browsing",
  "keyword": "Given "
});
formatter.step({
  "line": 6,
  "name": "Try to Forceful browsing",
  "keyword": "When "
});
formatter.step({
  "comments": [
    {
      "line": 7,
      "value": "# assertion for attack step success"
    }
  ],
  "line": 8,
  "name": "Assert the success of Forceful browsing",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 9,
      "value": "#assertions for security pattern testing (checker whether the pattern consequences are observed)"
    }
  ],
  "line": 10,
  "name": "assert the consequences of the pattern audit interceptor",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 11,
      "value": "# depends secure logger"
    }
  ],
  "line": 12,
  "name": "assert the consequences of the pattern secure logger",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 13,
      "value": "# benifits audit interceptor"
    }
  ],
  "line": 14,
  "name": "assert the consequences of the pattern application firewall",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 15,
      "value": "# alternative output guard"
    },
    {
      "line": 16,
      "value": "# alternative input guard"
    }
  ],
  "line": 17,
  "name": "assert the consequences of the pattern input guard",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 18,
      "value": "# alternative application firewall"
    },
    {
      "line": 19,
      "value": "# benifits output guard"
    }
  ],
  "line": 20,
  "name": "assert the consequences of the pattern output guard",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 21,
      "value": "# alternative application firewall"
    },
    {
      "line": 22,
      "value": "# benifits input guard"
    }
  ],
  "line": 23,
  "name": "assert the consequences of the pattern comparator checked fault tolerant system",
  "keyword": "Then "
});
formatter.match({
  "location": "forcefulbrowsing.preforcefulbrowsing()"
});
formatter.result({
  "duration": 16329,
  "status": "passed"
});
formatter.match({
  "location": "forcefulbrowsing.tryforcefulbrowsing()"
});
formatter.result({
  "duration": 3365,
  "status": "passed"
});
formatter.match({
  "location": "forcefulbrowsing.assforcefulbrowsing()"
});
formatter.result({
  "duration": 2969,
  "status": "passed"
});
formatter.match({
  "location": "PatternSteps.assauditinterceptor()"
});
formatter.result({
  "duration": 8360,
  "status": "passed"
});
formatter.match({
  "location": "PatternSteps.asssecurelogger()"
});
formatter.result({
  "duration": 3545,
  "status": "passed"
});
formatter.match({
  "location": "PatternSteps.assapplicationfirewall()"
});
formatter.result({
  "duration": 3247,
  "status": "passed"
});
formatter.match({
  "location": "PatternSteps.assinputguard()"
});
formatter.result({
  "duration": 2886,
  "status": "passed"
});
formatter.match({
  "location": "PatternSteps.assoutputguard()"
});
formatter.result({
  "duration": 2958,
  "status": "passed"
});
formatter.match({
  "location": "PatternSteps.asscomparatorcheckedfaulttolerantsystem()"
});
formatter.result({
  "duration": 3199,
  "status": "passed"
});
formatter.uri("CAPEC_86_Step_3_3.feature");
formatter.feature({
  "line": 2,
  "name": "CAPEC-86: Embedding Script (XSS) in HTTP Headers",
  "description": "",
  "id": "capec-86:-embedding-script-(xss)-in-http-headers",
  "keyword": "Feature",
  "tags": [
    {
      "line": 1,
      "name": "@capec86"
    }
  ]
});
formatter.scenario({
  "comments": [
    {
      "line": 3,
      "value": "#3. Exploit"
    }
  ],
  "line": 4,
  "name": "Step3.3 Content spoofing",
  "description": "",
  "id": "capec-86:-embedding-script-(xss)-in-http-headers;step3.3-content-spoofing",
  "type": "scenario",
  "keyword": "Scenario"
});
formatter.step({
  "line": 5,
  "name": "prepare to Content spoofing",
  "keyword": "Given "
});
formatter.step({
  "line": 6,
  "name": "Try to Content spoofing",
  "keyword": "When "
});
formatter.step({
  "comments": [
    {
      "line": 7,
      "value": "# assertion for attack step success"
    }
  ],
  "line": 8,
  "name": "Assert the success of Content spoofing",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 9,
      "value": "#assertions for security pattern testing (checker whether the pattern consequences are observed)"
    }
  ],
  "line": 10,
  "name": "assert the consequences of the pattern audit interceptor",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 11,
      "value": "# depends secure logger"
    }
  ],
  "line": 12,
  "name": "assert the consequences of the pattern secure logger",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 13,
      "value": "# benifits audit interceptor"
    }
  ],
  "line": 14,
  "name": "assert the consequences of the pattern application firewall",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 15,
      "value": "# alternative output guard"
    },
    {
      "line": 16,
      "value": "# alternative input guard"
    }
  ],
  "line": 17,
  "name": "assert the consequences of the pattern input guard",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 18,
      "value": "# alternative application firewall"
    },
    {
      "line": 19,
      "value": "# benifits output guard"
    }
  ],
  "line": 20,
  "name": "assert the consequences of the pattern output guard",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 21,
      "value": "# alternative application firewall"
    },
    {
      "line": 22,
      "value": "# benifits input guard"
    }
  ],
  "line": 23,
  "name": "assert the consequences of the pattern comparator checked fault tolerant system",
  "keyword": "Then "
});
formatter.match({
  "location": "contentspoofing.precontentspoofing()"
});
formatter.result({
  "duration": 40846,
  "status": "passed"
});
formatter.match({
  "location": "contentspoofing.trycontentspoofing()"
});
formatter.result({
  "duration": 5001,
  "status": "passed"
});
formatter.match({
  "location": "contentspoofing.asscontentspoofing()"
});
formatter.result({
  "duration": 6599,
  "status": "passed"
});
formatter.match({
  "location": "PatternSteps.assauditinterceptor()"
});
formatter.result({
  "duration": 16888,
  "status": "passed"
});
formatter.match({
  "location": "PatternSteps.asssecurelogger()"
});
formatter.result({
  "duration": 6414,
  "status": "passed"
});
formatter.match({
  "location": "PatternSteps.assapplicationfirewall()"
});
formatter.result({
  "duration": 4197,
  "status": "passed"
});
formatter.match({
  "location": "PatternSteps.assinputguard()"
});
formatter.result({
  "duration": 4984,
  "status": "passed"
});
formatter.match({
  "location": "PatternSteps.assoutputguard()"
});
formatter.result({
  "duration": 4312,
  "status": "passed"
});
formatter.match({
  "location": "PatternSteps.asscomparatorcheckedfaulttolerantsystem()"
});
formatter.result({
  "duration": 5245,
  "status": "passed"
});
formatter.uri("CAPEC_87_Step_1_1.feature");
formatter.feature({
  "line": 2,
  "name": "CAPEC-87: Forceful Browsing",
  "description": "",
  "id": "capec-87:-forceful-browsing",
  "keyword": "Feature",
  "tags": [
    {
      "line": 1,
      "name": "@capec87"
    }
  ]
});
formatter.scenario({
  "comments": [
    {
      "line": 3,
      "value": "#1. Explore"
    }
  ],
  "line": 4,
  "name": "Step1.1 Spider",
  "description": "",
  "id": "capec-87:-forceful-browsing;step1.1-spider",
  "type": "scenario",
  "keyword": "Scenario"
});
formatter.step({
  "line": 5,
  "name": "prepare to Spider",
  "keyword": "Given "
});
formatter.step({
  "line": 6,
  "name": "Try to Spider",
  "keyword": "When "
});
formatter.step({
  "comments": [
    {
      "line": 7,
      "value": "# assertion for attack step success"
    }
  ],
  "line": 8,
  "name": "Assert the success of Spider",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 9,
      "value": "#assertions for security pattern testing (checker whether the pattern consequences are observed)"
    }
  ],
  "line": 10,
  "name": "assert the consequences of the pattern",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 11,
      "value": "#"
    }
  ],
  "line": 12,
  "name": "assert the consequences of the pattern audit interceptor",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 13,
      "value": "# depends secure logger"
    }
  ],
  "line": 14,
  "name": "assert the consequences of the pattern secure logger",
  "keyword": "Then "
});
formatter.match({
  "location": "spider.prespider()"
});
formatter.result({
  "duration": 1449959,
  "error_message": "net.continuumsecurity.proxy.ProxyException: org.zaproxy.clientapi.core.ClientApiException: java.net.ConnectException: Connection refused\n\tat net.continuumsecurity.proxy.ZAProxyScanner.validateMinimumRequiredZapVersion(ZAProxyScanner.java:96)\n\tat net.continuumsecurity.proxy.ZAProxyScanner.\u003cinit\u003e(ZAProxyScanner.java:38)\n\tat steps.spider.prespider(spider.java:17)\n\tat ✽.Given prepare to Spider(CAPEC_87_Step_1_1.feature:5)\nCaused by: org.zaproxy.clientapi.core.ClientApiException: java.net.ConnectException: Connection refused\n\tat org.zaproxy.clientapi.core.ClientApi.callApiDom(ClientApi.java:307)\n\tat org.zaproxy.clientapi.core.ClientApi.callApi(ClientApi.java:289)\n\tat org.zaproxy.clientapi.gen.Core.version(Core.java:158)\n\tat net.continuumsecurity.proxy.ZAProxyScanner.validateMinimumRequiredZapVersion(ZAProxyScanner.java:85)\n\tat net.continuumsecurity.proxy.ZAProxyScanner.\u003cinit\u003e(ZAProxyScanner.java:38)\n\tat steps.spider.prespider(spider.java:17)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.lang.reflect.Method.invoke(Method.java:498)\n\tat cucumber.runtime.Utils$1.call(Utils.java:37)\n\tat cucumber.runtime.Timeout.timeout(Timeout.java:13)\n\tat cucumber.runtime.Utils.invoke(Utils.java:31)\n\tat cucumber.runtime.java.JavaStepDefinition.execute(JavaStepDefinition.java:37)\n\tat cucumber.runtime.StepDefinitionMatch.runStep(StepDefinitionMatch.java:37)\n\tat cucumber.runtime.Runtime.runStep(Runtime.java:298)\n\tat cucumber.runtime.model.StepContainer.runStep(StepContainer.java:44)\n\tat cucumber.runtime.model.StepContainer.runSteps(StepContainer.java:39)\n\tat cucumber.runtime.model.CucumberScenario.run(CucumberScenario.java:48)\n\tat cucumber.runtime.junit.ExecutionUnitRunner.run(ExecutionUnitRunner.java:91)\n\tat cucumber.runtime.junit.FeatureRunner.runChild(FeatureRunner.java:63)\n\tat cucumber.runtime.junit.FeatureRunner.runChild(FeatureRunner.java:18)\n\tat org.junit.runners.ParentRunner$3.run(ParentRunner.java:238)\n\tat org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:63)\n\tat org.junit.runners.ParentRunner.runChildren(ParentRunner.java:236)\n\tat org.junit.runners.ParentRunner.access$000(ParentRunner.java:53)\n\tat org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:229)\n\tat org.junit.runners.ParentRunner.run(ParentRunner.java:309)\n\tat cucumber.runtime.junit.FeatureRunner.run(FeatureRunner.java:70)\n\tat cucumber.api.junit.Cucumber.runChild(Cucumber.java:93)\n\tat cucumber.api.junit.Cucumber.runChild(Cucumber.java:37)\n\tat org.junit.runners.ParentRunner$3.run(ParentRunner.java:238)\n\tat org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:63)\n\tat org.junit.runners.ParentRunner.runChildren(ParentRunner.java:236)\n\tat org.junit.runners.ParentRunner.access$000(ParentRunner.java:53)\n\tat org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:229)\n\tat org.junit.internal.runners.statements.RunAfters.evaluate(RunAfters.java:27)\n\tat org.junit.runners.ParentRunner.run(ParentRunner.java:309)\n\tat cucumber.api.junit.Cucumber.run(Cucumber.java:98)\n\tat org.eclipse.jdt.internal.junit4.runner.JUnit4TestReference.run(JUnit4TestReference.java:86)\n\tat org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:459)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:678)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:382)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:192)\nCaused by: java.net.ConnectException: Connection refused\n\tat java.net.PlainSocketImpl.socketConnect(Native Method)\n\tat java.net.AbstractPlainSocketImpl.doConnect(AbstractPlainSocketImpl.java:350)\n\tat java.net.AbstractPlainSocketImpl.connectToAddress(AbstractPlainSocketImpl.java:206)\n\tat java.net.AbstractPlainSocketImpl.connect(AbstractPlainSocketImpl.java:188)\n\tat java.net.Socket.connect(Socket.java:589)\n\tat java.net.Socket.connect(Socket.java:538)\n\tat sun.net.NetworkClient.doConnect(NetworkClient.java:180)\n\tat sun.net.www.http.HttpClient.openServer(HttpClient.java:432)\n\tat sun.net.www.http.HttpClient$1.run(HttpClient.java:484)\n\tat sun.net.www.http.HttpClient$1.run(HttpClient.java:482)\n\tat java.security.AccessController.doPrivileged(Native Method)\n\tat sun.net.www.http.HttpClient.privilegedOpenServer(HttpClient.java:481)\n\tat sun.net.www.http.HttpClient.openServer(HttpClient.java:522)\n\tat sun.net.www.http.HttpClient.\u003cinit\u003e(HttpClient.java:211)\n\tat sun.net.www.http.HttpClient.New(HttpClient.java:308)\n\tat sun.net.www.http.HttpClient.New(HttpClient.java:326)\n\tat sun.net.www.protocol.http.HttpURLConnection.getNewHttpClient(HttpURLConnection.java:1169)\n\tat sun.net.www.protocol.http.HttpURLConnection.plainConnect0(HttpURLConnection.java:1148)\n\tat sun.net.www.protocol.http.HttpURLConnection.plainConnect(HttpURLConnection.java:999)\n\tat sun.net.www.protocol.http.HttpURLConnection.connect(HttpURLConnection.java:933)\n\tat org.zaproxy.clientapi.core.ClientApi.getConnectionInputStream(ClientApi.java:313)\n\tat org.zaproxy.clientapi.core.ClientApi.callApiDom(ClientApi.java:305)\n\t... 44 more\n",
  "status": "failed"
});
formatter.match({
  "location": "spider.tryspider()"
});
formatter.result({
  "status": "skipped"
});
formatter.match({
  "location": "spider.assspider()"
});
formatter.result({
  "status": "skipped"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({
  "location": "PatternSteps.assauditinterceptor()"
});
formatter.result({
  "status": "skipped"
});
formatter.match({
  "location": "PatternSteps.asssecurelogger()"
});
formatter.result({
  "status": "skipped"
});
formatter.uri("CAPEC_87_Step_2_1.feature");
formatter.feature({
  "line": 2,
  "name": "CAPEC-87: Forceful Browsing",
  "description": "",
  "id": "capec-87:-forceful-browsing",
  "keyword": "Feature",
  "tags": [
    {
      "line": 1,
      "name": "@capec87"
    }
  ]
});
formatter.scenario({
  "comments": [
    {
      "line": 3,
      "value": "#2. Experiment"
    }
  ],
  "line": 4,
  "name": "Step2.1 Attempt well-known or guessable resource locations",
  "description": "",
  "id": "capec-87:-forceful-browsing;step2.1-attempt-well-known-or-guessable-resource-locations",
  "type": "scenario",
  "keyword": "Scenario"
});
formatter.step({
  "line": 5,
  "name": "prepare to Attempt well-known or guessable resource locations",
  "keyword": "Given "
});
formatter.step({
  "line": 6,
  "name": "Try to Attempt well-known or guessable resource locations",
  "keyword": "When "
});
formatter.step({
  "comments": [
    {
      "line": 7,
      "value": "# assertion for attack step success"
    }
  ],
  "line": 8,
  "name": "Assert the success of Attempt well-known or guessable resource locations",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 9,
      "value": "#assertions for security pattern testing (checker whether the pattern consequences are observed)"
    }
  ],
  "line": 10,
  "name": "assert the consequences of the pattern secure logger",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 11,
      "value": "# benifits audit interceptor"
    }
  ],
  "line": 12,
  "name": "assert the consequences of the pattern",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 13,
      "value": "#"
    }
  ],
  "line": 14,
  "name": "assert the consequences of the pattern audit interceptor",
  "keyword": "Then "
});
formatter.match({
  "location": "attemptwellknownorguessableresourcelocations.preattemptwellknownorguessableresourcelocations()"
});
formatter.result({
  "duration": 50112,
  "status": "passed"
});
formatter.match({
  "location": "attemptwellknownorguessableresourcelocations.tryattemptwellknownorguessableresourcelocations()"
});
formatter.result({
  "duration": 3795,
  "status": "passed"
});
formatter.match({
  "location": "attemptwellknownorguessableresourcelocations.assattemptwellknownorguessableresourcelocations()"
});
formatter.result({
  "duration": 3154,
  "status": "passed"
});
formatter.match({
  "location": "PatternSteps.asssecurelogger()"
});
formatter.result({
  "duration": 9215,
  "status": "passed"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({
  "location": "PatternSteps.assauditinterceptor()"
});
formatter.result({
  "status": "skipped"
});
formatter.uri("CAPEC_87_Step_3_1.feature");
formatter.feature({
  "line": 2,
  "name": "CAPEC-87: Forceful Browsing",
  "description": "",
  "id": "capec-87:-forceful-browsing",
  "keyword": "Feature",
  "tags": [
    {
      "line": 1,
      "name": "@capec87"
    }
  ]
});
formatter.scenario({
  "comments": [
    {
      "line": 3,
      "value": "#3. Exploit"
    }
  ],
  "line": 4,
  "name": "Step3.1 Use unauthorized resources",
  "description": "",
  "id": "capec-87:-forceful-browsing;step3.1-use-unauthorized-resources",
  "type": "scenario",
  "keyword": "Scenario"
});
formatter.step({
  "line": 5,
  "name": "prepare to Use unauthorized resources",
  "keyword": "Given "
});
formatter.step({
  "line": 6,
  "name": "Try to Use unauthorized resources",
  "keyword": "When "
});
formatter.step({
  "comments": [
    {
      "line": 7,
      "value": "# assertion for attack step success"
    }
  ],
  "line": 8,
  "name": "Assert the success of Use unauthorized resources",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 9,
      "value": "#assertions for security pattern testing (checker whether the pattern consequences are observed)"
    }
  ],
  "line": 10,
  "name": "assert the consequences of the pattern secure logger",
  "keyword": "Then "
});
formatter.match({
  "location": "useunauthorizedresources.preuseunauthorizedresources()"
});
formatter.result({
  "duration": 45144,
  "status": "passed"
});
formatter.match({
  "location": "useunauthorizedresources.tryuseunauthorizedresources()"
});
formatter.result({
  "duration": 3705,
  "status": "passed"
});
formatter.match({
  "location": "useunauthorizedresources.assuseunauthorizedresources()"
});
formatter.result({
  "duration": 3752,
  "status": "passed"
});
formatter.match({
  "location": "PatternSteps.asssecurelogger()"
});
formatter.result({
  "duration": 11475,
  "status": "passed"
});
formatter.uri("CAPEC_87_Step_3_2.feature");
formatter.feature({
  "line": 2,
  "name": "CAPEC-87: Forceful Browsing",
  "description": "",
  "id": "capec-87:-forceful-browsing",
  "keyword": "Feature",
  "tags": [
    {
      "line": 1,
      "name": "@capec87"
    }
  ]
});
formatter.scenario({
  "comments": [
    {
      "line": 3,
      "value": "#3. Exploit"
    }
  ],
  "line": 4,
  "name": "Step3.2 View unauthorized data",
  "description": "",
  "id": "capec-87:-forceful-browsing;step3.2-view-unauthorized-data",
  "type": "scenario",
  "keyword": "Scenario"
});
formatter.step({
  "line": 5,
  "name": "prepare to View unauthorized data",
  "keyword": "Given "
});
formatter.step({
  "line": 6,
  "name": "Try to View unauthorized data",
  "keyword": "When "
});
formatter.step({
  "comments": [
    {
      "line": 7,
      "value": "# assertion for attack step success"
    }
  ],
  "line": 8,
  "name": "Assert the success of View unauthorized data",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 9,
      "value": "#assertions for security pattern testing (checker whether the pattern consequences are observed)"
    }
  ],
  "line": 10,
  "name": "assert the consequences of the pattern",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 11,
      "value": "#"
    }
  ],
  "line": 12,
  "name": "assert the consequences of the pattern audit interceptor",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 13,
      "value": "# depends secure logger"
    }
  ],
  "line": 14,
  "name": "assert the consequences of the pattern secure logger",
  "keyword": "Then "
});
formatter.match({
  "location": "viewunauthorizeddata.previewunauthorizeddata()"
});
formatter.result({
  "duration": 35879,
  "status": "passed"
});
formatter.match({
  "location": "viewunauthorizeddata.tryviewunauthorizeddata()"
});
formatter.result({
  "duration": 6134,
  "status": "passed"
});
formatter.match({
  "location": "viewunauthorizeddata.assviewunauthorizeddata()"
});
formatter.result({
  "duration": 4472,
  "status": "passed"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({
  "location": "PatternSteps.assauditinterceptor()"
});
formatter.result({
  "status": "skipped"
});
formatter.match({
  "location": "PatternSteps.asssecurelogger()"
});
formatter.result({
  "status": "skipped"
});
formatter.uri("CAPEC_88_Step_1_1.feature");
formatter.feature({
  "line": 2,
  "name": "CAPEC-88: OS Command Injection",
  "description": "",
  "id": "capec-88:-os-command-injection",
  "keyword": "Feature",
  "tags": [
    {
      "line": 1,
      "name": "@capec88"
    }
  ]
});
formatter.scenario({
  "comments": [
    {
      "line": 3,
      "value": "#1. Explore"
    }
  ],
  "line": 4,
  "name": "Step1.1 Identify inputs for OS commands",
  "description": "",
  "id": "capec-88:-os-command-injection;step1.1-identify-inputs-for-os-commands",
  "type": "scenario",
  "keyword": "Scenario"
});
formatter.step({
  "line": 5,
  "name": "prepare to Identify inputs for OS commands",
  "keyword": "Given "
});
formatter.step({
  "line": 6,
  "name": "Try to Identify inputs for OS commands",
  "keyword": "When "
});
formatter.step({
  "comments": [
    {
      "line": 7,
      "value": "# assertion for attack step success"
    }
  ],
  "line": 8,
  "name": "Assert the success of Identify inputs for OS commands",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 9,
      "value": "#assertions for security pattern testing (checker whether the pattern consequences are observed)"
    }
  ],
  "line": 10,
  "name": "assert the consequences of the pattern",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 11,
      "value": "#"
    }
  ],
  "line": 12,
  "name": "assert the consequences of the pattern secure logger",
  "keyword": "Then "
});
formatter.match({
  "location": "identifyinputsforoscommands.preidentifyinputsforoscommands()"
});
formatter.result({
  "duration": 1306183,
  "error_message": "net.continuumsecurity.proxy.ProxyException: org.zaproxy.clientapi.core.ClientApiException: java.net.ConnectException: Connection refused\n\tat net.continuumsecurity.proxy.ZAProxyScanner.validateMinimumRequiredZapVersion(ZAProxyScanner.java:96)\n\tat net.continuumsecurity.proxy.ZAProxyScanner.\u003cinit\u003e(ZAProxyScanner.java:38)\n\tat steps.identifyinputsforoscommands.preidentifyinputsforoscommands(identifyinputsforoscommands.java:16)\n\tat ✽.Given prepare to Identify inputs for OS commands(CAPEC_88_Step_1_1.feature:5)\nCaused by: org.zaproxy.clientapi.core.ClientApiException: java.net.ConnectException: Connection refused\n\tat org.zaproxy.clientapi.core.ClientApi.callApiDom(ClientApi.java:307)\n\tat org.zaproxy.clientapi.core.ClientApi.callApi(ClientApi.java:289)\n\tat org.zaproxy.clientapi.gen.Core.version(Core.java:158)\n\tat net.continuumsecurity.proxy.ZAProxyScanner.validateMinimumRequiredZapVersion(ZAProxyScanner.java:85)\n\tat net.continuumsecurity.proxy.ZAProxyScanner.\u003cinit\u003e(ZAProxyScanner.java:38)\n\tat steps.identifyinputsforoscommands.preidentifyinputsforoscommands(identifyinputsforoscommands.java:16)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.lang.reflect.Method.invoke(Method.java:498)\n\tat cucumber.runtime.Utils$1.call(Utils.java:37)\n\tat cucumber.runtime.Timeout.timeout(Timeout.java:13)\n\tat cucumber.runtime.Utils.invoke(Utils.java:31)\n\tat cucumber.runtime.java.JavaStepDefinition.execute(JavaStepDefinition.java:37)\n\tat cucumber.runtime.StepDefinitionMatch.runStep(StepDefinitionMatch.java:37)\n\tat cucumber.runtime.Runtime.runStep(Runtime.java:298)\n\tat cucumber.runtime.model.StepContainer.runStep(StepContainer.java:44)\n\tat cucumber.runtime.model.StepContainer.runSteps(StepContainer.java:39)\n\tat cucumber.runtime.model.CucumberScenario.run(CucumberScenario.java:48)\n\tat cucumber.runtime.junit.ExecutionUnitRunner.run(ExecutionUnitRunner.java:91)\n\tat cucumber.runtime.junit.FeatureRunner.runChild(FeatureRunner.java:63)\n\tat cucumber.runtime.junit.FeatureRunner.runChild(FeatureRunner.java:18)\n\tat org.junit.runners.ParentRunner$3.run(ParentRunner.java:238)\n\tat org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:63)\n\tat org.junit.runners.ParentRunner.runChildren(ParentRunner.java:236)\n\tat org.junit.runners.ParentRunner.access$000(ParentRunner.java:53)\n\tat org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:229)\n\tat org.junit.runners.ParentRunner.run(ParentRunner.java:309)\n\tat cucumber.runtime.junit.FeatureRunner.run(FeatureRunner.java:70)\n\tat cucumber.api.junit.Cucumber.runChild(Cucumber.java:93)\n\tat cucumber.api.junit.Cucumber.runChild(Cucumber.java:37)\n\tat org.junit.runners.ParentRunner$3.run(ParentRunner.java:238)\n\tat org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:63)\n\tat org.junit.runners.ParentRunner.runChildren(ParentRunner.java:236)\n\tat org.junit.runners.ParentRunner.access$000(ParentRunner.java:53)\n\tat org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:229)\n\tat org.junit.internal.runners.statements.RunAfters.evaluate(RunAfters.java:27)\n\tat org.junit.runners.ParentRunner.run(ParentRunner.java:309)\n\tat cucumber.api.junit.Cucumber.run(Cucumber.java:98)\n\tat org.eclipse.jdt.internal.junit4.runner.JUnit4TestReference.run(JUnit4TestReference.java:86)\n\tat org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:459)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:678)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:382)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:192)\nCaused by: java.net.ConnectException: Connection refused\n\tat java.net.PlainSocketImpl.socketConnect(Native Method)\n\tat java.net.AbstractPlainSocketImpl.doConnect(AbstractPlainSocketImpl.java:350)\n\tat java.net.AbstractPlainSocketImpl.connectToAddress(AbstractPlainSocketImpl.java:206)\n\tat java.net.AbstractPlainSocketImpl.connect(AbstractPlainSocketImpl.java:188)\n\tat java.net.Socket.connect(Socket.java:589)\n\tat java.net.Socket.connect(Socket.java:538)\n\tat sun.net.NetworkClient.doConnect(NetworkClient.java:180)\n\tat sun.net.www.http.HttpClient.openServer(HttpClient.java:432)\n\tat sun.net.www.http.HttpClient$1.run(HttpClient.java:484)\n\tat sun.net.www.http.HttpClient$1.run(HttpClient.java:482)\n\tat java.security.AccessController.doPrivileged(Native Method)\n\tat sun.net.www.http.HttpClient.privilegedOpenServer(HttpClient.java:481)\n\tat sun.net.www.http.HttpClient.openServer(HttpClient.java:522)\n\tat sun.net.www.http.HttpClient.\u003cinit\u003e(HttpClient.java:211)\n\tat sun.net.www.http.HttpClient.New(HttpClient.java:308)\n\tat sun.net.www.http.HttpClient.New(HttpClient.java:326)\n\tat sun.net.www.protocol.http.HttpURLConnection.getNewHttpClient(HttpURLConnection.java:1169)\n\tat sun.net.www.protocol.http.HttpURLConnection.plainConnect0(HttpURLConnection.java:1148)\n\tat sun.net.www.protocol.http.HttpURLConnection.plainConnect(HttpURLConnection.java:999)\n\tat sun.net.www.protocol.http.HttpURLConnection.connect(HttpURLConnection.java:933)\n\tat org.zaproxy.clientapi.core.ClientApi.getConnectionInputStream(ClientApi.java:313)\n\tat org.zaproxy.clientapi.core.ClientApi.callApiDom(ClientApi.java:305)\n\t... 44 more\n",
  "status": "failed"
});
formatter.match({
  "location": "identifyinputsforoscommands.tryidentifyinputsforoscommands()"
});
formatter.result({
  "status": "skipped"
});
formatter.match({
  "location": "identifyinputsforoscommands.assidentifyinputsforoscommands()"
});
formatter.result({
  "status": "skipped"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({
  "location": "PatternSteps.asssecurelogger()"
});
formatter.result({
  "status": "skipped"
});
formatter.uri("CAPEC_88_Step_1_2.feature");
formatter.feature({
  "line": 2,
  "name": "CAPEC-88: OS Command Injection",
  "description": "",
  "id": "capec-88:-os-command-injection",
  "keyword": "Feature",
  "tags": [
    {
      "line": 1,
      "name": "@capec88"
    }
  ]
});
formatter.scenario({
  "comments": [
    {
      "line": 3,
      "value": "#1. Explore"
    }
  ],
  "line": 4,
  "name": "Step1.2 Survey the Application",
  "description": "",
  "id": "capec-88:-os-command-injection;step1.2-survey-the-application",
  "type": "scenario",
  "keyword": "Scenario"
});
formatter.step({
  "line": 5,
  "name": "prepare to Survey the Application",
  "keyword": "Given "
});
formatter.step({
  "line": 6,
  "name": "Try to Survey the Application",
  "keyword": "When "
});
formatter.step({
  "comments": [
    {
      "line": 7,
      "value": "# assertion for attack step success"
    }
  ],
  "line": 8,
  "name": "Assert the success of Survey the Application",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 9,
      "value": "#assertions for security pattern testing (checker whether the pattern consequences are observed)"
    }
  ],
  "line": 10,
  "name": "assert the consequences of the pattern",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 11,
      "value": "#"
    }
  ],
  "line": 12,
  "name": "assert the consequences of the pattern audit interceptor",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 13,
      "value": "# depends secure logger"
    }
  ],
  "line": 14,
  "name": "assert the consequences of the pattern secure logger",
  "keyword": "Then "
});
formatter.match({
  "location": "survey.presurvey()"
});
formatter.result({
  "duration": 1356650,
  "error_message": "net.continuumsecurity.proxy.ProxyException: org.zaproxy.clientapi.core.ClientApiException: java.net.ConnectException: Connection refused\n\tat net.continuumsecurity.proxy.ZAProxyScanner.validateMinimumRequiredZapVersion(ZAProxyScanner.java:96)\n\tat net.continuumsecurity.proxy.ZAProxyScanner.\u003cinit\u003e(ZAProxyScanner.java:38)\n\tat steps.survey.presurvey(survey.java:17)\n\tat ✽.Given prepare to Survey the Application(CAPEC_88_Step_1_2.feature:5)\nCaused by: org.zaproxy.clientapi.core.ClientApiException: java.net.ConnectException: Connection refused\n\tat org.zaproxy.clientapi.core.ClientApi.callApiDom(ClientApi.java:307)\n\tat org.zaproxy.clientapi.core.ClientApi.callApi(ClientApi.java:289)\n\tat org.zaproxy.clientapi.gen.Core.version(Core.java:158)\n\tat net.continuumsecurity.proxy.ZAProxyScanner.validateMinimumRequiredZapVersion(ZAProxyScanner.java:85)\n\tat net.continuumsecurity.proxy.ZAProxyScanner.\u003cinit\u003e(ZAProxyScanner.java:38)\n\tat steps.survey.presurvey(survey.java:17)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.lang.reflect.Method.invoke(Method.java:498)\n\tat cucumber.runtime.Utils$1.call(Utils.java:37)\n\tat cucumber.runtime.Timeout.timeout(Timeout.java:13)\n\tat cucumber.runtime.Utils.invoke(Utils.java:31)\n\tat cucumber.runtime.java.JavaStepDefinition.execute(JavaStepDefinition.java:37)\n\tat cucumber.runtime.StepDefinitionMatch.runStep(StepDefinitionMatch.java:37)\n\tat cucumber.runtime.Runtime.runStep(Runtime.java:298)\n\tat cucumber.runtime.model.StepContainer.runStep(StepContainer.java:44)\n\tat cucumber.runtime.model.StepContainer.runSteps(StepContainer.java:39)\n\tat cucumber.runtime.model.CucumberScenario.run(CucumberScenario.java:48)\n\tat cucumber.runtime.junit.ExecutionUnitRunner.run(ExecutionUnitRunner.java:91)\n\tat cucumber.runtime.junit.FeatureRunner.runChild(FeatureRunner.java:63)\n\tat cucumber.runtime.junit.FeatureRunner.runChild(FeatureRunner.java:18)\n\tat org.junit.runners.ParentRunner$3.run(ParentRunner.java:238)\n\tat org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:63)\n\tat org.junit.runners.ParentRunner.runChildren(ParentRunner.java:236)\n\tat org.junit.runners.ParentRunner.access$000(ParentRunner.java:53)\n\tat org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:229)\n\tat org.junit.runners.ParentRunner.run(ParentRunner.java:309)\n\tat cucumber.runtime.junit.FeatureRunner.run(FeatureRunner.java:70)\n\tat cucumber.api.junit.Cucumber.runChild(Cucumber.java:93)\n\tat cucumber.api.junit.Cucumber.runChild(Cucumber.java:37)\n\tat org.junit.runners.ParentRunner$3.run(ParentRunner.java:238)\n\tat org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:63)\n\tat org.junit.runners.ParentRunner.runChildren(ParentRunner.java:236)\n\tat org.junit.runners.ParentRunner.access$000(ParentRunner.java:53)\n\tat org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:229)\n\tat org.junit.internal.runners.statements.RunAfters.evaluate(RunAfters.java:27)\n\tat org.junit.runners.ParentRunner.run(ParentRunner.java:309)\n\tat cucumber.api.junit.Cucumber.run(Cucumber.java:98)\n\tat org.eclipse.jdt.internal.junit4.runner.JUnit4TestReference.run(JUnit4TestReference.java:86)\n\tat org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:459)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:678)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:382)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:192)\nCaused by: java.net.ConnectException: Connection refused\n\tat java.net.PlainSocketImpl.socketConnect(Native Method)\n\tat java.net.AbstractPlainSocketImpl.doConnect(AbstractPlainSocketImpl.java:350)\n\tat java.net.AbstractPlainSocketImpl.connectToAddress(AbstractPlainSocketImpl.java:206)\n\tat java.net.AbstractPlainSocketImpl.connect(AbstractPlainSocketImpl.java:188)\n\tat java.net.Socket.connect(Socket.java:589)\n\tat java.net.Socket.connect(Socket.java:538)\n\tat sun.net.NetworkClient.doConnect(NetworkClient.java:180)\n\tat sun.net.www.http.HttpClient.openServer(HttpClient.java:432)\n\tat sun.net.www.http.HttpClient$1.run(HttpClient.java:484)\n\tat sun.net.www.http.HttpClient$1.run(HttpClient.java:482)\n\tat java.security.AccessController.doPrivileged(Native Method)\n\tat sun.net.www.http.HttpClient.privilegedOpenServer(HttpClient.java:481)\n\tat sun.net.www.http.HttpClient.openServer(HttpClient.java:522)\n\tat sun.net.www.http.HttpClient.\u003cinit\u003e(HttpClient.java:211)\n\tat sun.net.www.http.HttpClient.New(HttpClient.java:308)\n\tat sun.net.www.http.HttpClient.New(HttpClient.java:326)\n\tat sun.net.www.protocol.http.HttpURLConnection.getNewHttpClient(HttpURLConnection.java:1169)\n\tat sun.net.www.protocol.http.HttpURLConnection.plainConnect0(HttpURLConnection.java:1148)\n\tat sun.net.www.protocol.http.HttpURLConnection.plainConnect(HttpURLConnection.java:999)\n\tat sun.net.www.protocol.http.HttpURLConnection.connect(HttpURLConnection.java:933)\n\tat org.zaproxy.clientapi.core.ClientApi.getConnectionInputStream(ClientApi.java:313)\n\tat org.zaproxy.clientapi.core.ClientApi.callApiDom(ClientApi.java:305)\n\t... 44 more\n",
  "status": "failed"
});
formatter.match({
  "location": "survey.trysurvey()"
});
formatter.result({
  "status": "skipped"
});
formatter.match({
  "location": "survey.asssurvey()"
});
formatter.result({
  "status": "skipped"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({
  "location": "PatternSteps.assauditinterceptor()"
});
formatter.result({
  "status": "skipped"
});
formatter.match({
  "location": "PatternSteps.asssecurelogger()"
});
formatter.result({
  "status": "skipped"
});
formatter.uri("CAPEC_88_Step_2_1.feature");
formatter.feature({
  "line": 2,
  "name": "CAPEC-88: OS Command Injection",
  "description": "",
  "id": "capec-88:-os-command-injection",
  "keyword": "Feature",
  "tags": [
    {
      "line": 1,
      "name": "@capec88"
    }
  ]
});
formatter.scenario({
  "comments": [
    {
      "line": 3,
      "value": "#2. Experiment"
    }
  ],
  "line": 4,
  "name": "Step2.1 Vary inputs, looking for malicious results.",
  "description": "",
  "id": "capec-88:-os-command-injection;step2.1-vary-inputs,-looking-for-malicious-results.",
  "type": "scenario",
  "keyword": "Scenario"
});
formatter.step({
  "line": 5,
  "name": "prepare to Vary inputs, looking for malicious results.",
  "keyword": "Given "
});
formatter.step({
  "line": 6,
  "name": "Try to Vary inputs, looking for malicious results.",
  "keyword": "When "
});
formatter.step({
  "comments": [
    {
      "line": 7,
      "value": "# assertion for attack step success"
    }
  ],
  "line": 8,
  "name": "Assert the success of Vary inputs, looking for malicious results.",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 9,
      "value": "#assertions for security pattern testing (checker whether the pattern consequences are observed)"
    }
  ],
  "line": 10,
  "name": "assert the consequences of the pattern",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 11,
      "value": "#"
    }
  ],
  "line": 12,
  "name": "assert the consequences of the pattern audit interceptor",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 13,
      "value": "# depends secure logger"
    }
  ],
  "line": 14,
  "name": "assert the consequences of the pattern secure logger",
  "keyword": "Then "
});
formatter.match({
  "location": "varyinputslookingformaliciousresults.prevaryinputslookingformaliciousresults()"
});
formatter.result({
  "duration": 1440720,
  "error_message": "net.continuumsecurity.proxy.ProxyException: org.zaproxy.clientapi.core.ClientApiException: java.net.ConnectException: Connection refused\n\tat net.continuumsecurity.proxy.ZAProxyScanner.validateMinimumRequiredZapVersion(ZAProxyScanner.java:96)\n\tat net.continuumsecurity.proxy.ZAProxyScanner.\u003cinit\u003e(ZAProxyScanner.java:38)\n\tat steps.varyinputslookingformaliciousresults.prevaryinputslookingformaliciousresults(varyinputslookingformaliciousresults.java:15)\n\tat ✽.Given prepare to Vary inputs, looking for malicious results.(CAPEC_88_Step_2_1.feature:5)\nCaused by: org.zaproxy.clientapi.core.ClientApiException: java.net.ConnectException: Connection refused\n\tat org.zaproxy.clientapi.core.ClientApi.callApiDom(ClientApi.java:307)\n\tat org.zaproxy.clientapi.core.ClientApi.callApi(ClientApi.java:289)\n\tat org.zaproxy.clientapi.gen.Core.version(Core.java:158)\n\tat net.continuumsecurity.proxy.ZAProxyScanner.validateMinimumRequiredZapVersion(ZAProxyScanner.java:85)\n\tat net.continuumsecurity.proxy.ZAProxyScanner.\u003cinit\u003e(ZAProxyScanner.java:38)\n\tat steps.varyinputslookingformaliciousresults.prevaryinputslookingformaliciousresults(varyinputslookingformaliciousresults.java:15)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.lang.reflect.Method.invoke(Method.java:498)\n\tat cucumber.runtime.Utils$1.call(Utils.java:37)\n\tat cucumber.runtime.Timeout.timeout(Timeout.java:13)\n\tat cucumber.runtime.Utils.invoke(Utils.java:31)\n\tat cucumber.runtime.java.JavaStepDefinition.execute(JavaStepDefinition.java:37)\n\tat cucumber.runtime.StepDefinitionMatch.runStep(StepDefinitionMatch.java:37)\n\tat cucumber.runtime.Runtime.runStep(Runtime.java:298)\n\tat cucumber.runtime.model.StepContainer.runStep(StepContainer.java:44)\n\tat cucumber.runtime.model.StepContainer.runSteps(StepContainer.java:39)\n\tat cucumber.runtime.model.CucumberScenario.run(CucumberScenario.java:48)\n\tat cucumber.runtime.junit.ExecutionUnitRunner.run(ExecutionUnitRunner.java:91)\n\tat cucumber.runtime.junit.FeatureRunner.runChild(FeatureRunner.java:63)\n\tat cucumber.runtime.junit.FeatureRunner.runChild(FeatureRunner.java:18)\n\tat org.junit.runners.ParentRunner$3.run(ParentRunner.java:238)\n\tat org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:63)\n\tat org.junit.runners.ParentRunner.runChildren(ParentRunner.java:236)\n\tat org.junit.runners.ParentRunner.access$000(ParentRunner.java:53)\n\tat org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:229)\n\tat org.junit.runners.ParentRunner.run(ParentRunner.java:309)\n\tat cucumber.runtime.junit.FeatureRunner.run(FeatureRunner.java:70)\n\tat cucumber.api.junit.Cucumber.runChild(Cucumber.java:93)\n\tat cucumber.api.junit.Cucumber.runChild(Cucumber.java:37)\n\tat org.junit.runners.ParentRunner$3.run(ParentRunner.java:238)\n\tat org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:63)\n\tat org.junit.runners.ParentRunner.runChildren(ParentRunner.java:236)\n\tat org.junit.runners.ParentRunner.access$000(ParentRunner.java:53)\n\tat org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:229)\n\tat org.junit.internal.runners.statements.RunAfters.evaluate(RunAfters.java:27)\n\tat org.junit.runners.ParentRunner.run(ParentRunner.java:309)\n\tat cucumber.api.junit.Cucumber.run(Cucumber.java:98)\n\tat org.eclipse.jdt.internal.junit4.runner.JUnit4TestReference.run(JUnit4TestReference.java:86)\n\tat org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:459)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:678)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:382)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:192)\nCaused by: java.net.ConnectException: Connection refused\n\tat java.net.PlainSocketImpl.socketConnect(Native Method)\n\tat java.net.AbstractPlainSocketImpl.doConnect(AbstractPlainSocketImpl.java:350)\n\tat java.net.AbstractPlainSocketImpl.connectToAddress(AbstractPlainSocketImpl.java:206)\n\tat java.net.AbstractPlainSocketImpl.connect(AbstractPlainSocketImpl.java:188)\n\tat java.net.Socket.connect(Socket.java:589)\n\tat java.net.Socket.connect(Socket.java:538)\n\tat sun.net.NetworkClient.doConnect(NetworkClient.java:180)\n\tat sun.net.www.http.HttpClient.openServer(HttpClient.java:432)\n\tat sun.net.www.http.HttpClient$1.run(HttpClient.java:484)\n\tat sun.net.www.http.HttpClient$1.run(HttpClient.java:482)\n\tat java.security.AccessController.doPrivileged(Native Method)\n\tat sun.net.www.http.HttpClient.privilegedOpenServer(HttpClient.java:481)\n\tat sun.net.www.http.HttpClient.openServer(HttpClient.java:522)\n\tat sun.net.www.http.HttpClient.\u003cinit\u003e(HttpClient.java:211)\n\tat sun.net.www.http.HttpClient.New(HttpClient.java:308)\n\tat sun.net.www.http.HttpClient.New(HttpClient.java:326)\n\tat sun.net.www.protocol.http.HttpURLConnection.getNewHttpClient(HttpURLConnection.java:1169)\n\tat sun.net.www.protocol.http.HttpURLConnection.plainConnect0(HttpURLConnection.java:1148)\n\tat sun.net.www.protocol.http.HttpURLConnection.plainConnect(HttpURLConnection.java:999)\n\tat sun.net.www.protocol.http.HttpURLConnection.connect(HttpURLConnection.java:933)\n\tat org.zaproxy.clientapi.core.ClientApi.getConnectionInputStream(ClientApi.java:313)\n\tat org.zaproxy.clientapi.core.ClientApi.callApiDom(ClientApi.java:305)\n\t... 44 more\n",
  "status": "failed"
});
formatter.match({
  "location": "varyinputslookingformaliciousresults.tryvaryinputslookingformaliciousresults()"
});
formatter.result({
  "status": "skipped"
});
formatter.match({
  "location": "varyinputslookingformaliciousresults.assvaryinputslookingformaliciousresults()"
});
formatter.result({
  "status": "skipped"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({
  "location": "PatternSteps.assauditinterceptor()"
});
formatter.result({
  "status": "skipped"
});
formatter.match({
  "location": "PatternSteps.asssecurelogger()"
});
formatter.result({
  "status": "skipped"
});
formatter.uri("CAPEC_88_Step_3_1.feature");
formatter.feature({
  "line": 2,
  "name": "CAPEC-88: OS Command Injection",
  "description": "",
  "id": "capec-88:-os-command-injection",
  "keyword": "Feature",
  "tags": [
    {
      "line": 1,
      "name": "@capec88"
    }
  ]
});
formatter.scenario({
  "comments": [
    {
      "line": 3,
      "value": "#3. Exploit"
    }
  ],
  "line": 4,
  "name": "Step3.1 Execute malicious commands",
  "description": "",
  "id": "capec-88:-os-command-injection;step3.1-execute-malicious-commands",
  "type": "scenario",
  "keyword": "Scenario"
});
formatter.step({
  "line": 5,
  "name": "prepare to Execute malicious commands",
  "keyword": "Given "
});
formatter.step({
  "line": 6,
  "name": "Try to Execute malicious commands",
  "keyword": "When "
});
formatter.step({
  "comments": [
    {
      "line": 7,
      "value": "# assertion for attack step success"
    }
  ],
  "line": 8,
  "name": "Assert the success of Execute malicious commands",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 9,
      "value": "#assertions for security pattern testing (checker whether the pattern consequences are observed)"
    }
  ],
  "line": 10,
  "name": "assert the consequences of the pattern secure logger",
  "keyword": "Then "
});
formatter.match({
  "location": "executemaliciouscommands.preexecutemaliciouscommands()"
});
formatter.result({
  "duration": 44207,
  "status": "passed"
});
formatter.match({
  "location": "executemaliciouscommands.tryexecutemaliciouscommands()"
});
formatter.result({
  "duration": 3745,
  "status": "passed"
});
formatter.match({
  "location": "executemaliciouscommands.assexecutemaliciouscommands()"
});
formatter.result({
  "duration": 3313,
  "status": "passed"
});
formatter.match({
  "location": "PatternSteps.asssecurelogger()"
});
formatter.result({
  "duration": 10558,
  "status": "passed"
});
formatter.uri("CAPEC_89_Step_1_1.feature");
formatter.feature({
  "line": 2,
  "name": "CAPEC-89: Pharming",
  "description": "",
  "id": "capec-89:-pharming",
  "keyword": "Feature",
  "tags": [
    {
      "line": 1,
      "name": "@capec89"
    }
  ]
});
formatter.scenario({
  "comments": [
    {
      "line": 3,
      "value": "#1. Exploit"
    }
  ],
  "line": 4,
  "name": "Step1.1",
  "description": "",
  "id": "capec-89:-pharming;step1.1",
  "type": "scenario",
  "keyword": "Scenario"
});
formatter.step({
  "line": 5,
  "name": "prepare to",
  "keyword": "Given "
});
formatter.step({
  "line": 6,
  "name": "Try to",
  "keyword": "When "
});
formatter.step({
  "comments": [
    {
      "line": 7,
      "value": "# assertion for attack step success"
    }
  ],
  "line": 8,
  "name": "Assert the success of",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 9,
      "value": "#assertions for security pattern testing (checker whether the pattern consequences are observed)"
    }
  ],
  "line": 10,
  "name": "assert the consequences of the pattern",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 11,
      "value": "#"
    }
  ],
  "line": 12,
  "name": "assert the consequences of the pattern audit interceptor",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 13,
      "value": "# depends secure logger"
    }
  ],
  "line": 14,
  "name": "assert the consequences of the pattern secure logger",
  "keyword": "Then "
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({
  "location": "PatternSteps.assauditinterceptor()"
});
formatter.result({
  "status": "skipped"
});
formatter.match({
  "location": "PatternSteps.asssecurelogger()"
});
formatter.result({
  "status": "skipped"
});
formatter.uri("CAPEC_8_Step_1_1.feature");
formatter.feature({
  "line": 2,
  "name": "CAPEC-8: Buffer Overflow in an API Call",
  "description": "",
  "id": "capec-8:-buffer-overflow-in-an-api-call",
  "keyword": "Feature",
  "tags": [
    {
      "line": 1,
      "name": "@capec8"
    }
  ]
});
formatter.scenario({
  "comments": [
    {
      "line": 3,
      "value": "#1. Experiment"
    }
  ],
  "line": 4,
  "name": "Step1.1",
  "description": "",
  "id": "capec-8:-buffer-overflow-in-an-api-call;step1.1",
  "type": "scenario",
  "keyword": "Scenario"
});
formatter.step({
  "line": 5,
  "name": "prepare to",
  "keyword": "Given "
});
formatter.step({
  "line": 6,
  "name": "Try to",
  "keyword": "When "
});
formatter.step({
  "comments": [
    {
      "line": 7,
      "value": "# assertion for attack step success"
    }
  ],
  "line": 8,
  "name": "Assert the success of",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 9,
      "value": "#assertions for security pattern testing (checker whether the pattern consequences are observed)"
    }
  ],
  "line": 10,
  "name": "assert the consequences of the pattern",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 11,
      "value": "#"
    }
  ],
  "line": 12,
  "name": "assert the consequences of the pattern audit interceptor",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 13,
      "value": "# depends secure logger"
    }
  ],
  "line": 14,
  "name": "assert the consequences of the pattern secure logger",
  "keyword": "Then "
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({
  "location": "PatternSteps.assauditinterceptor()"
});
formatter.result({
  "status": "skipped"
});
formatter.match({
  "location": "PatternSteps.asssecurelogger()"
});
formatter.result({
  "status": "skipped"
});
formatter.uri("CAPEC_8_Step_2_1.feature");
formatter.feature({
  "line": 2,
  "name": "CAPEC-8: Buffer Overflow in an API Call",
  "description": "",
  "id": "capec-8:-buffer-overflow-in-an-api-call",
  "keyword": "Feature",
  "tags": [
    {
      "line": 1,
      "name": "@capec8"
    }
  ]
});
formatter.scenario({
  "comments": [
    {
      "line": 3,
      "value": "#2. Exploit"
    }
  ],
  "line": 4,
  "name": "Step2.1",
  "description": "",
  "id": "capec-8:-buffer-overflow-in-an-api-call;step2.1",
  "type": "scenario",
  "keyword": "Scenario"
});
formatter.step({
  "line": 5,
  "name": "prepare to",
  "keyword": "Given "
});
formatter.step({
  "line": 6,
  "name": "Try to",
  "keyword": "When "
});
formatter.step({
  "comments": [
    {
      "line": 7,
      "value": "# assertion for attack step success"
    }
  ],
  "line": 8,
  "name": "Assert the success of",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 9,
      "value": "#assertions for security pattern testing (checker whether the pattern consequences are observed)"
    }
  ],
  "line": 10,
  "name": "assert the consequences of the pattern",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 11,
      "value": "#"
    }
  ],
  "line": 12,
  "name": "assert the consequences of the pattern audit interceptor",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 13,
      "value": "# depends secure logger"
    }
  ],
  "line": 14,
  "name": "assert the consequences of the pattern secure logger",
  "keyword": "Then "
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({
  "location": "PatternSteps.assauditinterceptor()"
});
formatter.result({
  "status": "skipped"
});
formatter.match({
  "location": "PatternSteps.asssecurelogger()"
});
formatter.result({
  "status": "skipped"
});
formatter.uri("CAPEC_90_Step_1_1.feature");
formatter.feature({
  "line": 2,
  "name": "CAPEC-90: Reflection Attack in Authentication Protocol",
  "description": "",
  "id": "capec-90:-reflection-attack-in-authentication-protocol",
  "keyword": "Feature",
  "tags": [
    {
      "line": 1,
      "name": "@capec90"
    }
  ]
});
formatter.scenario({
  "comments": [
    {
      "line": 3,
      "value": "#1. Experiment"
    }
  ],
  "line": 4,
  "name": "Step1.1",
  "description": "",
  "id": "capec-90:-reflection-attack-in-authentication-protocol;step1.1",
  "type": "scenario",
  "keyword": "Scenario"
});
formatter.step({
  "line": 5,
  "name": "prepare to",
  "keyword": "Given "
});
formatter.step({
  "line": 6,
  "name": "Try to",
  "keyword": "When "
});
formatter.step({
  "comments": [
    {
      "line": 7,
      "value": "# assertion for attack step success"
    }
  ],
  "line": 8,
  "name": "Assert the success of",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 9,
      "value": "#assertions for security pattern testing (checker whether the pattern consequences are observed)"
    }
  ],
  "line": 10,
  "name": "assert the consequences of the pattern",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 11,
      "value": "#"
    }
  ],
  "line": 12,
  "name": "assert the consequences of the pattern audit interceptor",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 13,
      "value": "# depends secure logger"
    }
  ],
  "line": 14,
  "name": "assert the consequences of the pattern secure logger",
  "keyword": "Then "
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({
  "location": "PatternSteps.assauditinterceptor()"
});
formatter.result({
  "status": "skipped"
});
formatter.match({
  "location": "PatternSteps.asssecurelogger()"
});
formatter.result({
  "status": "skipped"
});
formatter.uri("CAPEC_91_Step_1_1.feature");
formatter.feature({
  "line": 2,
  "name": "CAPEC-91: XSS in IMG Tags",
  "description": "",
  "id": "capec-91:-xss-in-img-tags",
  "keyword": "Feature",
  "tags": [
    {
      "line": 1,
      "name": "@capec91"
    }
  ]
});
formatter.scenario({
  "comments": [
    {
      "line": 3,
      "value": "#1. Explore"
    }
  ],
  "line": 4,
  "name": "Step1.1 Spider",
  "description": "",
  "id": "capec-91:-xss-in-img-tags;step1.1-spider",
  "type": "scenario",
  "keyword": "Scenario"
});
formatter.step({
  "line": 5,
  "name": "prepare to Spider",
  "keyword": "Given "
});
formatter.step({
  "line": 6,
  "name": "Try to Spider",
  "keyword": "When "
});
formatter.step({
  "comments": [
    {
      "line": 7,
      "value": "# assertion for attack step success"
    }
  ],
  "line": 8,
  "name": "Assert the success of Spider",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 9,
      "value": "#assertions for security pattern testing (checker whether the pattern consequences are observed)"
    }
  ],
  "line": 10,
  "name": "assert the consequences of the pattern secure logger",
  "keyword": "Then "
});
formatter.step({
  "line": 11,
  "name": "assert the consequences of the pattern application firewall",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 12,
      "value": "# alternative output guard"
    },
    {
      "line": 13,
      "value": "# alternative input guard"
    }
  ],
  "line": 14,
  "name": "assert the consequences of the pattern input guard",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 15,
      "value": "# alternative application firewall"
    },
    {
      "line": 16,
      "value": "# benifits output guard"
    }
  ],
  "line": 17,
  "name": "assert the consequences of the pattern pathname canonicalization",
  "keyword": "Then "
});
formatter.step({
  "line": 18,
  "name": "assert the consequences of the pattern output guard",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 19,
      "value": "# alternative application firewall"
    },
    {
      "line": 20,
      "value": "# benifits input guard"
    }
  ],
  "line": 21,
  "name": "assert the consequences of the pattern comparator checked fault tolerant system",
  "keyword": "Then "
});
formatter.match({
  "location": "spider.prespider()"
});
formatter.result({
  "duration": 1353034,
  "error_message": "net.continuumsecurity.proxy.ProxyException: org.zaproxy.clientapi.core.ClientApiException: java.net.ConnectException: Connection refused\n\tat net.continuumsecurity.proxy.ZAProxyScanner.validateMinimumRequiredZapVersion(ZAProxyScanner.java:96)\n\tat net.continuumsecurity.proxy.ZAProxyScanner.\u003cinit\u003e(ZAProxyScanner.java:38)\n\tat steps.spider.prespider(spider.java:17)\n\tat ✽.Given prepare to Spider(CAPEC_91_Step_1_1.feature:5)\nCaused by: org.zaproxy.clientapi.core.ClientApiException: java.net.ConnectException: Connection refused\n\tat org.zaproxy.clientapi.core.ClientApi.callApiDom(ClientApi.java:307)\n\tat org.zaproxy.clientapi.core.ClientApi.callApi(ClientApi.java:289)\n\tat org.zaproxy.clientapi.gen.Core.version(Core.java:158)\n\tat net.continuumsecurity.proxy.ZAProxyScanner.validateMinimumRequiredZapVersion(ZAProxyScanner.java:85)\n\tat net.continuumsecurity.proxy.ZAProxyScanner.\u003cinit\u003e(ZAProxyScanner.java:38)\n\tat steps.spider.prespider(spider.java:17)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.lang.reflect.Method.invoke(Method.java:498)\n\tat cucumber.runtime.Utils$1.call(Utils.java:37)\n\tat cucumber.runtime.Timeout.timeout(Timeout.java:13)\n\tat cucumber.runtime.Utils.invoke(Utils.java:31)\n\tat cucumber.runtime.java.JavaStepDefinition.execute(JavaStepDefinition.java:37)\n\tat cucumber.runtime.StepDefinitionMatch.runStep(StepDefinitionMatch.java:37)\n\tat cucumber.runtime.Runtime.runStep(Runtime.java:298)\n\tat cucumber.runtime.model.StepContainer.runStep(StepContainer.java:44)\n\tat cucumber.runtime.model.StepContainer.runSteps(StepContainer.java:39)\n\tat cucumber.runtime.model.CucumberScenario.run(CucumberScenario.java:48)\n\tat cucumber.runtime.junit.ExecutionUnitRunner.run(ExecutionUnitRunner.java:91)\n\tat cucumber.runtime.junit.FeatureRunner.runChild(FeatureRunner.java:63)\n\tat cucumber.runtime.junit.FeatureRunner.runChild(FeatureRunner.java:18)\n\tat org.junit.runners.ParentRunner$3.run(ParentRunner.java:238)\n\tat org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:63)\n\tat org.junit.runners.ParentRunner.runChildren(ParentRunner.java:236)\n\tat org.junit.runners.ParentRunner.access$000(ParentRunner.java:53)\n\tat org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:229)\n\tat org.junit.runners.ParentRunner.run(ParentRunner.java:309)\n\tat cucumber.runtime.junit.FeatureRunner.run(FeatureRunner.java:70)\n\tat cucumber.api.junit.Cucumber.runChild(Cucumber.java:93)\n\tat cucumber.api.junit.Cucumber.runChild(Cucumber.java:37)\n\tat org.junit.runners.ParentRunner$3.run(ParentRunner.java:238)\n\tat org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:63)\n\tat org.junit.runners.ParentRunner.runChildren(ParentRunner.java:236)\n\tat org.junit.runners.ParentRunner.access$000(ParentRunner.java:53)\n\tat org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:229)\n\tat org.junit.internal.runners.statements.RunAfters.evaluate(RunAfters.java:27)\n\tat org.junit.runners.ParentRunner.run(ParentRunner.java:309)\n\tat cucumber.api.junit.Cucumber.run(Cucumber.java:98)\n\tat org.eclipse.jdt.internal.junit4.runner.JUnit4TestReference.run(JUnit4TestReference.java:86)\n\tat org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:459)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:678)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:382)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:192)\nCaused by: java.net.ConnectException: Connection refused\n\tat java.net.PlainSocketImpl.socketConnect(Native Method)\n\tat java.net.AbstractPlainSocketImpl.doConnect(AbstractPlainSocketImpl.java:350)\n\tat java.net.AbstractPlainSocketImpl.connectToAddress(AbstractPlainSocketImpl.java:206)\n\tat java.net.AbstractPlainSocketImpl.connect(AbstractPlainSocketImpl.java:188)\n\tat java.net.Socket.connect(Socket.java:589)\n\tat java.net.Socket.connect(Socket.java:538)\n\tat sun.net.NetworkClient.doConnect(NetworkClient.java:180)\n\tat sun.net.www.http.HttpClient.openServer(HttpClient.java:432)\n\tat sun.net.www.http.HttpClient$1.run(HttpClient.java:484)\n\tat sun.net.www.http.HttpClient$1.run(HttpClient.java:482)\n\tat java.security.AccessController.doPrivileged(Native Method)\n\tat sun.net.www.http.HttpClient.privilegedOpenServer(HttpClient.java:481)\n\tat sun.net.www.http.HttpClient.openServer(HttpClient.java:522)\n\tat sun.net.www.http.HttpClient.\u003cinit\u003e(HttpClient.java:211)\n\tat sun.net.www.http.HttpClient.New(HttpClient.java:308)\n\tat sun.net.www.http.HttpClient.New(HttpClient.java:326)\n\tat sun.net.www.protocol.http.HttpURLConnection.getNewHttpClient(HttpURLConnection.java:1169)\n\tat sun.net.www.protocol.http.HttpURLConnection.plainConnect0(HttpURLConnection.java:1148)\n\tat sun.net.www.protocol.http.HttpURLConnection.plainConnect(HttpURLConnection.java:999)\n\tat sun.net.www.protocol.http.HttpURLConnection.connect(HttpURLConnection.java:933)\n\tat org.zaproxy.clientapi.core.ClientApi.getConnectionInputStream(ClientApi.java:313)\n\tat org.zaproxy.clientapi.core.ClientApi.callApiDom(ClientApi.java:305)\n\t... 44 more\n",
  "status": "failed"
});
formatter.match({
  "location": "spider.tryspider()"
});
formatter.result({
  "status": "skipped"
});
formatter.match({
  "location": "spider.assspider()"
});
formatter.result({
  "status": "skipped"
});
formatter.match({
  "location": "PatternSteps.asssecurelogger()"
});
formatter.result({
  "status": "skipped"
});
formatter.match({
  "location": "PatternSteps.assapplicationfirewall()"
});
formatter.result({
  "status": "skipped"
});
formatter.match({
  "location": "PatternSteps.assinputguard()"
});
formatter.result({
  "status": "skipped"
});
formatter.match({
  "location": "PatternSteps.asspathnamecanonicalization()"
});
formatter.result({
  "status": "skipped"
});
formatter.match({
  "location": "PatternSteps.assoutputguard()"
});
formatter.result({
  "status": "skipped"
});
formatter.match({
  "location": "PatternSteps.asscomparatorcheckedfaulttolerantsystem()"
});
formatter.result({
  "status": "skipped"
});
formatter.uri("CAPEC_91_Step_2_1.feature");
formatter.feature({
  "line": 2,
  "name": "CAPEC-91: XSS in IMG Tags",
  "description": "",
  "id": "capec-91:-xss-in-img-tags",
  "keyword": "Feature",
  "tags": [
    {
      "line": 1,
      "name": "@capec91"
    }
  ]
});
formatter.scenario({
  "comments": [
    {
      "line": 3,
      "value": "#2. Experiment"
    }
  ],
  "line": 4,
  "name": "Step2.1 Probe identified potential entry points for XSS vulnerability",
  "description": "",
  "id": "capec-91:-xss-in-img-tags;step2.1-probe-identified-potential-entry-points-for-xss-vulnerability",
  "type": "scenario",
  "keyword": "Scenario"
});
formatter.step({
  "line": 5,
  "name": "prepare to Probe identified potential entry points for XSS vulnerability",
  "keyword": "Given "
});
formatter.step({
  "line": 6,
  "name": "Try to Probe identified potential entry points for XSS vulnerability",
  "keyword": "When "
});
formatter.step({
  "comments": [
    {
      "line": 7,
      "value": "# assertion for attack step success"
    }
  ],
  "line": 8,
  "name": "Assert the success of Probe identified potential entry points for XSS vulnerability",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 9,
      "value": "#assertions for security pattern testing (checker whether the pattern consequences are observed)"
    }
  ],
  "line": 10,
  "name": "assert the consequences of the pattern secure logger",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 11,
      "value": "# benifits audit interceptor"
    }
  ],
  "line": 12,
  "name": "assert the consequences of the pattern application firewall",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 13,
      "value": "# alternative output guard"
    },
    {
      "line": 14,
      "value": "# alternative input guard"
    }
  ],
  "line": 15,
  "name": "assert the consequences of the pattern input guard",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 16,
      "value": "# alternative application firewall"
    },
    {
      "line": 17,
      "value": "# benifits output guard"
    }
  ],
  "line": 18,
  "name": "assert the consequences of the pattern output guard",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 19,
      "value": "# alternative application firewall"
    },
    {
      "line": 20,
      "value": "# benifits input guard"
    }
  ],
  "line": 21,
  "name": "assert the consequences of the pattern comparator checked fault tolerant system",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 22,
      "value": "# alternative output guard"
    },
    {
      "line": 23,
      "value": "# impairs audit interceptor"
    }
  ],
  "line": 24,
  "name": "assert the consequences of the pattern audit interceptor",
  "keyword": "Then "
});
formatter.match({
  "location": "probeidentifiedpotentialentrypointsforxssvulnerability.preprobeidentifiedpotentialentrypointsforxssvulnerability()"
});
formatter.result({
  "duration": 2129180,
  "error_message": "net.continuumsecurity.proxy.ProxyException: org.zaproxy.clientapi.core.ClientApiException: java.net.ConnectException: Connection refused\n\tat net.continuumsecurity.proxy.ZAProxyScanner.validateMinimumRequiredZapVersion(ZAProxyScanner.java:96)\n\tat net.continuumsecurity.proxy.ZAProxyScanner.\u003cinit\u003e(ZAProxyScanner.java:38)\n\tat steps.probeidentifiedpotentialentrypointsforxssvulnerability.preprobeidentifiedpotentialentrypointsforxssvulnerability(probeidentifiedpotentialentrypointsforxssvulnerability.java:15)\n\tat ✽.Given prepare to Probe identified potential entry points for XSS vulnerability(CAPEC_91_Step_2_1.feature:5)\nCaused by: org.zaproxy.clientapi.core.ClientApiException: java.net.ConnectException: Connection refused\n\tat org.zaproxy.clientapi.core.ClientApi.callApiDom(ClientApi.java:307)\n\tat org.zaproxy.clientapi.core.ClientApi.callApi(ClientApi.java:289)\n\tat org.zaproxy.clientapi.gen.Core.version(Core.java:158)\n\tat net.continuumsecurity.proxy.ZAProxyScanner.validateMinimumRequiredZapVersion(ZAProxyScanner.java:85)\n\tat net.continuumsecurity.proxy.ZAProxyScanner.\u003cinit\u003e(ZAProxyScanner.java:38)\n\tat steps.probeidentifiedpotentialentrypointsforxssvulnerability.preprobeidentifiedpotentialentrypointsforxssvulnerability(probeidentifiedpotentialentrypointsforxssvulnerability.java:15)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.lang.reflect.Method.invoke(Method.java:498)\n\tat cucumber.runtime.Utils$1.call(Utils.java:37)\n\tat cucumber.runtime.Timeout.timeout(Timeout.java:13)\n\tat cucumber.runtime.Utils.invoke(Utils.java:31)\n\tat cucumber.runtime.java.JavaStepDefinition.execute(JavaStepDefinition.java:37)\n\tat cucumber.runtime.StepDefinitionMatch.runStep(StepDefinitionMatch.java:37)\n\tat cucumber.runtime.Runtime.runStep(Runtime.java:298)\n\tat cucumber.runtime.model.StepContainer.runStep(StepContainer.java:44)\n\tat cucumber.runtime.model.StepContainer.runSteps(StepContainer.java:39)\n\tat cucumber.runtime.model.CucumberScenario.run(CucumberScenario.java:48)\n\tat cucumber.runtime.junit.ExecutionUnitRunner.run(ExecutionUnitRunner.java:91)\n\tat cucumber.runtime.junit.FeatureRunner.runChild(FeatureRunner.java:63)\n\tat cucumber.runtime.junit.FeatureRunner.runChild(FeatureRunner.java:18)\n\tat org.junit.runners.ParentRunner$3.run(ParentRunner.java:238)\n\tat org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:63)\n\tat org.junit.runners.ParentRunner.runChildren(ParentRunner.java:236)\n\tat org.junit.runners.ParentRunner.access$000(ParentRunner.java:53)\n\tat org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:229)\n\tat org.junit.runners.ParentRunner.run(ParentRunner.java:309)\n\tat cucumber.runtime.junit.FeatureRunner.run(FeatureRunner.java:70)\n\tat cucumber.api.junit.Cucumber.runChild(Cucumber.java:93)\n\tat cucumber.api.junit.Cucumber.runChild(Cucumber.java:37)\n\tat org.junit.runners.ParentRunner$3.run(ParentRunner.java:238)\n\tat org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:63)\n\tat org.junit.runners.ParentRunner.runChildren(ParentRunner.java:236)\n\tat org.junit.runners.ParentRunner.access$000(ParentRunner.java:53)\n\tat org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:229)\n\tat org.junit.internal.runners.statements.RunAfters.evaluate(RunAfters.java:27)\n\tat org.junit.runners.ParentRunner.run(ParentRunner.java:309)\n\tat cucumber.api.junit.Cucumber.run(Cucumber.java:98)\n\tat org.eclipse.jdt.internal.junit4.runner.JUnit4TestReference.run(JUnit4TestReference.java:86)\n\tat org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:459)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:678)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:382)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:192)\nCaused by: java.net.ConnectException: Connection refused\n\tat java.net.PlainSocketImpl.socketConnect(Native Method)\n\tat java.net.AbstractPlainSocketImpl.doConnect(AbstractPlainSocketImpl.java:350)\n\tat java.net.AbstractPlainSocketImpl.connectToAddress(AbstractPlainSocketImpl.java:206)\n\tat java.net.AbstractPlainSocketImpl.connect(AbstractPlainSocketImpl.java:188)\n\tat java.net.Socket.connect(Socket.java:589)\n\tat java.net.Socket.connect(Socket.java:538)\n\tat sun.net.NetworkClient.doConnect(NetworkClient.java:180)\n\tat sun.net.www.http.HttpClient.openServer(HttpClient.java:432)\n\tat sun.net.www.http.HttpClient$1.run(HttpClient.java:484)\n\tat sun.net.www.http.HttpClient$1.run(HttpClient.java:482)\n\tat java.security.AccessController.doPrivileged(Native Method)\n\tat sun.net.www.http.HttpClient.privilegedOpenServer(HttpClient.java:481)\n\tat sun.net.www.http.HttpClient.openServer(HttpClient.java:522)\n\tat sun.net.www.http.HttpClient.\u003cinit\u003e(HttpClient.java:211)\n\tat sun.net.www.http.HttpClient.New(HttpClient.java:308)\n\tat sun.net.www.http.HttpClient.New(HttpClient.java:326)\n\tat sun.net.www.protocol.http.HttpURLConnection.getNewHttpClient(HttpURLConnection.java:1169)\n\tat sun.net.www.protocol.http.HttpURLConnection.plainConnect0(HttpURLConnection.java:1148)\n\tat sun.net.www.protocol.http.HttpURLConnection.plainConnect(HttpURLConnection.java:999)\n\tat sun.net.www.protocol.http.HttpURLConnection.connect(HttpURLConnection.java:933)\n\tat org.zaproxy.clientapi.core.ClientApi.getConnectionInputStream(ClientApi.java:313)\n\tat org.zaproxy.clientapi.core.ClientApi.callApiDom(ClientApi.java:305)\n\t... 44 more\n",
  "status": "failed"
});
formatter.match({
  "location": "probeidentifiedpotentialentrypointsforxssvulnerability.tryprobeidentifiedpotentialentrypointsforxssvulnerability()"
});
formatter.result({
  "status": "skipped"
});
formatter.match({
  "location": "probeidentifiedpotentialentrypointsforxssvulnerability.assprobeidentifiedpotentialentrypointsforxssvulnerability()"
});
formatter.result({
  "status": "skipped"
});
formatter.match({
  "location": "PatternSteps.asssecurelogger()"
});
formatter.result({
  "status": "skipped"
});
formatter.match({
  "location": "PatternSteps.assapplicationfirewall()"
});
formatter.result({
  "status": "skipped"
});
formatter.match({
  "location": "PatternSteps.assinputguard()"
});
formatter.result({
  "status": "skipped"
});
formatter.match({
  "location": "PatternSteps.assoutputguard()"
});
formatter.result({
  "status": "skipped"
});
formatter.match({
  "location": "PatternSteps.asscomparatorcheckedfaulttolerantsystem()"
});
formatter.result({
  "status": "skipped"
});
formatter.match({
  "location": "PatternSteps.assauditinterceptor()"
});
formatter.result({
  "status": "skipped"
});
formatter.uri("CAPEC_91_Step_3_1.feature");
formatter.feature({
  "line": 2,
  "name": "CAPEC-91: XSS in IMG Tags",
  "description": "",
  "id": "capec-91:-xss-in-img-tags",
  "keyword": "Feature",
  "tags": [
    {
      "line": 1,
      "name": "@capec91"
    }
  ]
});
formatter.scenario({
  "comments": [
    {
      "line": 3,
      "value": "#3. Exploit"
    }
  ],
  "line": 4,
  "name": "Step3.1 Steal session IDs, credentials, page content, etc.",
  "description": "",
  "id": "capec-91:-xss-in-img-tags;step3.1-steal-session-ids,-credentials,-page-content,-etc.",
  "type": "scenario",
  "keyword": "Scenario"
});
formatter.step({
  "line": 5,
  "name": "prepare to Steal session IDs, credentials, page content, etc.",
  "keyword": "Given "
});
formatter.step({
  "line": 6,
  "name": "Try to Steal session IDs, credentials, page content, etc.",
  "keyword": "When "
});
formatter.step({
  "comments": [
    {
      "line": 7,
      "value": "# assertion for attack step success"
    }
  ],
  "line": 8,
  "name": "Assert the success of Steal session IDs, credentials, page content, etc.",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 9,
      "value": "#assertions for security pattern testing (checker whether the pattern consequences are observed)"
    }
  ],
  "line": 10,
  "name": "assert the consequences of the pattern audit interceptor",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 11,
      "value": "# depends secure logger"
    }
  ],
  "line": 12,
  "name": "assert the consequences of the pattern secure logger",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 13,
      "value": "# benifits audit interceptor"
    }
  ],
  "line": 14,
  "name": "assert the consequences of the pattern application firewall",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 15,
      "value": "# alternative output guard"
    },
    {
      "line": 16,
      "value": "# alternative input guard"
    }
  ],
  "line": 17,
  "name": "assert the consequences of the pattern input guard",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 18,
      "value": "# alternative application firewall"
    },
    {
      "line": 19,
      "value": "# benifits output guard"
    }
  ],
  "line": 20,
  "name": "assert the consequences of the pattern output guard",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 21,
      "value": "# alternative application firewall"
    },
    {
      "line": 22,
      "value": "# benifits input guard"
    }
  ],
  "line": 23,
  "name": "assert the consequences of the pattern comparator checked fault tolerant system",
  "keyword": "Then "
});
formatter.match({
  "location": "stealsessionidscredentialspagecontentetc.prestealsessionidscredentialspagecontentetc()"
});
formatter.result({
  "duration": 27963,
  "status": "passed"
});
formatter.match({
  "location": "stealsessionidscredentialspagecontentetc.trystealsessionidscredentialspagecontentetc()"
});
formatter.result({
  "duration": 5970,
  "status": "passed"
});
formatter.match({
  "location": "stealsessionidscredentialspagecontentetc.assstealsessionidscredentialspagecontentetc()"
});
formatter.result({
  "duration": 3678,
  "status": "passed"
});
formatter.match({
  "location": "PatternSteps.assauditinterceptor()"
});
formatter.result({
  "duration": 17680,
  "status": "passed"
});
formatter.match({
  "location": "PatternSteps.asssecurelogger()"
});
formatter.result({
  "duration": 4052,
  "status": "passed"
});
formatter.match({
  "location": "PatternSteps.assapplicationfirewall()"
});
formatter.result({
  "duration": 3780,
  "status": "passed"
});
formatter.match({
  "location": "PatternSteps.assinputguard()"
});
formatter.result({
  "duration": 3676,
  "status": "passed"
});
formatter.match({
  "location": "PatternSteps.assoutputguard()"
});
formatter.result({
  "duration": 3631,
  "status": "passed"
});
formatter.match({
  "location": "PatternSteps.asscomparatorcheckedfaulttolerantsystem()"
});
formatter.result({
  "duration": 3340,
  "status": "passed"
});
formatter.uri("CAPEC_91_Step_3_2.feature");
formatter.feature({
  "line": 2,
  "name": "CAPEC-91: XSS in IMG Tags",
  "description": "",
  "id": "capec-91:-xss-in-img-tags",
  "keyword": "Feature",
  "tags": [
    {
      "line": 1,
      "name": "@capec91"
    }
  ]
});
formatter.scenario({
  "comments": [
    {
      "line": 3,
      "value": "#3. Exploit"
    }
  ],
  "line": 4,
  "name": "Step3.2 Forceful browsing",
  "description": "",
  "id": "capec-91:-xss-in-img-tags;step3.2-forceful-browsing",
  "type": "scenario",
  "keyword": "Scenario"
});
formatter.step({
  "line": 5,
  "name": "prepare to Forceful browsing",
  "keyword": "Given "
});
formatter.step({
  "line": 6,
  "name": "Try to Forceful browsing",
  "keyword": "When "
});
formatter.step({
  "comments": [
    {
      "line": 7,
      "value": "# assertion for attack step success"
    }
  ],
  "line": 8,
  "name": "Assert the success of Forceful browsing",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 9,
      "value": "#assertions for security pattern testing (checker whether the pattern consequences are observed)"
    }
  ],
  "line": 10,
  "name": "assert the consequences of the pattern audit interceptor",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 11,
      "value": "# depends secure logger"
    }
  ],
  "line": 12,
  "name": "assert the consequences of the pattern secure logger",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 13,
      "value": "# benifits audit interceptor"
    }
  ],
  "line": 14,
  "name": "assert the consequences of the pattern application firewall",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 15,
      "value": "# alternative output guard"
    },
    {
      "line": 16,
      "value": "# alternative input guard"
    }
  ],
  "line": 17,
  "name": "assert the consequences of the pattern input guard",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 18,
      "value": "# alternative application firewall"
    },
    {
      "line": 19,
      "value": "# benifits output guard"
    }
  ],
  "line": 20,
  "name": "assert the consequences of the pattern output guard",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 21,
      "value": "# alternative application firewall"
    },
    {
      "line": 22,
      "value": "# benifits input guard"
    }
  ],
  "line": 23,
  "name": "assert the consequences of the pattern comparator checked fault tolerant system",
  "keyword": "Then "
});
formatter.match({
  "location": "forcefulbrowsing.preforcefulbrowsing()"
});
formatter.result({
  "duration": 26219,
  "status": "passed"
});
formatter.match({
  "location": "forcefulbrowsing.tryforcefulbrowsing()"
});
formatter.result({
  "duration": 3899,
  "status": "passed"
});
formatter.match({
  "location": "forcefulbrowsing.assforcefulbrowsing()"
});
formatter.result({
  "duration": 3465,
  "status": "passed"
});
formatter.match({
  "location": "PatternSteps.assauditinterceptor()"
});
formatter.result({
  "duration": 16460,
  "status": "passed"
});
formatter.match({
  "location": "PatternSteps.asssecurelogger()"
});
formatter.result({
  "duration": 4081,
  "status": "passed"
});
formatter.match({
  "location": "PatternSteps.assapplicationfirewall()"
});
formatter.result({
  "duration": 3727,
  "status": "passed"
});
formatter.match({
  "location": "PatternSteps.assinputguard()"
});
formatter.result({
  "duration": 3099,
  "status": "passed"
});
formatter.match({
  "location": "PatternSteps.assoutputguard()"
});
formatter.result({
  "duration": 3104,
  "status": "passed"
});
formatter.match({
  "location": "PatternSteps.asscomparatorcheckedfaulttolerantsystem()"
});
formatter.result({
  "duration": 3078,
  "status": "passed"
});
formatter.uri("CAPEC_91_Step_3_3.feature");
formatter.feature({
  "line": 2,
  "name": "CAPEC-91: XSS in IMG Tags",
  "description": "",
  "id": "capec-91:-xss-in-img-tags",
  "keyword": "Feature",
  "tags": [
    {
      "line": 1,
      "name": "@capec91"
    }
  ]
});
formatter.scenario({
  "comments": [
    {
      "line": 3,
      "value": "#3. Exploit"
    }
  ],
  "line": 4,
  "name": "Step3.3 Content spoofing",
  "description": "",
  "id": "capec-91:-xss-in-img-tags;step3.3-content-spoofing",
  "type": "scenario",
  "keyword": "Scenario"
});
formatter.step({
  "line": 5,
  "name": "prepare to Content spoofing",
  "keyword": "Given "
});
formatter.step({
  "line": 6,
  "name": "Try to Content spoofing",
  "keyword": "When "
});
formatter.step({
  "comments": [
    {
      "line": 7,
      "value": "# assertion for attack step success"
    }
  ],
  "line": 8,
  "name": "Assert the success of Content spoofing",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 9,
      "value": "#assertions for security pattern testing (checker whether the pattern consequences are observed)"
    }
  ],
  "line": 10,
  "name": "assert the consequences of the pattern audit interceptor",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 11,
      "value": "# depends secure logger"
    }
  ],
  "line": 12,
  "name": "assert the consequences of the pattern secure logger",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 13,
      "value": "# benifits audit interceptor"
    }
  ],
  "line": 14,
  "name": "assert the consequences of the pattern application firewall",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 15,
      "value": "# alternative output guard"
    },
    {
      "line": 16,
      "value": "# alternative input guard"
    }
  ],
  "line": 17,
  "name": "assert the consequences of the pattern input guard",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 18,
      "value": "# alternative application firewall"
    },
    {
      "line": 19,
      "value": "# benifits output guard"
    }
  ],
  "line": 20,
  "name": "assert the consequences of the pattern output guard",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 21,
      "value": "# alternative application firewall"
    },
    {
      "line": 22,
      "value": "# benifits input guard"
    }
  ],
  "line": 23,
  "name": "assert the consequences of the pattern comparator checked fault tolerant system",
  "keyword": "Then "
});
formatter.match({
  "location": "contentspoofing.precontentspoofing()"
});
formatter.result({
  "duration": 22298,
  "status": "passed"
});
formatter.match({
  "location": "contentspoofing.trycontentspoofing()"
});
formatter.result({
  "duration": 3455,
  "status": "passed"
});
formatter.match({
  "location": "contentspoofing.asscontentspoofing()"
});
formatter.result({
  "duration": 2858,
  "status": "passed"
});
formatter.match({
  "location": "PatternSteps.assauditinterceptor()"
});
formatter.result({
  "duration": 9732,
  "status": "passed"
});
formatter.match({
  "location": "PatternSteps.asssecurelogger()"
});
formatter.result({
  "duration": 3697,
  "status": "passed"
});
formatter.match({
  "location": "PatternSteps.assapplicationfirewall()"
});
formatter.result({
  "duration": 3274,
  "status": "passed"
});
formatter.match({
  "location": "PatternSteps.assinputguard()"
});
formatter.result({
  "duration": 3005,
  "status": "passed"
});
formatter.match({
  "location": "PatternSteps.assoutputguard()"
});
formatter.result({
  "duration": 3202,
  "status": "passed"
});
formatter.match({
  "location": "PatternSteps.asscomparatorcheckedfaulttolerantsystem()"
});
formatter.result({
  "duration": 2968,
  "status": "passed"
});
formatter.uri("CAPEC_92_Step_1_1.feature");
formatter.feature({
  "line": 2,
  "name": "CAPEC-92: Forced Integer Overflow",
  "description": "",
  "id": "capec-92:-forced-integer-overflow",
  "keyword": "Feature",
  "tags": [
    {
      "line": 1,
      "name": "@capec92"
    }
  ]
});
formatter.scenario({
  "comments": [
    {
      "line": 3,
      "value": "#1. Explore"
    }
  ],
  "line": 4,
  "name": "Step1.1",
  "description": "",
  "id": "capec-92:-forced-integer-overflow;step1.1",
  "type": "scenario",
  "keyword": "Scenario"
});
formatter.step({
  "line": 5,
  "name": "prepare to",
  "keyword": "Given "
});
formatter.step({
  "line": 6,
  "name": "Try to",
  "keyword": "When "
});
formatter.step({
  "comments": [
    {
      "line": 7,
      "value": "# assertion for attack step success"
    }
  ],
  "line": 8,
  "name": "Assert the success of",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 9,
      "value": "#assertions for security pattern testing (checker whether the pattern consequences are observed)"
    }
  ],
  "line": 10,
  "name": "assert the consequences of the pattern",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 11,
      "value": "#"
    }
  ],
  "line": 12,
  "name": "assert the consequences of the pattern audit interceptor",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 13,
      "value": "# depends secure logger"
    }
  ],
  "line": 14,
  "name": "assert the consequences of the pattern secure logger",
  "keyword": "Then "
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({
  "location": "PatternSteps.assauditinterceptor()"
});
formatter.result({
  "status": "skipped"
});
formatter.match({
  "location": "PatternSteps.asssecurelogger()"
});
formatter.result({
  "status": "skipped"
});
formatter.uri("CAPEC_92_Step_2_1.feature");
formatter.feature({
  "line": 2,
  "name": "CAPEC-92: Forced Integer Overflow",
  "description": "",
  "id": "capec-92:-forced-integer-overflow",
  "keyword": "Feature",
  "tags": [
    {
      "line": 1,
      "name": "@capec92"
    }
  ]
});
formatter.scenario({
  "comments": [
    {
      "line": 3,
      "value": "#2. Experiment"
    }
  ],
  "line": 4,
  "name": "Step2.1",
  "description": "",
  "id": "capec-92:-forced-integer-overflow;step2.1",
  "type": "scenario",
  "keyword": "Scenario"
});
formatter.step({
  "line": 5,
  "name": "prepare to",
  "keyword": "Given "
});
formatter.step({
  "line": 6,
  "name": "Try to",
  "keyword": "When "
});
formatter.step({
  "comments": [
    {
      "line": 7,
      "value": "# assertion for attack step success"
    }
  ],
  "line": 8,
  "name": "Assert the success of",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 9,
      "value": "#assertions for security pattern testing (checker whether the pattern consequences are observed)"
    }
  ],
  "line": 10,
  "name": "assert the consequences of the pattern",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 11,
      "value": "#"
    }
  ],
  "line": 12,
  "name": "assert the consequences of the pattern audit interceptor",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 13,
      "value": "# depends secure logger"
    }
  ],
  "line": 14,
  "name": "assert the consequences of the pattern secure logger",
  "keyword": "Then "
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({
  "location": "PatternSteps.assauditinterceptor()"
});
formatter.result({
  "status": "skipped"
});
formatter.match({
  "location": "PatternSteps.asssecurelogger()"
});
formatter.result({
  "status": "skipped"
});
formatter.uri("CAPEC_92_Step_3_1.feature");
formatter.feature({
  "line": 2,
  "name": "CAPEC-92: Forced Integer Overflow",
  "description": "",
  "id": "capec-92:-forced-integer-overflow",
  "keyword": "Feature",
  "tags": [
    {
      "line": 1,
      "name": "@capec92"
    }
  ]
});
formatter.scenario({
  "comments": [
    {
      "line": 3,
      "value": "#3. Exploit"
    }
  ],
  "line": 4,
  "name": "Step3.1",
  "description": "",
  "id": "capec-92:-forced-integer-overflow;step3.1",
  "type": "scenario",
  "keyword": "Scenario"
});
formatter.step({
  "line": 5,
  "name": "prepare to",
  "keyword": "Given "
});
formatter.step({
  "line": 6,
  "name": "Try to",
  "keyword": "When "
});
formatter.step({
  "comments": [
    {
      "line": 7,
      "value": "# assertion for attack step success"
    }
  ],
  "line": 8,
  "name": "Assert the success of",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 9,
      "value": "#assertions for security pattern testing (checker whether the pattern consequences are observed)"
    }
  ],
  "line": 10,
  "name": "assert the consequences of the pattern",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 11,
      "value": "#"
    }
  ],
  "line": 12,
  "name": "assert the consequences of the pattern audit interceptor",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 13,
      "value": "# depends secure logger"
    }
  ],
  "line": 14,
  "name": "assert the consequences of the pattern secure logger",
  "keyword": "Then "
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({
  "location": "PatternSteps.assauditinterceptor()"
});
formatter.result({
  "status": "skipped"
});
formatter.match({
  "location": "PatternSteps.asssecurelogger()"
});
formatter.result({
  "status": "skipped"
});
formatter.uri("CAPEC_93_Step_1_1.feature");
formatter.feature({
  "line": 2,
  "name": "CAPEC-93: Log Injection-Tampering-Forging",
  "description": "",
  "id": "capec-93:-log-injection-tampering-forging",
  "keyword": "Feature",
  "tags": [
    {
      "line": 1,
      "name": "@capec93"
    }
  ]
});
formatter.scenario({
  "comments": [
    {
      "line": 3,
      "value": "#1. Explore"
    }
  ],
  "line": 4,
  "name": "Step1.1 Determine Application\u0027s Log File Format",
  "description": "",
  "id": "capec-93:-log-injection-tampering-forging;step1.1-determine-application\u0027s-log-file-format",
  "type": "scenario",
  "keyword": "Scenario"
});
formatter.step({
  "line": 5,
  "name": "prepare to Determine Application\u0027s Log File Format",
  "keyword": "Given "
});
formatter.step({
  "line": 6,
  "name": "Try to Determine Application\u0027s Log File Format",
  "keyword": "When "
});
formatter.step({
  "comments": [
    {
      "line": 7,
      "value": "# assertion for attack step success"
    }
  ],
  "line": 8,
  "name": "Assert the success of Determine Application\u0027s Log File Format",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 9,
      "value": "#assertions for security pattern testing (checker whether the pattern consequences are observed)"
    }
  ],
  "line": 10,
  "name": "assert the consequences of the pattern",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 11,
      "value": "#"
    }
  ],
  "line": 12,
  "name": "assert the consequences of the pattern audit interceptor",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 13,
      "value": "# depends secure logger"
    }
  ],
  "line": 14,
  "name": "assert the consequences of the pattern secure logger",
  "keyword": "Then "
});
formatter.match({
  "location": "determineapplicationslogfileformat.predetermineapplicationslogfileformat()"
});
formatter.result({
  "duration": 52870,
  "status": "passed"
});
formatter.match({
  "location": "determineapplicationslogfileformat.trydetermineapplicationslogfileformat()"
});
formatter.result({
  "duration": 3998,
  "status": "passed"
});
formatter.match({
  "location": "determineapplicationslogfileformat.assdetermineapplicationslogfileformat()"
});
formatter.result({
  "duration": 3387,
  "status": "passed"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({
  "location": "PatternSteps.assauditinterceptor()"
});
formatter.result({
  "status": "skipped"
});
formatter.match({
  "location": "PatternSteps.asssecurelogger()"
});
formatter.result({
  "status": "skipped"
});
formatter.uri("CAPEC_93_Step_2_1.feature");
formatter.feature({
  "line": 2,
  "name": "CAPEC-93: Log Injection-Tampering-Forging",
  "description": "",
  "id": "capec-93:-log-injection-tampering-forging",
  "keyword": "Feature",
  "tags": [
    {
      "line": 1,
      "name": "@capec93"
    }
  ]
});
formatter.scenario({
  "comments": [
    {
      "line": 3,
      "value": "#2. Exploit"
    }
  ],
  "line": 4,
  "name": "Step2.1 Manipulate Log Files",
  "description": "",
  "id": "capec-93:-log-injection-tampering-forging;step2.1-manipulate-log-files",
  "type": "scenario",
  "keyword": "Scenario"
});
formatter.step({
  "line": 5,
  "name": "prepare to Manipulate Log Files",
  "keyword": "Given "
});
formatter.step({
  "line": 6,
  "name": "Try to Manipulate Log Files",
  "keyword": "When "
});
formatter.step({
  "comments": [
    {
      "line": 7,
      "value": "# assertion for attack step success"
    }
  ],
  "line": 8,
  "name": "Assert the success of Manipulate Log Files",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 9,
      "value": "#assertions for security pattern testing (checker whether the pattern consequences are observed)"
    }
  ],
  "line": 10,
  "name": "assert the consequences of the pattern secure logger",
  "keyword": "Then "
});
formatter.step({
  "line": 11,
  "name": "assert the consequences of the pattern application firewall",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 12,
      "value": "# alternative output guard"
    },
    {
      "line": 13,
      "value": "# alternative input guard"
    }
  ],
  "line": 14,
  "name": "assert the consequences of the pattern input guard",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 15,
      "value": "# alternative application firewall"
    },
    {
      "line": 16,
      "value": "# benifits output guard"
    }
  ],
  "line": 17,
  "name": "assert the consequences of the pattern pathname canonicalization",
  "keyword": "Then "
});
formatter.step({
  "line": 18,
  "name": "assert the consequences of the pattern output guard",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 19,
      "value": "# alternative application firewall"
    },
    {
      "line": 20,
      "value": "# benifits input guard"
    }
  ],
  "line": 21,
  "name": "assert the consequences of the pattern comparator checked fault tolerant system",
  "keyword": "Then "
});
formatter.match({
  "location": "manipulatelogfiles.premanipulatelogfiles()"
});
formatter.result({
  "duration": 24759,
  "status": "passed"
});
formatter.match({
  "location": "manipulatelogfiles.trymanipulatelogfiles()"
});
formatter.result({
  "duration": 3595,
  "status": "passed"
});
formatter.match({
  "location": "manipulatelogfiles.assmanipulatelogfiles()"
});
formatter.result({
  "duration": 3437,
  "status": "passed"
});
formatter.match({
  "location": "PatternSteps.asssecurelogger()"
});
formatter.result({
  "duration": 10018,
  "status": "passed"
});
formatter.match({
  "location": "PatternSteps.assapplicationfirewall()"
});
formatter.result({
  "duration": 4083,
  "status": "passed"
});
formatter.match({
  "location": "PatternSteps.assinputguard()"
});
formatter.result({
  "duration": 3293,
  "status": "passed"
});
formatter.match({
  "location": "PatternSteps.asspathnamecanonicalization()"
});
formatter.result({
  "duration": 3293,
  "status": "passed"
});
formatter.match({
  "location": "PatternSteps.assoutputguard()"
});
formatter.result({
  "duration": 4300,
  "status": "passed"
});
formatter.match({
  "location": "PatternSteps.asscomparatorcheckedfaulttolerantsystem()"
});
formatter.result({
  "duration": 3944,
  "status": "passed"
});
formatter.uri("CAPEC_94_Step_1_1.feature");
formatter.feature({
  "line": 2,
  "name": "CAPEC-94: Man in the Middle Attack",
  "description": "",
  "id": "capec-94:-man-in-the-middle-attack",
  "keyword": "Feature",
  "tags": [
    {
      "line": 1,
      "name": "@capec94"
    }
  ]
});
formatter.scenario({
  "comments": [
    {
      "line": 3,
      "value": "#1. Experiment"
    }
  ],
  "line": 4,
  "name": "Step1.1",
  "description": "",
  "id": "capec-94:-man-in-the-middle-attack;step1.1",
  "type": "scenario",
  "keyword": "Scenario"
});
formatter.step({
  "line": 5,
  "name": "prepare to",
  "keyword": "Given "
});
formatter.step({
  "line": 6,
  "name": "Try to",
  "keyword": "When "
});
formatter.step({
  "comments": [
    {
      "line": 7,
      "value": "# assertion for attack step success"
    }
  ],
  "line": 8,
  "name": "Assert the success of",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 9,
      "value": "#assertions for security pattern testing (checker whether the pattern consequences are observed)"
    }
  ],
  "line": 10,
  "name": "assert the consequences of the pattern",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 11,
      "value": "#"
    }
  ],
  "line": 12,
  "name": "assert the consequences of the pattern audit interceptor",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 13,
      "value": "# depends secure logger"
    }
  ],
  "line": 14,
  "name": "assert the consequences of the pattern secure logger",
  "keyword": "Then "
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({
  "location": "PatternSteps.assauditinterceptor()"
});
formatter.result({
  "status": "skipped"
});
formatter.match({
  "location": "PatternSteps.asssecurelogger()"
});
formatter.result({
  "status": "skipped"
});
formatter.uri("CAPEC_94_Step_3_1.feature");
formatter.feature({
  "line": 2,
  "name": "CAPEC-94: Man in the Middle Attack",
  "description": "",
  "id": "capec-94:-man-in-the-middle-attack",
  "keyword": "Feature",
  "tags": [
    {
      "line": 1,
      "name": "@capec94"
    }
  ]
});
formatter.scenario({
  "comments": [
    {
      "line": 3,
      "value": "#3. Exploit"
    }
  ],
  "line": 4,
  "name": "Step3.1",
  "description": "",
  "id": "capec-94:-man-in-the-middle-attack;step3.1",
  "type": "scenario",
  "keyword": "Scenario"
});
formatter.step({
  "line": 5,
  "name": "prepare to",
  "keyword": "Given "
});
formatter.step({
  "line": 6,
  "name": "Try to",
  "keyword": "When "
});
formatter.step({
  "comments": [
    {
      "line": 7,
      "value": "# assertion for attack step success"
    }
  ],
  "line": 8,
  "name": "Assert the success of",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 9,
      "value": "#assertions for security pattern testing (checker whether the pattern consequences are observed)"
    }
  ],
  "line": 10,
  "name": "assert the consequences of the pattern",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 11,
      "value": "#"
    }
  ],
  "line": 12,
  "name": "assert the consequences of the pattern audit interceptor",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 13,
      "value": "# depends secure logger"
    }
  ],
  "line": 14,
  "name": "assert the consequences of the pattern secure logger",
  "keyword": "Then "
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({
  "location": "PatternSteps.assauditinterceptor()"
});
formatter.result({
  "status": "skipped"
});
formatter.match({
  "location": "PatternSteps.asssecurelogger()"
});
formatter.result({
  "status": "skipped"
});
formatter.uri("CAPEC_95_Step_1_1.feature");
formatter.feature({
  "line": 2,
  "name": "CAPEC-95: WSDL Scanning",
  "description": "",
  "id": "capec-95:-wsdl-scanning",
  "keyword": "Feature",
  "tags": [
    {
      "line": 1,
      "name": "@capec95"
    }
  ]
});
formatter.scenario({
  "comments": [
    {
      "line": 3,
      "value": "#1. Explore"
    }
  ],
  "line": 4,
  "name": "Step1.1",
  "description": "",
  "id": "capec-95:-wsdl-scanning;step1.1",
  "type": "scenario",
  "keyword": "Scenario"
});
formatter.step({
  "line": 5,
  "name": "prepare to",
  "keyword": "Given "
});
formatter.step({
  "line": 6,
  "name": "Try to",
  "keyword": "When "
});
formatter.step({
  "comments": [
    {
      "line": 7,
      "value": "# assertion for attack step success"
    }
  ],
  "line": 8,
  "name": "Assert the success of",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 9,
      "value": "#assertions for security pattern testing (checker whether the pattern consequences are observed)"
    }
  ],
  "line": 10,
  "name": "assert the consequences of the pattern",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 11,
      "value": "#"
    }
  ],
  "line": 12,
  "name": "assert the consequences of the pattern audit interceptor",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 13,
      "value": "# depends secure logger"
    }
  ],
  "line": 14,
  "name": "assert the consequences of the pattern secure logger",
  "keyword": "Then "
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({
  "location": "PatternSteps.assauditinterceptor()"
});
formatter.result({
  "status": "skipped"
});
formatter.match({
  "location": "PatternSteps.asssecurelogger()"
});
formatter.result({
  "status": "skipped"
});
formatter.uri("CAPEC_95_Step_2_1.feature");
formatter.feature({
  "line": 2,
  "name": "CAPEC-95: WSDL Scanning",
  "description": "",
  "id": "capec-95:-wsdl-scanning",
  "keyword": "Feature",
  "tags": [
    {
      "line": 1,
      "name": "@capec95"
    }
  ]
});
formatter.scenario({
  "comments": [
    {
      "line": 3,
      "value": "#2. Experiment"
    }
  ],
  "line": 4,
  "name": "Step2.1",
  "description": "",
  "id": "capec-95:-wsdl-scanning;step2.1",
  "type": "scenario",
  "keyword": "Scenario"
});
formatter.step({
  "line": 5,
  "name": "prepare to",
  "keyword": "Given "
});
formatter.step({
  "line": 6,
  "name": "Try to",
  "keyword": "When "
});
formatter.step({
  "comments": [
    {
      "line": 7,
      "value": "# assertion for attack step success"
    }
  ],
  "line": 8,
  "name": "Assert the success of",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 9,
      "value": "#assertions for security pattern testing (checker whether the pattern consequences are observed)"
    }
  ],
  "line": 10,
  "name": "assert the consequences of the pattern",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 11,
      "value": "#"
    }
  ],
  "line": 12,
  "name": "assert the consequences of the pattern audit interceptor",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 13,
      "value": "# depends secure logger"
    }
  ],
  "line": 14,
  "name": "assert the consequences of the pattern secure logger",
  "keyword": "Then "
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({
  "location": "PatternSteps.assauditinterceptor()"
});
formatter.result({
  "status": "skipped"
});
formatter.match({
  "location": "PatternSteps.asssecurelogger()"
});
formatter.result({
  "status": "skipped"
});
formatter.uri("CAPEC_95_Step_3_1.feature");
formatter.feature({
  "line": 2,
  "name": "CAPEC-95: WSDL Scanning",
  "description": "",
  "id": "capec-95:-wsdl-scanning",
  "keyword": "Feature",
  "tags": [
    {
      "line": 1,
      "name": "@capec95"
    }
  ]
});
formatter.scenario({
  "comments": [
    {
      "line": 3,
      "value": "#3. Exploit"
    }
  ],
  "line": 4,
  "name": "Step3.1",
  "description": "",
  "id": "capec-95:-wsdl-scanning;step3.1",
  "type": "scenario",
  "keyword": "Scenario"
});
formatter.step({
  "line": 5,
  "name": "prepare to",
  "keyword": "Given "
});
formatter.step({
  "line": 6,
  "name": "Try to",
  "keyword": "When "
});
formatter.step({
  "comments": [
    {
      "line": 7,
      "value": "# assertion for attack step success"
    }
  ],
  "line": 8,
  "name": "Assert the success of",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 9,
      "value": "#assertions for security pattern testing (checker whether the pattern consequences are observed)"
    }
  ],
  "line": 10,
  "name": "assert the consequences of the pattern",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 11,
      "value": "#"
    }
  ],
  "line": 12,
  "name": "assert the consequences of the pattern audit interceptor",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 13,
      "value": "# depends secure logger"
    }
  ],
  "line": 14,
  "name": "assert the consequences of the pattern secure logger",
  "keyword": "Then "
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({
  "location": "PatternSteps.assauditinterceptor()"
});
formatter.result({
  "status": "skipped"
});
formatter.match({
  "location": "PatternSteps.asssecurelogger()"
});
formatter.result({
  "status": "skipped"
});
formatter.uri("CAPEC_96_Step_1_1.feature");
formatter.feature({
  "line": 2,
  "name": "CAPEC-96: Block Access to Libraries",
  "description": "",
  "id": "capec-96:-block-access-to-libraries",
  "keyword": "Feature",
  "tags": [
    {
      "line": 1,
      "name": "@capec96"
    }
  ]
});
formatter.scenario({
  "comments": [
    {
      "line": 3,
      "value": "#1. Explore"
    }
  ],
  "line": 4,
  "name": "Step1.1",
  "description": "",
  "id": "capec-96:-block-access-to-libraries;step1.1",
  "type": "scenario",
  "keyword": "Scenario"
});
formatter.step({
  "line": 5,
  "name": "prepare to",
  "keyword": "Given "
});
formatter.step({
  "line": 6,
  "name": "Try to",
  "keyword": "When "
});
formatter.step({
  "comments": [
    {
      "line": 7,
      "value": "# assertion for attack step success"
    }
  ],
  "line": 8,
  "name": "Assert the success of",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 9,
      "value": "#assertions for security pattern testing (checker whether the pattern consequences are observed)"
    }
  ],
  "line": 10,
  "name": "assert the consequences of the pattern",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 11,
      "value": "#"
    }
  ],
  "line": 12,
  "name": "assert the consequences of the pattern audit interceptor",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 13,
      "value": "# depends secure logger"
    }
  ],
  "line": 14,
  "name": "assert the consequences of the pattern secure logger",
  "keyword": "Then "
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({
  "location": "PatternSteps.assauditinterceptor()"
});
formatter.result({
  "status": "skipped"
});
formatter.match({
  "location": "PatternSteps.asssecurelogger()"
});
formatter.result({
  "status": "skipped"
});
formatter.uri("CAPEC_96_Step_2_1.feature");
formatter.feature({
  "line": 2,
  "name": "CAPEC-96: Block Access to Libraries",
  "description": "",
  "id": "capec-96:-block-access-to-libraries",
  "keyword": "Feature",
  "tags": [
    {
      "line": 1,
      "name": "@capec96"
    }
  ]
});
formatter.scenario({
  "comments": [
    {
      "line": 3,
      "value": "#2. Experiment"
    }
  ],
  "line": 4,
  "name": "Step2.1",
  "description": "",
  "id": "capec-96:-block-access-to-libraries;step2.1",
  "type": "scenario",
  "keyword": "Scenario"
});
formatter.step({
  "line": 5,
  "name": "prepare to",
  "keyword": "Given "
});
formatter.step({
  "line": 6,
  "name": "Try to",
  "keyword": "When "
});
formatter.step({
  "comments": [
    {
      "line": 7,
      "value": "# assertion for attack step success"
    }
  ],
  "line": 8,
  "name": "Assert the success of",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 9,
      "value": "#assertions for security pattern testing (checker whether the pattern consequences are observed)"
    }
  ],
  "line": 10,
  "name": "assert the consequences of the pattern",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 11,
      "value": "#"
    }
  ],
  "line": 12,
  "name": "assert the consequences of the pattern audit interceptor",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 13,
      "value": "# depends secure logger"
    }
  ],
  "line": 14,
  "name": "assert the consequences of the pattern secure logger",
  "keyword": "Then "
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({
  "location": "PatternSteps.assauditinterceptor()"
});
formatter.result({
  "status": "skipped"
});
formatter.match({
  "location": "PatternSteps.asssecurelogger()"
});
formatter.result({
  "status": "skipped"
});
formatter.uri("CAPEC_97_Step_1_1.feature");
formatter.feature({
  "line": 2,
  "name": "CAPEC-97: Cryptanalysis",
  "description": "",
  "id": "capec-97:-cryptanalysis",
  "keyword": "Feature",
  "tags": [
    {
      "line": 1,
      "name": "@capec97"
    }
  ]
});
formatter.scenario({
  "comments": [
    {
      "line": 3,
      "value": "#1. Explore"
    }
  ],
  "line": 4,
  "name": "Step1.1",
  "description": "",
  "id": "capec-97:-cryptanalysis;step1.1",
  "type": "scenario",
  "keyword": "Scenario"
});
formatter.step({
  "line": 5,
  "name": "prepare to",
  "keyword": "Given "
});
formatter.step({
  "line": 6,
  "name": "Try to",
  "keyword": "When "
});
formatter.step({
  "comments": [
    {
      "line": 7,
      "value": "# assertion for attack step success"
    }
  ],
  "line": 8,
  "name": "Assert the success of",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 9,
      "value": "#assertions for security pattern testing (checker whether the pattern consequences are observed)"
    }
  ],
  "line": 10,
  "name": "assert the consequences of the pattern",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 11,
      "value": "#"
    }
  ],
  "line": 12,
  "name": "assert the consequences of the pattern audit interceptor",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 13,
      "value": "# depends secure logger"
    }
  ],
  "line": 14,
  "name": "assert the consequences of the pattern secure logger",
  "keyword": "Then "
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({
  "location": "PatternSteps.assauditinterceptor()"
});
formatter.result({
  "status": "skipped"
});
formatter.match({
  "location": "PatternSteps.asssecurelogger()"
});
formatter.result({
  "status": "skipped"
});
formatter.uri("CAPEC_97_Step_2_1.feature");
formatter.feature({
  "line": 2,
  "name": "CAPEC-97: Cryptanalysis",
  "description": "",
  "id": "capec-97:-cryptanalysis",
  "keyword": "Feature",
  "tags": [
    {
      "line": 1,
      "name": "@capec97"
    }
  ]
});
formatter.scenario({
  "comments": [
    {
      "line": 3,
      "value": "#2. Exploit"
    }
  ],
  "line": 4,
  "name": "Step2.1",
  "description": "",
  "id": "capec-97:-cryptanalysis;step2.1",
  "type": "scenario",
  "keyword": "Scenario"
});
formatter.step({
  "line": 5,
  "name": "prepare to",
  "keyword": "Given "
});
formatter.step({
  "line": 6,
  "name": "Try to",
  "keyword": "When "
});
formatter.step({
  "comments": [
    {
      "line": 7,
      "value": "# assertion for attack step success"
    }
  ],
  "line": 8,
  "name": "Assert the success of",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 9,
      "value": "#assertions for security pattern testing (checker whether the pattern consequences are observed)"
    }
  ],
  "line": 10,
  "name": "assert the consequences of the pattern",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 11,
      "value": "#"
    }
  ],
  "line": 12,
  "name": "assert the consequences of the pattern audit interceptor",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 13,
      "value": "# depends secure logger"
    }
  ],
  "line": 14,
  "name": "assert the consequences of the pattern secure logger",
  "keyword": "Then "
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({
  "location": "PatternSteps.assauditinterceptor()"
});
formatter.result({
  "status": "skipped"
});
formatter.match({
  "location": "PatternSteps.asssecurelogger()"
});
formatter.result({
  "status": "skipped"
});
formatter.uri("CAPEC_98_Step_1_1.feature");
formatter.feature({
  "line": 2,
  "name": "CAPEC-98: Phishing",
  "description": "",
  "id": "capec-98:-phishing",
  "keyword": "Feature",
  "tags": [
    {
      "line": 1,
      "name": "@capec98"
    }
  ]
});
formatter.scenario({
  "comments": [
    {
      "line": 3,
      "value": "#1. Explore"
    }
  ],
  "line": 4,
  "name": "Step1.1 Obtain domain name and certificate to spoof legitimate site",
  "description": "",
  "id": "capec-98:-phishing;step1.1-obtain-domain-name-and-certificate-to-spoof-legitimate-site",
  "type": "scenario",
  "keyword": "Scenario"
});
formatter.step({
  "line": 5,
  "name": "prepare to Obtain domain name and certificate to spoof legitimate site",
  "keyword": "Given "
});
formatter.step({
  "line": 6,
  "name": "Try to Obtain domain name and certificate to spoof legitimate site",
  "keyword": "When "
});
formatter.step({
  "comments": [
    {
      "line": 7,
      "value": "# assertion for attack step success"
    }
  ],
  "line": 8,
  "name": "Assert the success of Obtain domain name and certificate to spoof legitimate site",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 9,
      "value": "#assertions for security pattern testing (checker whether the pattern consequences are observed)"
    }
  ],
  "line": 10,
  "name": "assert the consequences of the pattern",
  "keyword": "Then "
});
formatter.match({
  "location": "obtaindomainnameandcertificatetospooflegitimatesite.preobtaindomainnameandcertificatetospooflegitimatesite()"
});
formatter.result({
  "duration": 88426,
  "status": "passed"
});
formatter.match({
  "location": "obtaindomainnameandcertificatetospooflegitimatesite.tryobtaindomainnameandcertificatetospooflegitimatesite()"
});
formatter.result({
  "duration": 6097,
  "status": "passed"
});
formatter.match({
  "location": "obtaindomainnameandcertificatetospooflegitimatesite.assobtaindomainnameandcertificatetospooflegitimatesite()"
});
formatter.result({
  "duration": 4765,
  "status": "passed"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.uri("CAPEC_98_Step_1_2.feature");
formatter.feature({
  "line": 2,
  "name": "CAPEC-98: Phishing",
  "description": "",
  "id": "capec-98:-phishing",
  "keyword": "Feature",
  "tags": [
    {
      "line": 1,
      "name": "@capec98"
    }
  ]
});
formatter.scenario({
  "comments": [
    {
      "line": 3,
      "value": "#1. Explore"
    }
  ],
  "line": 4,
  "name": "Step1.2 Explore legitimate website and create duplicate",
  "description": "",
  "id": "capec-98:-phishing;step1.2-explore-legitimate-website-and-create-duplicate",
  "type": "scenario",
  "keyword": "Scenario"
});
formatter.step({
  "line": 5,
  "name": "prepare to Explore legitimate website and create duplicate",
  "keyword": "Given "
});
formatter.step({
  "line": 6,
  "name": "Try to Explore legitimate website and create duplicate",
  "keyword": "When "
});
formatter.step({
  "comments": [
    {
      "line": 7,
      "value": "# assertion for attack step success"
    }
  ],
  "line": 8,
  "name": "Assert the success of Explore legitimate website and create duplicate",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 9,
      "value": "#assertions for security pattern testing (checker whether the pattern consequences are observed)"
    }
  ],
  "line": 10,
  "name": "assert the consequences of the pattern",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 11,
      "value": "#"
    }
  ],
  "line": 12,
  "name": "assert the consequences of the pattern audit interceptor",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 13,
      "value": "# depends secure logger"
    }
  ],
  "line": 14,
  "name": "assert the consequences of the pattern secure logger",
  "keyword": "Then "
});
formatter.match({
  "location": "explorelegitimatewebsiteandcreateduplicate.preexplorelegitimatewebsiteandcreateduplicate()"
});
formatter.result({
  "duration": 84510,
  "status": "passed"
});
formatter.match({
  "location": "explorelegitimatewebsiteandcreateduplicate.tryexplorelegitimatewebsiteandcreateduplicate()"
});
formatter.result({
  "duration": 7254,
  "status": "passed"
});
formatter.match({
  "location": "explorelegitimatewebsiteandcreateduplicate.assexplorelegitimatewebsiteandcreateduplicate()"
});
formatter.result({
  "duration": 5776,
  "status": "passed"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({
  "location": "PatternSteps.assauditinterceptor()"
});
formatter.result({
  "status": "skipped"
});
formatter.match({
  "location": "PatternSteps.asssecurelogger()"
});
formatter.result({
  "status": "skipped"
});
formatter.uri("CAPEC_98_Step_2_1.feature");
formatter.feature({
  "line": 2,
  "name": "CAPEC-98: Phishing",
  "description": "",
  "id": "capec-98:-phishing",
  "keyword": "Feature",
  "tags": [
    {
      "line": 1,
      "name": "@capec98"
    }
  ]
});
formatter.scenario({
  "comments": [
    {
      "line": 3,
      "value": "#2. Exploit"
    }
  ],
  "line": 4,
  "name": "Step2.1 Convince user to enter sensitive information on attacker\u0027s site.",
  "description": "",
  "id": "capec-98:-phishing;step2.1-convince-user-to-enter-sensitive-information-on-attacker\u0027s-site.",
  "type": "scenario",
  "keyword": "Scenario"
});
formatter.step({
  "line": 5,
  "name": "prepare to Convince user to enter sensitive information on attacker\u0027s site.",
  "keyword": "Given "
});
formatter.step({
  "line": 6,
  "name": "Try to Convince user to enter sensitive information on attacker\u0027s site.",
  "keyword": "When "
});
formatter.step({
  "comments": [
    {
      "line": 7,
      "value": "# assertion for attack step success"
    }
  ],
  "line": 8,
  "name": "Assert the success of Convince user to enter sensitive information on attacker\u0027s site.",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 9,
      "value": "#assertions for security pattern testing (checker whether the pattern consequences are observed)"
    }
  ],
  "line": 10,
  "name": "assert the consequences of the pattern secure logger",
  "keyword": "Then "
});
formatter.match({
  "location": "convinceusertoentersensitiveinformationonattackerssite.preconvinceusertoentersensitiveinformationonattackerssite()"
});
formatter.result({
  "duration": 30489,
  "status": "passed"
});
formatter.match({
  "location": "convinceusertoentersensitiveinformationonattackerssite.tryconvinceusertoentersensitiveinformationonattackerssite()"
});
formatter.result({
  "duration": 3715,
  "status": "passed"
});
formatter.match({
  "location": "convinceusertoentersensitiveinformationonattackerssite.assconvinceusertoentersensitiveinformationonattackerssite()"
});
formatter.result({
  "duration": 3738,
  "status": "passed"
});
formatter.match({
  "location": "PatternSteps.asssecurelogger()"
});
formatter.result({
  "duration": 12207,
  "status": "passed"
});
formatter.uri("CAPEC_98_Step_2_2.feature");
formatter.feature({
  "line": 2,
  "name": "CAPEC-98: Phishing",
  "description": "",
  "id": "capec-98:-phishing",
  "keyword": "Feature",
  "tags": [
    {
      "line": 1,
      "name": "@capec98"
    }
  ]
});
formatter.scenario({
  "comments": [
    {
      "line": 3,
      "value": "#2. Exploit"
    }
  ],
  "line": 4,
  "name": "Step2.2 Use stolen credentials to log into legitimate site",
  "description": "",
  "id": "capec-98:-phishing;step2.2-use-stolen-credentials-to-log-into-legitimate-site",
  "type": "scenario",
  "keyword": "Scenario"
});
formatter.step({
  "line": 5,
  "name": "prepare to Use stolen credentials to log into legitimate site",
  "keyword": "Given "
});
formatter.step({
  "line": 6,
  "name": "Try to Use stolen credentials to log into legitimate site",
  "keyword": "When "
});
formatter.step({
  "comments": [
    {
      "line": 7,
      "value": "# assertion for attack step success"
    }
  ],
  "line": 8,
  "name": "Assert the success of Use stolen credentials to log into legitimate site",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 9,
      "value": "#assertions for security pattern testing (checker whether the pattern consequences are observed)"
    }
  ],
  "line": 10,
  "name": "assert the consequences of the pattern",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 11,
      "value": "#"
    }
  ],
  "line": 12,
  "name": "assert the consequences of the pattern secure logger",
  "keyword": "Then "
});
formatter.match({
  "location": "usestolencredentialstologintolegitimatesite.preusestolencredentialstologintolegitimatesite()"
});
formatter.result({
  "duration": 13197,
  "status": "passed"
});
formatter.match({
  "location": "usestolencredentialstologintolegitimatesite.tryusestolencredentialstologintolegitimatesite()"
});
formatter.result({
  "duration": 3362,
  "status": "passed"
});
formatter.match({
  "location": "usestolencredentialstologintolegitimatesite.assusestolencredentialstologintolegitimatesite()"
});
formatter.result({
  "duration": 3369,
  "status": "passed"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({
  "location": "PatternSteps.asssecurelogger()"
});
formatter.result({
  "status": "skipped"
});
formatter.uri("CAPEC_99_Step_1_1.feature");
formatter.feature({
  "line": 2,
  "name": "CAPEC-99: XML Parser Attack",
  "description": "",
  "id": "capec-99:-xml-parser-attack",
  "keyword": "Feature",
  "tags": [
    {
      "line": 1,
      "name": "@capec99"
    }
  ]
});
formatter.scenario({
  "comments": [
    {
      "line": 3,
      "value": "#1. Explore"
    }
  ],
  "line": 4,
  "name": "Step1.1",
  "description": "",
  "id": "capec-99:-xml-parser-attack;step1.1",
  "type": "scenario",
  "keyword": "Scenario"
});
formatter.step({
  "line": 5,
  "name": "prepare to",
  "keyword": "Given "
});
formatter.step({
  "line": 6,
  "name": "Try to",
  "keyword": "When "
});
formatter.step({
  "comments": [
    {
      "line": 7,
      "value": "# assertion for attack step success"
    }
  ],
  "line": 8,
  "name": "Assert the success of",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 9,
      "value": "#assertions for security pattern testing (checker whether the pattern consequences are observed)"
    }
  ],
  "line": 10,
  "name": "assert the consequences of the pattern",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 11,
      "value": "#"
    }
  ],
  "line": 12,
  "name": "assert the consequences of the pattern audit interceptor",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 13,
      "value": "# depends secure logger"
    }
  ],
  "line": 14,
  "name": "assert the consequences of the pattern secure logger",
  "keyword": "Then "
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({
  "location": "PatternSteps.assauditinterceptor()"
});
formatter.result({
  "status": "skipped"
});
formatter.match({
  "location": "PatternSteps.asssecurelogger()"
});
formatter.result({
  "status": "skipped"
});
formatter.uri("CAPEC_99_Step_2_1.feature");
formatter.feature({
  "line": 2,
  "name": "CAPEC-99: XML Parser Attack",
  "description": "",
  "id": "capec-99:-xml-parser-attack",
  "keyword": "Feature",
  "tags": [
    {
      "line": 1,
      "name": "@capec99"
    }
  ]
});
formatter.scenario({
  "comments": [
    {
      "line": 3,
      "value": "#2. Experiment"
    }
  ],
  "line": 4,
  "name": "Step2.1",
  "description": "",
  "id": "capec-99:-xml-parser-attack;step2.1",
  "type": "scenario",
  "keyword": "Scenario"
});
formatter.step({
  "line": 5,
  "name": "prepare to",
  "keyword": "Given "
});
formatter.step({
  "line": 6,
  "name": "Try to",
  "keyword": "When "
});
formatter.step({
  "comments": [
    {
      "line": 7,
      "value": "# assertion for attack step success"
    }
  ],
  "line": 8,
  "name": "Assert the success of",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 9,
      "value": "#assertions for security pattern testing (checker whether the pattern consequences are observed)"
    }
  ],
  "line": 10,
  "name": "assert the consequences of the pattern",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 11,
      "value": "#"
    }
  ],
  "line": 12,
  "name": "assert the consequences of the pattern audit interceptor",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 13,
      "value": "# depends secure logger"
    }
  ],
  "line": 14,
  "name": "assert the consequences of the pattern secure logger",
  "keyword": "Then "
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({
  "location": "PatternSteps.assauditinterceptor()"
});
formatter.result({
  "status": "skipped"
});
formatter.match({
  "location": "PatternSteps.asssecurelogger()"
});
formatter.result({
  "status": "skipped"
});
formatter.uri("CAPEC_9_Step_1_1.feature");
formatter.feature({
  "line": 2,
  "name": "CAPEC-9: Buffer Overflow in Local Command-Line Utilities",
  "description": "",
  "id": "capec-9:-buffer-overflow-in-local-command-line-utilities",
  "keyword": "Feature",
  "tags": [
    {
      "line": 1,
      "name": "@capec9"
    }
  ]
});
formatter.scenario({
  "comments": [
    {
      "line": 3,
      "value": "#1. Explore"
    }
  ],
  "line": 4,
  "name": "Step1.1",
  "description": "",
  "id": "capec-9:-buffer-overflow-in-local-command-line-utilities;step1.1",
  "type": "scenario",
  "keyword": "Scenario"
});
formatter.step({
  "line": 5,
  "name": "prepare to",
  "keyword": "Given "
});
formatter.step({
  "line": 6,
  "name": "Try to",
  "keyword": "When "
});
formatter.step({
  "comments": [
    {
      "line": 7,
      "value": "# assertion for attack step success"
    }
  ],
  "line": 8,
  "name": "Assert the success of",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 9,
      "value": "#assertions for security pattern testing (checker whether the pattern consequences are observed)"
    }
  ],
  "line": 10,
  "name": "assert the consequences of the pattern",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 11,
      "value": "#"
    }
  ],
  "line": 12,
  "name": "assert the consequences of the pattern audit interceptor",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 13,
      "value": "# depends secure logger"
    }
  ],
  "line": 14,
  "name": "assert the consequences of the pattern secure logger",
  "keyword": "Then "
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({
  "location": "PatternSteps.assauditinterceptor()"
});
formatter.result({
  "status": "skipped"
});
formatter.match({
  "location": "PatternSteps.asssecurelogger()"
});
formatter.result({
  "status": "skipped"
});
formatter.uri("CAPEC_9_Step_2_1.feature");
formatter.feature({
  "line": 2,
  "name": "CAPEC-9: Buffer Overflow in Local Command-Line Utilities",
  "description": "",
  "id": "capec-9:-buffer-overflow-in-local-command-line-utilities",
  "keyword": "Feature",
  "tags": [
    {
      "line": 1,
      "name": "@capec9"
    }
  ]
});
formatter.scenario({
  "comments": [
    {
      "line": 3,
      "value": "#2. Experiment"
    }
  ],
  "line": 4,
  "name": "Step2.1",
  "description": "",
  "id": "capec-9:-buffer-overflow-in-local-command-line-utilities;step2.1",
  "type": "scenario",
  "keyword": "Scenario"
});
formatter.step({
  "line": 5,
  "name": "prepare to",
  "keyword": "Given "
});
formatter.step({
  "line": 6,
  "name": "Try to",
  "keyword": "When "
});
formatter.step({
  "comments": [
    {
      "line": 7,
      "value": "# assertion for attack step success"
    }
  ],
  "line": 8,
  "name": "Assert the success of",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 9,
      "value": "#assertions for security pattern testing (checker whether the pattern consequences are observed)"
    }
  ],
  "line": 10,
  "name": "assert the consequences of the pattern",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 11,
      "value": "#"
    }
  ],
  "line": 12,
  "name": "assert the consequences of the pattern audit interceptor",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 13,
      "value": "# depends secure logger"
    }
  ],
  "line": 14,
  "name": "assert the consequences of the pattern secure logger",
  "keyword": "Then "
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({
  "location": "PatternSteps.assauditinterceptor()"
});
formatter.result({
  "status": "skipped"
});
formatter.match({
  "location": "PatternSteps.asssecurelogger()"
});
formatter.result({
  "status": "skipped"
});
formatter.uri("CAPEC_9_Step_3_1.feature");
formatter.feature({
  "line": 2,
  "name": "CAPEC-9: Buffer Overflow in Local Command-Line Utilities",
  "description": "",
  "id": "capec-9:-buffer-overflow-in-local-command-line-utilities",
  "keyword": "Feature",
  "tags": [
    {
      "line": 1,
      "name": "@capec9"
    }
  ]
});
formatter.scenario({
  "comments": [
    {
      "line": 3,
      "value": "#3. Exploit"
    }
  ],
  "line": 4,
  "name": "Step3.1",
  "description": "",
  "id": "capec-9:-buffer-overflow-in-local-command-line-utilities;step3.1",
  "type": "scenario",
  "keyword": "Scenario"
});
formatter.step({
  "line": 5,
  "name": "prepare to",
  "keyword": "Given "
});
formatter.step({
  "line": 6,
  "name": "Try to",
  "keyword": "When "
});
formatter.step({
  "comments": [
    {
      "line": 7,
      "value": "# assertion for attack step success"
    }
  ],
  "line": 8,
  "name": "Assert the success of",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 9,
      "value": "#assertions for security pattern testing (checker whether the pattern consequences are observed)"
    }
  ],
  "line": 10,
  "name": "assert the consequences of the pattern",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 11,
      "value": "#"
    }
  ],
  "line": 12,
  "name": "assert the consequences of the pattern audit interceptor",
  "keyword": "Then "
});
formatter.step({
  "comments": [
    {
      "line": 13,
      "value": "# depends secure logger"
    }
  ],
  "line": 14,
  "name": "assert the consequences of the pattern secure logger",
  "keyword": "Then "
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({});
formatter.result({
  "status": "undefined"
});
formatter.match({
  "location": "PatternSteps.assauditinterceptor()"
});
formatter.result({
  "status": "skipped"
});
formatter.match({
  "location": "PatternSteps.asssecurelogger()"
});
formatter.result({
  "status": "skipped"
});
});